
# 1. Master/Slave 기법
  - DB안의 데이터를 물리적으로 복사해서 다른 곳에 넣어두는 기술을 의미


  ## 1.1 단일 서버의 한계
  - 트래픽이 폭팔적으로 증가하는 경우 장애 발생 확률이 높음
  - 트래픽으로 인해 쿼리 수행(긴 쿼리/쓰기 작업) 빈도가 높아지면 작업 병목이 발생
    - DB Connection Timeout 발생


  ## 1.2 MySQL Replication
  - 2대 이상의 DBMS를 나눠서 데이터를 저장하는 방식, Master/Slave로 구성해야 함
  
  **Master DBMS 역할**
  - 웹서버로 부터 데이터 CREATE, UPDATE, DELETE 요청시 바이너리 로그를 생성하여 Slave서버로 전달
  - 주로 CREATE, UPDATE, DELETE 용으로 사용
  
  **Slave DBMS 역할**
  - Master DBMS로부터 전달받은 바이로그를 데이터로 반영
  - 주로 SELECT 용으로 이용

   ### 1.2.1 Replication의 장점
   - 가용성이 증가
     - Master DB가 죽을 경우, Slave 서버를 Master로 승격시켜 서비스를 복구할 수 있음
   - 부하분산이 가능(스케일 아웃)
     - Master DB에서는 WRITE(CUD), Slave DB에서는 Read(SELECT) 작업을 처리하게하여 부하 분산 가능
       - CQRS: 데이터 저장소로부터의 일긱와 업데이트 작업을 분리하는 패턴
   - 데이터 보호
     - 복제 과정을 중단하고 Slave에서 백업 서비스를 가동할 수 있음
   ### 1.2.2 동작 원리

    1. Client가 쓰기 쿼리 작업을 요청(수신 Master)
    2. Master는 변경사항을 Binary Log 파일에 기록 이후 DB에 Commit
    3. Slave는 현재까지 기록한 이벤트 정보를 가지고 다음 이벤트 정보를 Master에게 요청
    4. Master는 Binary Log 파일에서 최신 이벤트 정보를 읽어 Slave에 전송
    5. Slave는 Master에게 받은 이벤트 정보를 Relay Log 파일에 기록
    6. Slave는 최종 변경사항을 DB에 반영
   
   ### 1.2.3 방식
  - Async: Master DB에 commit 을 한 후 replication 과정
  - semi-sync: Slave가 Relay log 파일에 이벤트를 기록했는지 확인된 이후 Master DB Commit

   ### 궁금한 것
  - 만약 Master DB를 CUD 작업을 하고 Slave DB를 SELECT로 해온다고 했을 때 Slave DB에 데이터 반영이 안된 상태에서 SELECT가 들어올 경우 어떻게 되는 것인지?
    - Semi-Sync 방식을 사용해서 Slave에 전송한 후 처리할 수 있도록 사용
    - Slave DB에서 SELECT  쿼리를 실행하기전 복제 지연을 확인하고 필요한 경우 지연 시간동안 쿼리를 대기

# 2. Sharding
  - 한 테이블의 row들을 여러 개의 서로 다른 테이블, 즉 파티션으로 물리적으로 분리
  - row들을 여러 개의 서로 다른 테이블로 분해 하는 것이기 때문에 한 테이블을 Horizontal Partitioning 했다고 볼 수 있음
  - 하나로 구성될 스키마를 다수의 복제본으로 구성하고 각각의 샤드에 어떤 데이터가 저장될지 샤드키를 기준으로 분리
  ## 2.1 샤딩의 장 단점
  **장점**
  - 스케일 아웃이 가능
  - 스캔 범위를 줄여서 쿼리 반응 속도를 빠르게 함
  - 장애가 샤드 단위로 발생
  
  **단점**
  - 프로그래밍 복잡도 증가
  - 데이터가 한 쪽 샤드로 몰릴 경우(핫 스팟) 샤딩이 무의미
  - 잘 못 사용할 경우 리스크가 큼
  - 한번 샤딩 사용시 샤딩 이전의 구조로 돌아가기 힘듦

 -> 샤딩은 프로그래밍, 운영적 복잡도가 높아져 가능하면 샤딩을 피해 스케일 업, Read의 부하가 클 경우 Replication, 테이블의 일부 컬럼만 주로 사용할 경우 Vartical Patitioning 등의 방법이 있음
  ## 2.2 샤딩 방식
  ### 2.2.1 Hash Sharding
  - 데이터베이스의 id를 hasing 샤딩하는 방식
  - 샤드키를 id % num을 하여 정하는 방식

  ### 2.2.2 Dynamic Sharding
  - Locator Service를 통하여 샤드 키를 정하는 방식
  
  ### 2.2.3 Entity Group
  - 동일한 파티션에 관련 엔티티를 저장하여 단일 파티션 안에서 추가 기능을 제공하는 방식

# 3. NoSQL
  ## 3.1 NoSQL의 개념
  - Not Only SQL의 약자로 비관계형 데이터베이스를 지칭
  - 대량의 분산된 비정형 데이터를 저장하고 조회하는데 특화된 데이터베이스
    - 주로 빅데이터, 분산 시스템 환경에서 대용량의 데이터를 처리하는데 적합
  ### 3.1.1 NoSQL의 특징
  - RDBMS와 달리 데이터 간의 관계를 정의하지 않음.
  - RDBMS에 비해 대용량의 데이터를 저장 가능
  - 분산형 구조로 설계
  - 고정되어 있지 않은 테이블 스키마를 갖음

  ### 3.1.2 NoSQL 장단점
  **장점**
  - RDBMS에 비해 저렴한 비용으로 분산처리와 병렬 처리가 가능
  - 비정형 데이터 구조 설계로 설계 비용이 감소
  - Big Data 처리에 효과적
  - 가변적인 구조로 데이터 저장이 가능

  **단점**
  - 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능
  - 많은 인덱스를 사용하려면 충분한 메모리가 필요
  - 데이터 일관성이 항상 보장되지 않음.

  ### 3.1.3 NoSQL의 종류
  1. Key-Value: Redis, Oracle NoSQL
  - Key-Value 하나의 묶음으로 저장되는 구조로 단순한 구조여서 속도가 빠르며 분산 저장 시 용이
  2. Wide-Column: Hbase, GoogleBigTable
  - 행마다 키와 해당 값을 저장할 때마다 각각 다른 값의 다른 수의 스키마를 가질 수 있음.
  3. Document Database: MongoDB
  - 테이블의 스키마가 유동적, 즉 레코드마다 가각ㄱ 다른 스키마를 가질 수 있음.
  4. Graph Datbase: OrientDB
  - 데이터를 노드로 표현하며 노드 사이의 관계를 엣지로 표현
  

  ## 3.2 RDB VS NoSQL
  
  - RDB: 데이터 중복 감소, NoSQL: 확장 가능성
  - RDB: 엄격한 데이터 구조, NoSQL: 유연한 데이터 구조
  
  ### 3.2.1 NoSQL과 RDB는 언제 사용하는 것이 좋을까?
  - NoSQL -> 정확한 데이터 구조가 정해지지 않고, 데이터의 Update가 자주 이루어지지 않으며, 조회가 많은 경우 Scale-out이 가능하므로 데이터 양이 많은 경우 사용하면 좋음

  - RDB -> 데이터 구조가 명확하여 변경될 여지가 없는 경우, 또 데이터 중복이 없으므로 Update가 잦은 시스템에서 사용하면 좋음

  ## 3.3 Redis 동작원리
  - Redis란 In-Memory Store로써, 다양한 자료구조를 제공하고 빠른 데이터 입출력을 제공
    - 기본적으로 Key-Value 구조(문자열 뿐만 아니라 리스트, 세트, 해시)
  - Redis는 싱글 스레드 -> 앞의 긴 명령이 들어오는 경우 앞에 명령어가 처리 될 때까지 사용 불가 
    - 하지만 get, set 명령어의 경우 초당 10만개 이상 처리할 수 있을만큼 빠름


# 질문
### 1. Master/Slave 기법이 뭔지 설명해주시고 왜 사용하는지 알려주세요.
Master/Slave 기법은 DB안의 데이터를 물리적으로 복사해서 다른 곳에 넣어두는 기술을 의미합니다.
보통 일반적인 트래픽이 유지되는 곳은 하나의 단일 서버를 이용해서 사용해도 문제 없지만, 갑자기 트래픽이 폭주하는 경우 단일 장애점이 되어 복구할 수 없는 상황이 발생할 수도 있습니다. 이때 Master/Slave로 2대 이상의 서버를 구성하게 된다면 Master가 죽어도 Slave가 Master로 승격되어 사용되어 질 수 있습니다. 또한 Master/Slave로 나누고 CUD는 Master SELECT만 Slave가 하게하여 부하 분산을 할 수 있습니다.

### 2. Master/Slave의 방식 두가지를 이야기 해주세요.
  첫번째는 Async로 Master DB에 commit 을 한 후 replication 과정을 하는 것이고
  두번째 semi sync는 Slave가 Relay log 파일에 이벤트를 기록했는지 확인된 이후 Master DB가 Commit하는 과정입니다. Async의 경우 Slave에 반영되기 전에 Master Commit을 하는 것이기 때문에 CUD와 SELECT를 분리하는 경우 Slave에서 해당 데이터를 못 읽어오는 경우가 생길 수도 있습니다.

### 3. 샤딩이 무엇인지 설명해주세요.
한 테이블의 row들을 여러 개의 서로 다른 테이블, 즉 파티션으로 물리적으로 분리하는 것 입니다.
row들을 여러 개의 서로 다른 테이블로 분해 하는 것이기 때문에 한 테이블을 Horizontal Partitioning 했다고 볼 수 있으며
하나로 구성될 스키마를 다수의 복제본으로 구성하고, 각각의 샤드에 어떤 데이터가 저장될지 샤드키를 기준으로 분리합니다.


### 4. 샤딩의 장 단점에 대해서 알려주세요.
장점으로는 스케일 아웃이 가능하고, 스캔 범위를 줄여서 쿼리 반응 속도를 빠르게 할 수 있습니다. 또한 장애가 샤드 단위로 일어납니다. 하지만 단점으로는 프로그래밍 복잡도가 증가하고, 데이터가 한쪽에 몰릴 경우 샤딩이 무의미해질 수 있습니다.

### 5. NoSQL이 뭔지 설명해주세요.
NoSQL이란 Not Only SQL의 약자로 비관계형 데이터베이스를 뜻합니다. 비관계형 데이터베이스란 관계를 맺지않는 정형화되지 않은 데이터베이스로 대량의 분산된 비정형 데이터를 저장하고 조회하는데 특화된 데이터베이스 입니다.

### 6. NoSQL이랑 RDB의 차이점에 대해서 설명해주세요.
RDB의 경우 우선 데이터 중복 감소를 목적으로 만들어서 데이터가 유일성을 띄는 경우가 많지만 NoSQL은 반대로 중복되는 데이터가 많을 수 있습니다. 또한 RDBMS의 경우 엄격한 데이터 구조를 가지고 있고 NoSQL은 유연한 데이터 구조로 인해 매 레코드마다 다른 형식의 데이터가 들어갈 수 있습니다.