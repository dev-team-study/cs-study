## 04. 인덱스
### 키워드

- 인덱스
  - 인덱스 개념
  - 인덱스 종류
  - Clustered index, Non-Clustered index
  - 인덱스 자료구조


# 4 인덱스
## 4.1 인덱스 개념
- 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
- 책의 색인 처럼 모든 페이지를 찾아볼 수 없으므로 색인을 보고 바로 해당 페이지를 찾는 것과 비슷함
- index를 사용하지 않는 컬럼을 조회시 Full Scan으로 성능 저하
- index는 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 선택할 수 있어서 INSERT, UPDATE, DELETE시 아래와 같은 오버헤드가 발생
  - INSERT: 새로운 데이터에 대한 인덱스를 추가
  - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행
  - UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가
- 결론적으로 INSERT, UPDATE, DELETE의 성능을 희생하고 그대신 데이터 읽기 속도를 높이는 기능(데이터가 변경될 때 마다 값을 정렬시켜야히기 때문에)

### 4.1.1 장점
- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있음
- 전반적인 시스템의 부하를 줄일 수 있음

### 4.1.2 단점
- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요
- 인덱스를 관리하기 위해 추가 작업이 필요
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과 발생 가능성

### 4.1.3 인덱스를 사용하면 좋은 경우
- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

## 4.2 인덱스 종류
### 4.2.1 Clustered Index
- 키 값에 대한 테이블의 데이터 행을 정렬하는 인덱스
- 테이블의 데이터를 정렬해서 실제 물리적으로 저장되는 순서를 정의
- 테이블당 하나만 생성 가능
- PRIMARY KEY에 의해 자동으로 생성, UNIQUE NOT NULL에 의해 자동으로 생성

### 4.2.2 보조 인덱스(Non-Clustered Index)
- 데이터와 인덱스를 각각 다른 위치에 저장
- UNIQUE, UNIQUE NULL에 의해 자동 생성
- 찾아보기가 있는 일반 책과 같음
- 테이블 당 여러개 생성 가능


## 4.4 인덱스 자료구조
### 4.4.1 Hash
- Key, Value로 데이터를 저장하는 자료구조
- 빠른 데이터 검색이 필요할 때 유용
- key값을 이용해 고유한 Index를 생성하여, 그 Index에 저장된 값을 꺼내오는 구조
- 평균적으로 O(1)의 매우 빠른시간만에 원하는 데이터를 탐색할 수 있는 구조
- 해시 테이블은 주로 사용이 안되는데 이유는 등호 연산에 최적화 되어있기 때문임
  - 실제로 DB내에서는 부등호 연산이 자주 사용됨

### 4.4.2 B-Tree
- DB인덱스 위해, 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조
- 기존의 B-Tree는 어느 한 데이터의 검색은 효율적이나 모든 데이터를 한 번 순회하는데에는 트리의 모든 노드를 방문해야하므로 비효율적
- 이것을 개선시켜 leaf node에만 데이터를 저장하고 리프 노드끼리 링크드 리스트로 연결


# 질문
### 1. 인덱스란 무엇인가요?
데이터베이스 테이블의 검색 속도를 향상하기 위한 자료구조입니다. 기본적으로 인덱스 없이 데이터를 검색하려면 테이블을 전체 스캔해야하지만 책의 색인 처럼 정렬하여 해당 부분 페이지만 딱 찾아갈 수 있는 것 처럼 키와 값의 쌍으로 인덱스를 생성할 수 있습니다.

### 2. 인덱스의 장점과 단점은 무엇인가요?
우선 장점으로는 테이블을 조회하는 속도를 향상 시킬 수 있고, 시스템의 전반적인 부하를 줄일 수 있습니다. 그 반대인 단점으로는 인덱스를 관리하기 위해 DB에 추가적인 저장공간이 필요하게되고, 관리하기 위해 추가 작어이 필요합니다. 인덱스를 잘못사용하면 오히려 성능이 저하될 수 있습니다.

### 3. 인덱스를 잘못사용하면 오히려 성능이 저하될 수 있다고 말씀하셨는데 그런 경우가 언제인가요?
INSERT, DELETE, UPDATE 쿼리문을 실행할 때는 별도의 과정이 추가적으로 발생합니다. 예를 들어 INSERT의 경우 인덱스 데이터를 추가하는데, DELETE의 경우 인덱스에 존재하는 값을 삭제하지 않고 사용하지 않는다는 표시만 하게됩니다. 그럼 10만개의 데이터여도 100만개의 인덱스가 있을 수도 있게되는 것이죠. UPDATE의 경우에도 인덱스를 새로 추가하고 변경 전 데이터도 사용하지 않음으로 바꿔야하는 작업을 해야합니다.

그리고 데이터의 형식에 따라서도 달라지는데 예를 들어 이름, 성별 2개의 필드가 있을 때 성별 같은 필드에 인덱스를 걸어버리게 되면 인덱스의 기능을 할 수 없을 것 입니다.

### 4. 클러스터 인덱스와 논 클러스터 인덱스에 대해 설명해주세요.
클러스터 인덱스는 인덱스 종류의 하나로써 테이블당 1개씩 허용되고 PK를 설정하게되면 해당 PK 컬럼으로 클러스터 인덱스가 만들어집니다. 클러스터 인덱스로 저장될 경우 인덱스가 저장될 때 정렬되면 실제 데이터를 디스크에 기록할 때도 데이터가 정렬됩니다. 논 클러스터 인덱스보다 검색속도에 능하지만 입력, 수정, 삭제는 느립니다.

논 클러스터 인덱스의 경우 여러개 생성이 가능하고, 디스크에는 정렬되어 저장되지 않고 인덱스 페이지에만 정렬되어있습니다. 또한 데이터 페이지를 건드는 것이 아니라 별도의 장소에 인덱스 페이지를 추가하므로 용량을 더 차지하게 됩니다.

결국 클러스터 인덱스는 데이터 위치를 바로 알기 때문에 데이터로 접근할 수 있고, 넌 클러스터 인덱스는 인덱스 페이지를 한 번 거쳐서 데이터에 접근하는 방식입니다.

### 5. 인덱스의 자료구조에 대해서 설명해주세요.
인덱스의 자료구조로는 기본적으로 Hash와 B+Tree가 있습니다.
Hash는 해시 테이블로써 키와 값으로 이루어져있고 키 값을 해싱하여 고유한 인덱스를 가지고, 해당 인덱스로 바로 접근할 수 있도록 설계되어있는 자료구조입니다. 하지만 잘 사용되지 않는 이유는 해시는 등호 연산(=)에 최적화 되어있어서 입니다. 보통 데이터베이스는 부등호 연산을 많이 사용하기 때문에 잘 사용되지 않습니다.

B+Tree는 트리 구조의 형태이며 데이터베이스 내 값들을 트리 형태로 두는 방식입니다. B-Tree의 경우 일반적을 모든 트리에 값을 매기지만 B+Tree는 Leaf Node에만 데이터 값을 매기며 Leaf Node끼리 연결리스트로 연결되어있어 값을 찾을 때 선형 시간이 걸리게 됩니다.