# 1. Java 기초
  ## 1.1 static
  - 클래스에서 공유되는 변수나 메서드를 정의할 때 사용하는 키워드
  - 정적 멤버는 인스턴스에 소속된 멤버가 아닌 클래스에 고정된 멤버로 클래스 로더가 클래스를 로딩해서 메서드 메모리 영역에 적재할 때 클래스별로 관리 됨
  
  ### 1.1.1 정적 멤버 생성
  - static 키워드를 통해 생성된 정적멤버들은 Heap영역이 아닌 메서드 영역의 static에 할당
  - static 영역에 할당된 메모리는 모든 객체가 공유하여 하나의 멤버를 어디서든지 참조 가능
  - Garbage Collector의 관리 영역 밖에 존재하기에 Static영역에 있는 멤버들은 프로그램의 종료시까지 메모리가 할당된 채로 존재 -> 성능에 악영향

  ### 1.1.2 static 변수(정적 필드) -> 클래스 멤버
  - 클래스 필드에 static을 선언
    ```java
    class Num {
      private static int number = 0;
    }
    ```
  - 값이 공유되어 Num 클래스를 여러 번 생성하더라도 number 변수는 하나의 static 변수로 존재함.

  ### 1.1.3 static 메서드(정적 메서드) -> 클래스 멤버
  - 메서드에 static을 선언
    ```java
    class Util {
      private static int number = 0;

      public static int plus(){
        number++;
      }
    }

    ```
  - static 메서드에서는 static 변수가 아닌 인스턴스 변수는 접근 불가능
    - static 메서드는 객체를 생성하지 않고도 사용이 가능하기 때문
  - static 메서드는 주로 유틸성으로 사용되는 메서드에 사용되며 특정 클래스나, 인스턴스에 종속되지 않고, 재사용이 가능하고 범용 가능한 기능을 제공할 때 사용
    - 코드의 중복성을 줄이고 가독성 향상

  ### 1.1.4 static vs 싱글톤
  #### 싱글톤
  - 단 하나의 객체만을 생성할 수 있는 패턴
    - 객체를 생성하려고 할 때마다 이미 생성된 것을 반환하거나 없다면 해당 시간에 처음 생성하도록 함
  - 정적 클래스와는 달리 싱클톤 클래스는 확장과 인터페이스 구현이 가능
  - 언제 생성하는지에 대한 시점을 조정 가능
  - 객체이기 때문에 힙에 싱글톤 객체가 저장 -> 쓰레드간 공유가 가능
  - 싱글톤은 구현으로 단 하나만 생성되게 보장한 것이지만 그 자체로는 클래스 객체이기 때문에 직렬화가 가능

  #### static
  - static 메소드를 가지는 클래스를 말함
  - 어플리케이션이 메모리에 로드 될 때 정적 스택에 바로 초기화 됨
  - 표준 클래스라고 보기는 어렵고 함수와 변수가 있는 네임스페이스
  - 정적 스택에 저장이 되기 때문에 쓰레드 관리가 어려움

  #### 차이
  - 싱글톤은 분리 가능한 의존성으로 연결되어 있지만 정적 클래스는 하드코딩의 결정체
  - 싱글톤을 이용하면 내부에 선언된 정적 객체를 교체해서 변경 가능
  - 정적 메서드로 구현된 클래스는 분리할 수 없는 하드코딩된 의존성

  ## 1.2 final
  - final 는 한 번만 할당할 수 있는 엔터티를 정의하기 위해 여러 컨텍스트에서 사용하는 것으로 어디에 사용하느냐에 따라 그 의미가 달라짐
  
  ### 1.2.1 final 변수
  - 값을 변경할 수 없는 상수가 됨
  - 선언과 동시에 초기화 필요
    - 인스턴스 변수의 경우 생성자에서 초기화 가능

  #### 1.2.1.1 final 변수 객체
  - final 키워드는 값을 바꿀 수 없지만, 객체일 경우 약간 다름
  - final로 선언된 ArrayList가 있다면 이 안에 있는 값은 add로 계속 추가할 수 있으며 ArrayList에 대한 주소 값만 변경하지 못함
  - 재할당은 불가능하나 추가, 삭제는 가능함.
  - 어떠한 클래스 안 Collection 필드에 final을 붙여 일급 컬렉션을 만들 수 있음.

  ### 1.2.2 final 메서드
  - 오버라이딩을 통해 재정의 될 수 없음
  
  ### 1.2.3 final 클래스
  - 상속 클래스, 자신의 자손 클래스를 정의하지 못함

  ### 1.2.4 static final
  - final의 경우 생성자에서 초기화 하는 경우 객체마다 다른 값을 가질 수 있어 온전한 상수를 의미하기 어려움
  - static을 붙여 하나의 공유 변수로 만들고 final을 설정하여 수정이 불가능하게 만들어 온전한 상수로 만들 수 있음

  ## 1.3 generic
  - 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미
  - ArrayList 처럼 <> 안에 들어가는 타입에 따라 ArrayList 구현체의 필드 값이 정해짐

  ### 1.3.1 타입 파라미터 정의
  ```java
    class FruitBox<T> {
      List<T> fruits = new ArrayList<>();

      public void add(T fruit) {
        fruits.add(fruit);
      }
    } 
  ```
  
  - 클래스 명에 붙은 <> 타입이 안에 있는 필드와 메서드에까지 영향을 미치는 것을 제네릭 타입 전파라고 부르며 타입이 구체적으로 설정되는 것을 구체화 된다고 표현

  ### 1.3.2 타입 파라미터 생략
  ```java
  FruitBox<Apple> intBox = new FruitBox<>();
  ```
  - 앞에 선언시 지정해줬기 때문에 생략해도 됨

  ### 1.3.3 타입 파라미터 할당 가능 타입
  - Primitive 타입외 나머지 모두(Reference타입)

  ### 1.3.4 복수 파라미터 타입
  - 제네릭을 여러개 사용 할 수 있음 <Integer, String>

  ### 1.3.5 타입 파라미터 기호 네이밍
  - T : 타입
  - E : 요소
  - K : 키
  - V : 리턴 값, 매핑 값
  - N : 숫자
  - S, U, V : 2, 3, 4번째에 선언된 타입

  ### 1.3.6 제네릭 사용 이유
  - 컴파일 타임에 타입 검사를 통해 예외 방지
    - 여러 타입을 다루기 위해 Object로 선언해서 사용하곤 했는데 선언된 Object에서 값을 가져올 때 런타임 환경에서만 확인할 수 있었음
  - 불필요한 캐스팅을 없애 성능 향상
    - Object를 사용하게되면 캐스팅을 해서 맞춰줘야하지만 필요가 없어짐
  
  ### 1.3.7 제네릭 종류
  - 제네릭 클래스
    - 클래스 선언문 옆에 타입 매개변수가 쓰이는 경우
  - 제네릭 인터페이스
    - 인터페이스 선언문 옆에 타입 매개변수가 쓰이는 경우
  - 제네릭 함수형 인터페이스
    - 람다 표현식의 함수형 인터페이스
  - 제네릭 메서드
    - 메서드의 선언부에 T가 선언된 메서드를 의미
    - 제네릭 메서드는 직접 메서드에 T를 설정함으로써 동적으로 타입을 받아와 사용할 수 있는 독립적으로 운용 가능한 메서드
    - static으로 사용

  ### 1.3.8 제네릭 타입 한정
  - 한정하지 않으면 모든 타입이 다 되어 너무 자유로움
  - extends로 하위 타입들만 받을 수 있도록 설정
    - Number -> Integer, Double
  - interface로 구현체 들만 받을 수 있도록 설정

  ## 1.4 stream, lambda
  ### 1.4.1 stream
  - 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소로 정의할 수 있음
  - Java8에 추가된 기능
  - 선언형으로 컬렉션 데이터를 간결하고 가독성이 좋도록 처리 가능

  #### 1.4.1.1 stream 특징
  - 파이프라이닝
    - 스트림 연산끼리 연결하여 커다란 파이프 라인을 구성할 수 있음
    - 대부분의 스트림 연산은 스트림 자신을 반환하기 때문에 파이프라이닝이 가능
  - 내부 반복
    - 명시적으로 반복자를 통해 반복하지 않고, 스트림 내부에서 일어나는 반복을 의미(for문을 안써도 됨)
  
  #### 1.4.1.2 스트림의 연산
  - 중간 연산
    - 스트림을 연결할 수 있는 연산
    - filter, sorted처럼 다른 스트림을 반환
  - 최종 연산
    - 스트림을 닫는 연산
    - void, array, list 등 스트림 이외의 값을 반환

  #### 1.4.1.3 스트림의 단계
  1. 소스 지정
  2. 중간 연산을 연결하여 파이프라인 구성
  3. 파이프라인을 실행하여 최종 연산으로 결과 값 반환

  ### 1.4.2 lambda
  - 함수를 하나의 식으로 표현한 것
  - 익명 함수를 지칭
    - 말 그대로 이름이 없는 함수를 의미하며, 일급 객체라는 특징을 가지고 있음
      - 일급객체: 다른 객체들에 적용 가능한 연산을 모두 지원하는 개체를 의미
        - 함수를 값으로 사용할 수 있음
  - 등장이유
    - 불필요한 코드를 줄이고, 가독성을 높이기 위함
  
  #### 1.4.2.1 람다의 장점
  - 코드를 간결하게 만들 수 있음
  - 식에 개발자의 의도가 명확히 드러나 가독성을 높임
  - 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아짐
  - 병렬 프로그래밍 용이

  #### 1.4.2.2 람다의 단점
  - 만든 함수는 재사용이 불가능
  - 디버깅이 어려움

  #### 1.4.3 함수형 인터페이스
  - 함수를 1급 객체처럼 이용할 수 있도록 해주는 어노테이션 


  - Supplier T
    - 매개 변수 없이 반환 값만을 갖는 함수형 인터페이스
  - Consumer T
    - 객체 T를 받아 사용하며 반환 값이 없는 함수형 인터페이스
  - Function T, R
    - 객체 T를 받아 처리한 후 R로 반환하는 함수형 인터페이스
  - Predicate T
    - 객체 T를 받아 처리한 후 Boolean 반환 


# 2. Java 컬렉션
  ## 2.1 hashcode() & equals()
  ### 2.1.1 hashcode()
  - 각 객체의 주소 값을 이용하여 해싱 기법을 통해 해시 코드를 만든 후 반환
  - 서로 다른 두 객체는 같은 해시 코드를 가질 수 없음
  - 주소 값으로 만든 고유한 숫자 값

  #### 2.1.1.1 객체의 hashcode()
  - 객체가 생성될 때 마다 새로운 주소를 띄기 때문에 new로 생성하게되면 각자 다른 hashcode가 부여 됨
  - 하지만 기존 객체를 새로운 객체에 대입하는 경우 동일한 인스턴스를 바라보고 있기 때문에 hashcode가 같음

  #### 2.1.1.2 String의 hashcode()
  - String의 Hashcode는 재정의 되어있는데 주소 값을 기준으로 생성하는 것이 아닌 문자열이 같으면 동일한 hashcode가 되도록 설정되어있음

  ### 2.1.2 equals()
  - 어떠한 두 참조 변수의 값이 같은지 다른지 동등 여부를 비교해야할 때
  - 비교할 대상이 객체일 경우 객체의 주소를 이용하여 비교
  - 예를 들어, Person이라는 객체가 있는데 이 객체를 두개 생성할 경우 서로 다른 주소를 갖고 있기 때문에 객체 주소 비교시 false가 나옴
    - 만일 주소 값이 아닌 객체의 필드 값을 기준으로 동등 비교 기준을 변경하고 싶다면, 메서드를 오버라이딩해서 비교하도록 재정의가 필요
  - String 클래스의 equals 오버라이딩
    - 직접 문자열 값을 문자 배열로 만들어 각 배열 요소 문자값을 하나하나 비교함
  - 자바의 규칙
    - equals()의 결과가 true인 두 객체의 해시코드는 반드시 같아야 함.

  ### 2.1.3 equals와 hashcode를 같이 재정의해야하는 이유
  - Collection을 사용할 때 문제가 발생하기 때문
    ```java
    public static void main(String[] args) {
      Set<Car> cars = new HashSet<>();
      cars.add(new Car("foo"));
      cars.add(new Car("foo"));

      System.out.println(cars.size()); // 기대 값: 2 실제 결과 값: 1
    }
    ```
  - 결과 값 1로 필드의 값이 같으면 true로 반환하는 equals를 오버라이딩 했는데 2가 아닌 1이 나옴
    - 논리적으로 두 Car는 같다고 정의했지만 해시코드가 다르기 때문에 2로 나옴
  - Collection(HashMap,HashSet,HashTable)에서의 hashcode와 equals 동작순서
    - 컬렉션에서 hashcode() 리턴 값으로 값을 가지고 있는지 확인하고 없으면 다르다고 판단되어 저장 진행
    - 만약 같으면 equals()를 비교하여 없으면 다른 객체라고 판단, 있으면 동등 객체라고 판단
  - identityHashCode()
    - HashCode()를 오버라이딩 하면 기존 주소를 모르게되는데 그때 사용하는 것