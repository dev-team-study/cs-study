 # 1. JAVA 컬렉션
  ## 1.1 Thread Safe & Syncronized
  ### 1.1.1 Thread Safe
  - 멀티 쓰레드 프로그래밍에서 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것을 의미
    - 이를 위한 방법으로 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 "임계영역"과 "잠금"의 개념이 도입
  - 임계영역
    - 공유 데이터를 사용하는 코드 영역
  - 잠금
    - 공유 데이터를 사용하는 코드 영역을 잠금하여 Lock을 획득
  - 쓰레드의 동기화
    1. 임계 영역을 설정 후 Lock을 획득하여 하나의 쓰레드만 영역 내의 코드를 수행할 수 있게 함.
    2. 해당 쓰레드가 임계 영역을 벗어난 후 Lock을 반납하게되면 다른 쓰레드가 Lock을 획득하여 수행 함

  ### 1.1.2 동기화 방법
  #### 1.1.2.1 Synchronized
  - 메서드 전체를 임계 영역으로 지정
    ```java
        public synchronized void sum(){
            //...
        }
    ```
    - 메서드가 호출된 시점부터 Lock 획득 -> 종료 후 Lock 해제
  - 특정한 영역을 임계 영역으로 지정
    ```java
    synchronized(객체의 참조 변수){

    }
    ```
  - 메서드 전체에 걸 경우 멅티쓰레드 환경에서 성능상의 영향이 있기 때문에 가급적이면 필요한 부분에만 적용

#### 1.1.2.2 Volatile
- synchronized 키워드를 남용할 경우 lock이 걸리는 쓰레드가 많아지고, synchronized 메서드 혹은 로직에 대한 병목 현상이 많이 발생하여 성능 상의 이슈가 발생 가능
- volatile은 원자성은 보장할 수 없지만 가시성을 보장하는 방법
  - 원자성
    - 소스코드가 한 번에 실행된다는 것을 보장하는 것
    - 명령이 수행되는 동안 다른 쓰레드에서 접근이 불가능하게 만들어 동시 접근 문제를 보장
  - 가시성
    - 한 쓰레드에서 공유 자원을 변경한 결과가 다른 쓰레드에서 확인할 수 있는 것을 의미
- volatile 키워드를 사용하면 변수의 값을 읽어올 때 캐시가 아닌 메모리에서 읽어오게 됨
  - 캐시와 메모리 간의 불일치 해결, 같은 공유자원에 대해 같은 값을 가지게 되어 가시성을 보장
- 동시 접근 문제는 해결 불가
- 하나의 쓰레드만 Read & Write하고 나머지 쓰레드는 Read만 할 때 사용

#### 1.1.2.3 Atomic
- 원자성을 보장하는 변수라는 의미
- synchronized 키워드의 성능 저하 문제를 해결하기위해 고안된 방법

  ## 1.2 String
  ### 1.2.1 String vs StringBuffer vs StringBuilder 
  #### 1.2.1.1 String
  - String은 불변
  - 할당된 공간이 변하지 않는 '불변' 자료형임
  - String 객체의 내부 구성 요소에는 value 값이 상수(final)로 되어있음
  - 자바에서 String을 불변으로 설정한 이유
    1. 캐싱: String을 불변하게 함으로써 String pool에 각 리터러 문자열의 하나만 저장하며 다시 사용하거나 캐싱에 이용가능하며 이로 인해 힙 공간을 절약할 수 있다는 장점이 있음.
    2. 보안: 예를 들어 데이터베이스 사용자 이름, 암호는 데이터베이스 연결을 수신하기 위해 문자열로 전달되는데 만일 문자열 값이 변경이 가능하다면 참조 값을 변경하여 보안 문제를 일으킬 수 있음.
    3. 동기화: 불변함으로써 동시에 실행되는 여러 스레드에서 안정적이게 공유가 가능
  #### 1.2.1.2 StringBuffer 와 StringBuilder
  - String과 같이 문자열 데이터를 다루지만, 객체의 공간이 부족해지는 경우 버퍼의 크기를 유연하게 늘려주어 가변
  - 두 클래스는 내부 Buffer에 문자열을 저장해두고 그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어있음
  - String 객체는 한번 생성되면 불변적인 특성 때문에 값을 업데이트할 경우, 매 연산시마다 새로운 인스턴스를 생성하지만 StringBuffer/StringBuilder는 가변성을 가지기 때문에 메서드를 이용하여 동일 객체내에서 크기 변경이 가능
  - String은 equals로 값 비교가 가능하지만 StringBuffer와 StringBuilder는 equals를 오버라이딩하지 않아 비교 불가능 -> toString()으로 String 객체로 변환한 뒤 equals로 비교해야 됨.
  - String의 + 연산시 StringBuilder를 통해 연산된다고 함.

  #### 1.2.1.3 StringBuffer vs String Builder
  - 멀티쓰레드에서 안전하냐 안전하지 않느냐 차이
  - StringBuffer는 쓰레드에서 안전
  - StringBuilder는 쓰레드에서 안전하지 않음.
  - StringBuffer는 동기화를 지원(메서드에서 Synchronized 키워드를 사용)

  ### 1.2.2 Immutable Object
  - 객체 생성 이후 내부 상태가 변하지 않는, 변경할 수 없는 객체를 의미
  - String, Integer, Wrapper 클래스
  - 불변 객체는 내부 상태를 변경하는 메서드를 제공하지 않거나 방어적 복사를 통해 데이터를 제공

  ### 1.2.2.1 불변 객체의 장점
  1. Thread-safe하여 동기화를 고려하지 않아도 됨
   - 값이 덮어씌워지는 문제가 없음.
   - 항상 동일한 값 보장
  2. 내부 상태의 변경이 없기 때문에 Cache, Map, Set 등의 요소로 활용하기에 적합
   - 요소가 변경되지 않기 때문에 갱신 작업이 필요 없음
  3. 외부에서 객체에 대해 변경할 수 없기에 안정성이 높음
   - 신뢰성이 높음
  4. 가비지 컬렉션의 성능을 높일 수 있음.
   - Oracle 
     - 객체 생성에 대한 비용은 과대 평가 되고 있음 -> 불변 객체를 이용한 효율로 충분히 상쇄 가능
     - 불변 객체를 새로 생성한다 해서 GC에서 생명주기가 짧은 객체를 처리하는 것은 부담되지 않는 일
     - 불변 객체를 이용하면 불변객체 내부의 객체에 대해서는 GC 스캔 대상에 제외

  ### 1.2.3 `String a = ""` vs `String a = new String("")`
  - `String a = ""`로 생성할 경우 메서드 영역안에 상수풀에 하나만 생성되지만 new로 만드는 경우 힙 영역에 계속 생겨 성능상 좋지 않음.

  ## 1.3 List
  ### 1.3.1 ArrayList vs LinkedList
  #### ArrayList 문제점
  - ArrayList는 배열 공간이 꽉 차거나 요소 중간에 삽입을 행하려 할 때 기존의 배열을 복사해서 요소를 한칸 씩 뒤로 일일히 이동해야 하는 불편함이 있음.
  - 삽입/삭제가 빈번하게 발생하는 프로세스의 경우 치명적
  - 시간복잡도 O(N)
  #### LinkedList의 장단점
  - 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성, 공간의 제약이 존재하지 않으며, 삽입, 삭제도 포인터만 바꿔주면 되기 때문에 빠름
  - 삽입/삭제가 빈번하게 발생하는 경우 LinkedList를 이용하면 좋음
  - 요소를 get해올 때 ArrayList는 특정 요소에 바로 접근 가능하지만, LinkedList는 처음부터 순차적으로 접근해야하는 성능 차이를 보임
  - next, prev 같은 참조자도 추가 메모리 할당이 필요함
  - 시간 복잡도 O(N)

  #### LinkedList는?
  - 의외로 잘 사용되지 않으며 성능상 큰 차이가 없음
  - 내부적으로 ArrayList가 튜닝이 잘되어있음.


  ## 1.4 Map
  ### 1.4.1 HashTable vs HashMap vs LinkedHashMap vs TreeMap
  - Map 인터페이스의 구현체
  - HashMap: HashTable을 구현한 것으로 정렬되지 않은 키와 값을 가지고 있음
  - TreeMap: Red-Black-Tree 구조를 구현한 것으로 정렬된 키를 가지고 있음
  - LinkedHashMap: 값의 입력된 순서를 유지
  - HashTable: HashMap과는 달리 동기적. 동기화를 위한 오버헤드가 발생

  ### 1.4.2 HashMap vs ConcurrentHashMap
  #### 1.4.2.1 HashMap
  - Key와 Value에 Null을 허용하지만, 동기화를 보장하지 않음.
  - 동기화 처리를 하지 않기 때문에 데이터 탐색 속도는 빠르지만, 신뢰성과 안정성이 떨어짐

  #### 1.4.2.2 ConcurrentHashMap
  - Key와 Value에 Null을 허용하지 않으며 동기화를 보장
  - 동기화 처리 시, 조작하는 버킷에 대해서만 락을 걸기 때문에, 같은 멀티 쓰레드 환경에서 사용하더라도 HashTable 대비 속도가 빠름.