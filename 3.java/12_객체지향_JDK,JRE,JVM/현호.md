# 객체지향
## 4가지 특징
캡상추다  
- 캡슐화 : 각 클래스가 서로의 내부 구현을 모르도록 은닉할 수 있는 특성이다. 이를 통해 클래스들이 다른 클래스의 내부 구현 의존하는 상황을 방지할 수 있다. 
- 상속 : 재사용과 확장을 의미. 상위 클래스의 특성을 하위 클래스에서 상속한다. 하위 클래스는 필요한 속성을 추가, 확장해서 사용한다. 상위 클래스 쪽으로 갈수록 추상화, 일반화됐다고 하며, 하위 클래스 쪽으로 갈수록 구체화되었다고 말한다.
- 객체 지향의 상속은 부모 - 자식 같은 계층도보다는 동물 - 포유류 같은 분류도라고 이해해야 한다. 
- 추상화 : 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 있는 특성만 가지고 재조합하는 것이다. 모델링을 위해 존재하는 특성. 
- 다형성 : 같은 상위 클래스를 공유하는 하위 클래스들이 같은 행동을 할 수 있도록 하는 특성이다. 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 프로그램을 작성시 사용 편의성을 제공한다. 
## 5원칙 (SOLID)
- SRP(Single Responsibility Principle): 단일 책임 원칙 : 하나의 클래스가 하나의 역할과 책임만을 가져야한다. 즉, 어떤 클래스를 변경해야하는 이유는 오직 하나뿐이어야 한다.
- OCP(Open Closed Principle): 개방 폐쇄 원칙 : 클래스는 자신의 확장에 대해서는 열려 있어야하지만, 주변의 변경에 있어서는 닫혀 있어야 한다. 예를들어, 자바에서는 인터페이스를 통해 클라이언트 코드와 구현체 사이의 의존성을 끊어줄 수 있다. 이 상황에서 구현체가 바뀌더라도 클라이언트 코드의 변화는 거의 없게 되므로 변화에는 닫혀있고, 확장에는 열려있는 구조가 된다. 
- LSP(Liskov Substitution Principle): 리스코프 치환 원칙 : 서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다. 
- ISP(Interface Segregation Principle): 인터페이스 분리 원칙 : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
- DIP(Dependency Inversion Principle): 의존 역전 원칙 : 추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다. 좀 더 실용적으로 말하자면 자주 변경되는 구체 클래스에 의존하는 것은 좋지 않다.

## 객체지향 vs 절차지향 vs 함수형 프로그래밍
- 객체지향 : 이는 실세계를 모델링하여 소프트웨어를 개발하는 방법론이다. '객체'라는 개념을 중심으로 프로그래밍이 이루어지며, 객체는 속성(데이터)과 메소드(함수)로 구성된다. 추상화, 캡슐화, 상속, 다형성이 주요 특징이다. 자바, 파이썬, C++ 등이 객체지향 언어이다.
- 절차지향 : 프로그램을 일련의 절차 또는 순서에 따라 작성하는 방법론이다. 대부분의 코드가 함수의 형태로 작성되며, 데이터는 전역 변수를 통해 주로 처리된다. 이 패러다임의 주요 목표는 문제를 해결하기 위한 명확한 절차를 정의하는 것이다. C 언어가 대표적인 절차지향 언어이다.
- 함수형 프로그래밍 : 이는 순수 함수를 기반으로 프로그래밍을 진행하는 패러다임이다. 함수의 입력만이 출력에 영향을 주며, 함수 외부의 어떤 상태도 변경하지 않는 '부작용 없음'이 핵심 원칙이다. 코드의 간결함과 예측 가능성을 높이는데 유리하며, 병렬 처리에 장점이 있다. 하스켈, 스칼라, 클로저 등이 함수형 언어이다.

# JDK, JRE, JVM
간단히 정리하자면, Java로 프로그램을 직접 개발하려면 JDK가 필요하고, 컴파일 된 Java 프로그램을 실행시키려면 JRE가 필요하다.

- JDK : JDK는 자바 개발키트(Java Development Kit)의 약자로 개발자들이 자바로 개발하는 데 사용되는 개발 키트라 생각하면 된다.
  그래서 JDK안에는 자바를 개발 시 필요한 라이브러리들과 javac, javadoc 등의 개발 도구들을 포함되어 있고, 개발을 하려면 자바 프로그램을 실행도 시켜줘야 하기 때문에 JRE(Java Runtime Environment)도 함께 포함되어 있다.
  
- JRE : 자바 실행환경의 약자로서, 자바 프로그램을 실행시킬 때 필요한 라이브러리를 함께 묶어서 배포되는 패키지 이다. 이외에도 자바 런타임 환경에서 사용하는 프로퍼티 세팅이나 리소스 파일(jar 파일)을 가지고 있다.
  
- JVM : JVM은 자바 가상머신(Java Virtual Machine)의 약자로서, 직역하면 자바를 실행하는 머신이라는 건데, 그냥 자바를 돌리는 프로그램 정도로 이해하면 된다.
  자바로 작성된 모든 프로그램은 JVM(자바 가상 머신)에서만 실행될 수 있으므로, 자바 프로그램을 실행하기 위해서는 반드시 자바 가상 머신이 설치되어 있어야 한다.
 
앞서 말했듯이 JVM은 자바 실행 환경 JRE(Java Runtime Environment)에 포함되어 있다. 그래서 현재 사용하는 컴퓨터의 운영체제에 맞는 자바 실행환경 (JRE)가 설치되어 있다면 자바 가상 머신이 설치되어 있다는 뜻이기도 하다.
## 컴파일 언어 vs 인터프리터 언어
- 컴파일 언어 : 코드 -> 환경 전용 컴파일러 -> 실행 파일 
- 인터프리터 언어(자바 컴파일 과정) : 코드 -> 바이트 코드 -> 환경 전용 JVM -> 실시간 실행 
## JVM 메모리 구조
JVM Runtime Data Area라는 공간에 저장 됨.
- Method영역 : JVM에서 읽어들인 클래스와 인터페이스에 대한 메서드와 필드, Static 변수, 메서드 바이트 코드, 런타임 Constant 풀 등을 보관 
- Heap 영역 : 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 메모리 영역. new 연산자를 통해 생성한 객체를 저장.
- Stack 영역 : 자료구조 stack과 같이 선입후출 구조. 메서드 호출 시 생성되는 지역 변수, 매개변수 등을 저장. 
- PC 레지스터 : 현재 실행 중인 JVM 주소를 가지고 있음. CPU 명령어를 수행. 명령어를 수행하는 동안 CPU내 기억장치인 레지스터에 필요한 정보를 저장. 
## Garbage Collector 동작과정
- JVM의 힙 영역이 GC의 대상이 된다.
- 특정 객체가 GC 대상인지 아닌지 판단하기 위해서 객체로 접근할 수 있는 참조가 있는지 없는지로 구분하여, 유효한 참조가 없는 객체는 수거한다.  JVM 메모리에서는 객체들은 실질적으로 Heap영역에서 생성되고 Method Area이나 Stack Area 에서는 Heap Area에 생성된 객체의 주소만 참조하는 형식으로 구성된다.
  하지만 이렇게 생성된 Heap Area의 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인하여 Heap Area 객체의 메모리 주소를 가지고 있는 참조 변수가 삭제되는 현상이 발생하면, 위의 그림에서의 빨간색 객체와 같이 Heap영역에서 어디서든 참조하고 있지 않은 객체(Unreachable)들이 발생하게 된다.
  이러한 객체들을 주기적으로 가비지 컬렉터가 제거해주는 것이다.
- 자바 8까지는 참조가 최초에 시작되는 지점부터 전체 메모리를 탐색하여 참조가 끊겨있는 객체들을 제거했다. 반면, 자바 11부터 정식으로 쓰이는 G1 GC의 경우 전체 힙 영역을 Region이라는 여러 영역으로 분할한다. 그런 뒤 메모리가 많이 차있는 리전을 인식하여 해당 영역만을 GC하는 방식을 통해 GC가 좀 더 작은 단위로 빠르게 일어나는 구조로 바뀌었다.   
## Java8의 큰 특징 + Java11과의 차이점
Java8의 특징
- 람다와 스트림API 제공
- LocalDateTime과 같은 새로운 날짜 API 제공

Java11의 특징
- G1 GC가 기본 GC로 설정
- var키워드 사용 가능
- 컬렉션, 스트림 등에 메서드 추가
# 질문
1. 객체지향 프로그래밍의 4가지 특징에 대해 설명해주세요. 특히 '다형성'에 대해 자세히 설명해주시고 이를 활용한 구체적인 예시도 들어주세요.
2. 객체지향 설계 원칙인 SOLID 중에서 '개방 폐쇄 원칙(OCP)'에 대해 설명해주시고, 이 원칙을 어떻게 적용할 수 있는지 예를 들어 설명해주세요.
3. 객체지향 프로그래밍, 절차지향 프로그래밍, 함수형 프로그래밍의 차이점에 대해 설명해주시고, 각각 어떤 상황에서 사용하면 좋을지 예를 들어주세요.
4. JDK, JRE, JVM의 차이점과 각각의 역할에 대해 설명해주시고, 그 중 JVM의 메모리 구조에 대해서도 설명해주세요.
5. Java8과 Java11의 주요한 차이점과 각 버전의 주요 특징에 대해 설명해주세요.