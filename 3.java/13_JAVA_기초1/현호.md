# 접근제어자
1. private : 다른 클래스가 접근할 수 없다.
2. default : 같은 패키지의 클래스들이 접근할 수 있다. (같은 패키지 내의 일반 클래스, 자식 클래스가 접근할 수 있음)
3. protected : **같은 패키지의 클래스들 + 다른 패키지의 자식 클래스가 접근할 수 있다.** 
4. public : 모든 클래스가 접근할 수 있다.

# 클래스, 객체, 인스턴스 차이
1. 클래스 : 클래스란 객체를 생성하기 위한 일종의 설계도입니다.
2. 객체 : 클래스가 설계도라면 객체는 설계도를 통해 구현된 실체입니다.
3. 인스턴스 : 객체가 어떤 클래스의 객체인지 관계를 강조하여 파악할 때 쓰이는 표현입니다. 예를 들어, 이 객체는 어떤 클래스의 인스턴스다라는 식으로 표현합니다.   

# Overloading vs Overriding
1. 오버로딩 : 같은 메서드명을 공유하지만 매개변수의 타입이나 갯 수가 다른 여러 메서드를 정의해서 사용하는 방법입니다.
2. 오버라이딩 : 부모 클래스나 구현하고 있는 인터페이스에 존재하는 메서드를 자식 클래스가 다시 한 번 재정의하여 사용하는 것을 의미합니다.    

# Primitive type vs Reference type
1. Primitive type : 변수를 위해 할당 된 저장 공간에 실제 데이터가 저장되어 있는 자료형들을 의미합니다.  
2. Reference type : 반면, Reference type은 변수를 위한 저장 공간에 다른 변수로 이동할 수 있는 참조값이 저장되어 있는 자료형입니다.

# Call by Reference vs Call by Value 
1. Call by Value : 함수를 호출하면서 매개변수로 primitive type을 전달하는 경우를 Call by Value라고 합니다. Call by Value가 일어났을 경우 변수의 주소가 아니라 값 자체가 복사된 것이기 때문에 함수 내부에서 매개 변수에 어떠한 변경을 해도 변수의 값이 변하지 않는다는 특징이 있습니다.     
2. Call by Reference : 함수를 호출하면서 매개변수로 Reference type을 전달하는 경우를 의미합니다. Reference type이 가지고 있던 주소 자체가 복사되기 때문에, 메서드 내부에서 주소를 통해 참조해서 값을 바꿀 수 있다는 특징이 있습니다.     

# Wrapper Class
Wrapper Class : Primitive type을 객체로 표현하기 위해서 사용하는 클래스. Wrapper Class로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없다.   

# interface vs abstract class
인터페이스와 추상 클래스 모두 그 자체로는 객체를 생성할 수 없고 다른 클래스가 상속을 통하여 구현해야 한다는 공통점이 있습니다. 차이점으로는 인터페이스의 경우 필드를 가질 수 없고, 별도로 defalut 키워드를 사용하지 않는 한 메서드가 구현을 가질 수 없습니다. 반면에 추상클래스는 필드를 가질 수 있고, 메서드가 구현을 가질 수 있다는 차이점이 있습니다.   

# Checked Exception vs UnChecked Exception
Checked Exception은 Exception클래스의 하위 클래스로서 예외가 발생될 경우 throws문을 통해 명시적으로 예외를 던져주거나, try-catch 등으로 예외를 처리하는 것이 강제되는 예외 클래스들 입니다. 반면에, UnChecked Exception은 RuntimeException클래스의 하위 클래스들로서 예외가 발생되어도 명시적으로 이를 처리해줄 필요가 없는 클래스들 입니다.

# Reflection
자바 리플렉션(Reflection - 사전적 의미 : 거울 등에 비친, 반사)은 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 프로그램 기법이다. 클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고, 객체를 생성하는 것 또한 가능하게 해주어 유연한 프로그래밍을 가능하게 해준다.  
리플렉션을 사용하면 클래스와 메서드의 메타정보를 사용해서 애플리케이션을 동적으로 유연하게 만들 수 있다. 하지만 리플렉션 기술은 런타임에 동작하기 때문에, 컴파일 시점에 오류를 잡을 수 없다는 단점이 존재한다.만일 리플렉션으로 getMethod("메서드명") 를 통해 클래스의 메서드를 가져온다고 가정했을 때 인자로 존재하지도 않는 메서드명을 기재할 경우, 해당 코드를 직접 실행해야 오류가 발생해 미리 대비할수 없게 된다.

# Dynamic Proxy
개발자가 직접 디자인 패턴으로서 프록시 패턴을 구현해도 되지만, 자바 JDK에서는 별도로 프록시 객체 구현 기능을 지원한다. 이를 동적 프록시(Dynamic Proxy) 기법이라고 불리운다.
동적 프록시는 개발자가 직접 일일히 프록시 객체를 생성하는 것이 아닌, 애플리케이션 실행 도중 동적 프록시 라이브러리를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법이다. 그래서 별도의 프록시 클래스 정의없이 런타임으로 프록시 객체를 동적으로 생성해 이용할 수 있다는 장점이 있다.  
자바에서는 JDK의 Dynamick Proxy와 CGLIB 라이브러리가 주로 사용된다. 스프링 프레임워크에서 Bean을 등록할 때 Spring AOP를 이용하여 등록을 하는데, Bean으로 등록하려는 기본적으로 객체가 Interface를 하나라도 구현하고 있으면 Dynamic Proxy를 이용하고 Interface를 구현하고 있지 않으면 CGLIB 라이브러리를 이용한다.