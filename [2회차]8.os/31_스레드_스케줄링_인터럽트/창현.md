# 1. 스레드
  ## 1.1 스레드 개념
   - 프로세스 내에서 실제로 작업을 수행하는 주체를 의미
   - 스레드는 프로세스의 힙 영역과 코드 영역을 공유하며, 스택 영역이 별도로 생성됨
     - 이를 통해 자원의 공유 효율성이 생겨 좀 더 빠르지만, 공유된 자원에 대한 통제를 해야 함
     - 프로세스는 공유하지 않기 때문에 IPC와 같은 별도의 통신 방식으로 프로세스끼리 통신해야 함
  
  ## 1.2 멀티스레드의 구조
   - 멀티스레드: 하나의 프로세스 내부에서 여러 개의 스레드가 동시에 실행되는 것을 의미

  ## 1.3 멀티스레드의 장단점
   ### 멀티스레드의 장점
   - 자원 공유가 쉬움(힙 영역 공유)
   - 멀티프로세스보다 컨텍스트 스위칭에 있어서 유리함(일부를 공유해서 스위칭시 옮겨야할 데이터 영역이 적음)
   
   ### 멀티스레드의 단점
   - 자원 공유로 인한 경쟁 상태에 돌입하여 갱신 손실과 같은 문제를 발생시킬 수 있음(안정성 저하)
   - 극복하기 위해 동기화를 시키면 성능이 저하 됨
   - 많은 쓰레드가 발생할 경우 컨텍스트 스위칭이 많이 발생하면서 오히려 성능을 저하시킬 수 있음

  ## 1.4 멀티 프로세스 VS 멀티 스레드
   - 멀티 프로세스는 자원을 공유하기 위해서 IPC와 같은 프로세스간 통신 기법을 사용해야 함, 하지만 멀티 스레드는 같은 프로세스 내의 메모리를 공유하기 때문에 훨씬 손 쉽게 자원 공유가 가능
   - 컨텍스트 스위칭 비용이 멀티 프로세스는 모든 메모리 영역을 왔다갔다 해야하지만, 스레드는 공유하는 영역을 제외한 나머지만 왔다갔다 하면 되기 때문에 훨씬 효율적임

# 2. CPU 스케줄링
  - 언제 어떤 프로세스에 CPU를 할당할 것인지 결정하는 작업
  - CPU 이용률은 높게, 주어진 시간 안에 많은 일을 하게, 준비 큐에 있는 프로세스는 적게, 응답시간은 짧게 설정하는 것을 목표로 함

  ## 2.1 장기 스케줄링
  - 작업 스케줄러라고도 부르며, 어떤 프로세스를 준비 큐에 삽입할지를 결정하는 역할을 함
  - 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이때 디스크에서 어떤 프로그램을 가져와 커널(준비 큐)에 등록할지 결정

  ## 2.2 중기 스케줄링
  - 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우, 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절

  ## 2.3 단기 스케줄링
  - CPU 스케줄러라고도 하며 준비 상태의 프로세스 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지를 결정
  
# 3. 스케줄링 알고리즘
  ## 비선점형 알고리즘
   - 어떤 프로세스가 CPU를 점유하고 있다면, 이를 뺏을 수 없는 방식. 강제로 프로세스를 중지하지 않아서 상대적으로 문맥교환으로 인한 부하가 적음. 프로세스의 배치에 따라 효율성 차이가 많이 남
   ## 3.1 FCFS(FirstComeFirstServed)
   - 가장 먼저 요청한 프로세스에 CPU를 할당해주는 선착순 방식
   - 호위 효과 발생 가능 => 몇 개의 시간이 오래 걸리는 프로세스로 인해 전체 OS가 느려지는 현상
   ## 3.2 SJF(Shortest Job First)
   - 실행시간이 가장 짧은 프로세스를 먼저 실행하는 알고리즘
   - 실제로는 CPU 실행 시간을 예측하기 어렵고, 긴 시간을 필요로 하는 프로세스가 우선순위에서 계속 밀려 무기한 대기하는 기아 현상 발생 가능
   ## 3.3 Priority scheduling
   - 각각의 프로세스에 우선순위 넘버가 있는 알고리즘
   - 낮은 우선 순위의 프로세스가 절대 실행되지 않는 기아 문제를 노화를 이용하여 오래된 작업의 우선순위를 높여줌

  ## 선점형 알고리즘 
   - 현대 운영체제가 사용하는 방식으로, 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 이를 강제로 뺏을 수 있는 방식
   - 알고리즘에 따라 강제로 중단시키고 다른 프로세스에 CPU를 할당하는 방식
   - 처리 시간이 매우 긴 프로세스의 CPU 사용 독점을 막을 수 있어서 효율적인 운영이 가능하지만 잦은 컨텍스트 스위칭으로 인해 오버헤드가 발생할 수 있음

   ## 3.4 Round Robin
   - 현대 컴퓨터가 사용하는 우선 순위 스케줄링. 각각의 프로세스에 동일한 할당 시간을 부여해서 해당 시간 동안만 CPU를 이용하게 함.
   - 할당 시간 내에 처리를 완료하지 못하면 강제 중단 후 다음 작업으로 넘어가므로 선점형 방식

   ## 3.5 SRT(Shortest Remaining Time)
   - 최단 잔여시간을 우선으로 하는 스케줄링
   - 진행 중인 프로세스가 있어도, 최단 잔여시간인 프로세스를 위해 sleep 시키고 짧은 프로세스를 먼저 할당
   ## 3.6 Multilevel Queue
   - 우선 순위에 따른 큐가 여러 개의 큐들로 나뉘고 각각의 큐는 각자의 스케줄링 알고리즘을 가지고 있음
   - 우선 순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리가 되지 않는 기아 현상이 나타날 수 있음
   - 각 큐 사이에서 프로세스들이 이동할 수 없어서 유연성이 떨어지는 특징이 있음

   ## 3.7 Multilevel Feedback Queue
   - 각 큐 사이를 동적으로 오갈 수 있는 방식
# 4. 인터럽트
  ## 4.1 인터럽트 개념
  - 프로세스 실행 도중 예기치 않은 상황이 발생할 때 발생한 상황을 처리한 후 실행 중인 작업으로 복귀하는 것을 의미함

  ## 4.2 동기적 인터럽트, 비동기적 인터럽트
  ### 동기적 인터럽트(소프트웨어 인터럽트)
  - 프로세스 내부에서 잘못된 명령어 또는 데이터로 Exception이 발생되는 것이며 trap이라고 불림
  - 시스템 콜로써 구현될 수 있음

  ### 비동기적 인터럽트(하드웨어 인터럽트)
  - 전원 이상, 기계 착오, 외부 신호, 입출력 등 프로세스 외부에서 발생하는 인터럽트
  - 시스템 버스를 통해 하드웨어적으로 전달

  ## 4.3 인터럽트 처리 과정
  ### 인터럽트 서비스 루틴
  1. 주 프로그램 작업 수행 중 인터럽트 발생
  2. 주 프로그램 상태 레지스터와 PC등을 스택에 잠시 저장
  3. 인터럽트 서비스 루틴으로 점프, 처리
  4. 다시 주 프로그램 작업 복귀 

  ## 4.4 인터럽트와 이중 모드
  ### 이중모드란?
  - 하나의 컴퓨터를 여러 유저가 동시에 사용하는 환경이 많음. 하나의 컴퓨터 즉, 서버에 여러 유저가 접속하여 사용하게 되면 특정 한 사람이 서버를 독점하거나 하나의 실수로 인해 모든 유저가 피해를 보는 상황이 발생할 수 있음
  - 운영체제를 보호하기 위한 기법 중 하나로, 커널 모드와 사용자 모드를 구분하여 일반 사용자가 무분별하게 시스템 자원으로 접근할 수 없도록 함
  #### 커널 모드
  - 운영체제를 위한 동작을 담당

  #### 사용자 모드
  - 사용자가 접근할 수 있는 영역을 제한적으로 두고 프로그램의 자원에 함부로 접근하지 못하도록 하는 모드
  - 하드웨어 직접 접근 불가능
  - 유저 애플리케이션이 실행되는 코드라고 보면 됨

# 5. 프로세스 동기화
  ## 5.1 공유자원, 경쟁상태, 임계구역
  ### 공유자원
  - 시스템 안에서 각 프로세스, 스레드가 함께 접근할 수 있는 메모리, 파일, 데이터 등의 자원이나 변수를 의미

  ### 경쟁상태
  - 공유자원을 두 개 이상의 프로세스나 스레드가 동시에 읽거나 쓰는 상황을 말함

  ### 임계구역
  - 공유자원에 접근할 때 순서 등의 이유로 결과가 달라지는 영역을 뜻함

  ## 5.2 피터슨 알고리즘
  - 임계구역 문제를 소프트웨어적으로 해결하기 위한 알고리즘이며, 공유 메모리를 활용하여 여러 개의 프로세스가 하나의 자원을 사용할 때 문제가 발생하지 않도록 함
  - 아래는 임계 영역에 대한 문제를 해결하기 위한 세 요구사항
  - turn & flag를 이용한 방법

  ### 상호 배제
  - 한 프로세스가 임계 영역에서 실행되고 있다면 다른 프로세스들은 임계 영역에 진입할 수 없음
  ### 진행
  - 임계 영역이 비어있을 때, 진입하고자 하는 프로세스가 존재한다면 반드시 진입이 이루어져야 함
  ### 한정 대기
  - 프로세스가 임계 영역에 진입하기 위한 대기 시간은 한정되어야 함
  - 어떠한 프로세스도 무한 대기를 하면 안됨

  ```java
  boolean[] flag = new boolean[2];
  int turn;

  public void P0() {
    while(true){
      flag[0] = true;
      turn = 1;

      while(flag[1] && turn == 1);

      // 임계 영역

      flag[0] = false;
    }
  }

  public void P1() {
    while(true){
      flag[1] = true;
      turn = 0;

      while(flag[0] && turn == 0);

      // 임계 영역

      flag[1] = false;
    }
  }
  ```  
  ## 5.3 뮤텍스
  - 멀티 스레드 환경에서 자원에 대한 접근 제한을 위한 동기화 메커니즘
  - Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역에 들어갈 수 있음
  - lock, unlock 2가지만 있음

  ## 5.4 세마포어
  - 여러 개의 프로세스 또는 스레드가 임계 구역에 접근할 수 있도록 하는 것
  - 카운트를 가지고 있어 임계 구역에 몇개가 들어갈 수 있는지 카운팅 하는 것으로 1이면 뮤텍스로 볼 수 있음
  
  ## 5.5 모니터
  - 상호 배제를 보장
  - 조건에 따라 스레드가 대기 상태로 전환하게끔 함

  ### 구성요소
  - 뮤텍스
    - 락을 획득하고, 해제하는 기법
  - condition variable
    - waiting Queue를 가짐
  ### 주요 동작
  - wait
    - thread가 자기 자신을 condition variable의 waiting Queue에 넣고 대기로 전환
  - signal
    - waiting queue에서 대기중인 스레드 하나를 깨움
  - broadcast
    - waiting queue에서 대기중인 스레드 전부를 깨움
  ### 두 개의 큐
  - entry queue: critical section에 진입을 기다리는 큐(뮤텍스 관리 큐)
  - waiting queue: 조건이 충족되길 기다리는 큐(condition variable)
  ### 사용 사례
  - buffer
    - bounded producer 처리가 된 것을 buffer에 담았을 때, 매번 buffer의 용량을 확인해서 집어 넣어야함
    - consumer problem 버퍼에서 꺼내서 쓸때 buffer에 데이터가 있는지 없는지 매번 체크해야 함
 ### 자바에서의 모니터
 - 프로그래밍 언어 레벨에서 지원 하여 보통 건드릴일이 없음
 - 모든 객체는 모두 모니터를 가지고 있음
 - 모니터 세가지 동작
   - wait
   - notify(signal)
   - notifyAll(broadcast)

# 6. 교착 상태(Deadlock)
  ## 6.1 교착 상태 정의
  - 두 개 이상의 프로세스 또는 스레드가 자원을 점유한 상태에서 서로가 점유한 자원을 서로에게 요구하고 있어서 그 프로세스 또는 스레드들이 무한정으로 기다리고 있는 상태를 의미 함
  - 예를 들어 process1, process2가 있을 때 데이터베이스 테이블에 1번 레코드를 조회했더니 해당 레코드의 FK 부모 레코드에 공유락이 걸림
  - process1, process2번 둘다 공유락을 걸고 1번 레코드를 수정하려했는데 공유락이 걸려있어서 풀 수가 없음

  ## 6.2 교착 상태 조건
  - 상호 배제
    - 한 리소스는 한 번에 한 프로세스만이 사용할 수 있음
    - 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함
  - 점유와 대기
    - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함
  - 비선점
    - 이미 할당된 자원을 강제로 빼았을 수 없음
    - 리소스가 자발적으로 반환할 때까지 기다려야 함 
  - 환형 대기
    - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 함

  ## 6.3 교착 상태 해결 방법
  - 예방
    - 요구 조건을 만족시키지 않게함으로써 교착 상태를 방지
    - 자원 낭비가 심함
  - 회피
    - 교착 상태가 발생하면 적절히 피해나가는 방법
    - 요청 순서를 지정하여 피해감
  - 탐지 및 회복
    - 교착상태가 발생 할 수 있도록 놔 두고 교착상태가 발생 할 경우 찾아내어 고침
    - 탐지
      - 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견
    - 회복
      - 교착상태를 발견했다면 회복기법을 진행
      - 프로세스를 종료하거나 할당된 자원을 선점하여 프로세스나 자원을 회복시킴

  ## 6.4 식사하는 철학자 문제
  ```markdown
1. 일정 시간 생각을 한다.
2. 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
3. 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
4. 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
5. 오른쪽 포크를 내려놓는다.
6. 왼쪽 포크를 내려놓는다.
7. 다시 1번으로 돌아간다.
  ```
  - 모든 철학자 5명이 왼쪽 포크를 동시에 들면, 오른쪽 포크를 들 수 없는 상태가 되어 무한정 대기로 인하여 데드락이 걸림

### 해결 방법
- 철학자를 5명으로 줄여, 1명은 꼭 먹게 함
- 포크를 한 번에 2개씩 들도록 함
- 철학자마다 드는 포크의 방향을 다르게 함

## 질문
### 1. 멀티쓰레드 환경이 무엇인지 설명해주시고, 멀티 프로세스와 비교해서 장단점을 얘기해주세요.
### 2. CPU 스케줄링인 장기, 중기, 단기 스케줄링에 대해서 설명해주세요.
### 3. 비선점형, 선점형 알고리즘이 무엇인지와 알고 있는 알고리즘에 대해서 전부다 설명해주세요.
### 4. 인터럽트에 대해서 설명해주시고, 어떻게 처리되는지 설명해주세요.
### 5. 이중모드가 무엇인지 설명해주시고, 커널모드와 사용자 모드에 대해서 설명해주세요.