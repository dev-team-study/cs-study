## Java 컬렉션

### List

#### ArrayList vs LinkedList

내부 데이터 구조 

- ArrayList : 내부적으로 동적 배열을 사용해 요소들을 저장
- LinkedList : 이중 연결 리스트를 사용해 요소들을 저장 

성능

- ArrayList : 인덱스를 통한 무작위 접근이 매우 빠르다. 
- LinkedList : 요소의 추가 및 삭제 작업이 빠르다. 

메모리 사용 

- ArrayList : 배열 기반으로 사용하지 않는 공간도 메모리를 차지 할 수 있지만, 요소의 참조를 저장하는데 필요한 메모리 이외에 추가적인 오버헤드가 없다. 
- LinkedList : 각 요소가 자신의 이전 및 다음 요소에 대한 참조도 가지고 있어, 같은 수의 요소를 저장하더라도 ArrayList보다 더 많은 메모리를 사용할 수 있다. 

### Map

#### HashTable vs HashMap vs LinkedHashMap vs TreeMap

HashTable 

- 동기화 : HashTable은 동기화되어 있어 멀티스레드 환경에서 안전하게 사용할 수 있다. 
- Null 허용 x : 키와 값 모두 null을 허용하지 않는다. 
- Iterator : HashTable의 반복자는 fail-fast 속성을 가지고 있지 않음
- 성능 : 동기화 때문에 상대적으로 느릴 수 있다. 

HashMap 

- 비동기화 : HashMap은 동기화 되지 않아, 멀티스레드 환경에서의 안전성을 보장하지 않음. 
  - Collections.synchronizeMap() 메서드를 사용해 동기화된 map을 만들 순 있다.
- Null 허용 : 키에는 Null을 하나만 사용할 수 있고, 값에는 null을 여러개 사용할 수 있다.
- 반복자 : HashMap의 반복자는 fail-fast 속성을 가진다.
  - 반복 중에 맵이 변경되면 ConcurrentModificationException을 발생시킨다.
- 순서 : 요소의 순서를 보장하지 않음. 
  - 삽입  순서나 정렬 순서와 관계없이 키의 해시에 따라 데이터가 저장됨

LinkedHashMap

- 순서 보장 : HashMap에 순서 보장 기능을 추가한 것으로, 삽입 순서대로 혹은 접근 순서대로 요소를 순회할 수 있다.
- 성능 : HashMap과 비교했을 때 약간의 성능 저하가 있을 수 있지만, 순서를 유지해야 하는 상황에서 유용하다.
- Null 허용 : HashMap과 같다.

TreeMap

- 정렬 순서 : TreeMap은 키를 기준으로 정렬된 순서로 요소를 저장한다. 
  - 자연 순서 혹은 생성자에 제공된 Comparator에 따라 정렬된다.
- 성능 : get(), put(), remove() => O(logN)
- Null 허용 : 키에는 Null을 허용하지 않으나, 값에는 null을 사용할 수 있다. 
  - 하지만 Comparator의 구현에 따라 키에 null을 허용 할 수 도 있다.

> fail - fast
>
> 오류를 가능한 빨리 감지하고, 발생 시 즉시 작업을 중단해 더 큰 시스템 장애로 이어지는 것을 방지한다. 
>
> Java 컬렉션 프레임워크에서 컬렉션을 순회하는 동안 해당 컬렉션이 수정될 경우 즉각적으로 ConcurrentModificationException을 던지는 반복자의 속성을 가르킨다. 
>
> fail-fast 반복자는 내부적으로 컬렉션의 수정 횟수를 추적한다. 
>
> 반복자가 생성된 후에 컬렉션에 어떤 변경사항이 발생하면 수정 횟수와 내부의 카운트가 불일치하게 된다. 
>
> 이럴 경우 ConcurrentModificationException을 발생시켜 동시 수정이 일어났음을 알린다.

#### HashMap vs ConcurrentHashMap

HashMap 

- 비동기화 : 멀티스레드 환경에서 여러 스레드가 동시에 HashMap을 수정하려고 할 때 안전하지 않음. 
- 성능 : 비동기화 되어 있어 단일 스레드 환경에서는 HashTable 보다 빠르다.
- Null 값 허용 : HashMap은 키와 값 모두에 대해 null 값을 허용한다.

ConcurrentHashMap

- 부분 동기화 : 전체 맵을 Lock하지 않고, 내부적으로 여러 세그먼트로 나누어 각 세그먼트 별로 동기화 해, 동시에 여러 스레드가 맵의 다른 부분을 수정할 수 있도록 한다.
- 성능 : 멀티스레드 환경에서 HashMap 보다 나은 성능을 제공한다. 
- Null 값 비허용 : 안정성을 위해 키, 값 모두에 대해 null을 허용하지 않음

HashTable 

- 동기화 : HashTable은 모든 메소드가 동기화 되어 있어 멀티스레드 환경에서 안전하다.
- 성능 : 모든 연산이 동기화 되기에 HashMap, ConcurrentHashMap 보다 성능이 떨어질 수 있다.
- Null 값 비허용 : 키, 값 모두에 대해 null을 허용하지 않음

## 운영체제

### 운영체제 소개

운영체제란 컴퓨터 시스템 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임.

운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해 줌. 

### 운영체제 필요성

- 자원 관리
  - 자원을 응용 프로그램에 나눠줘 사용자가 원활하게 작업할 수 있도록 돕는다.
  - 만약 자원을 요청한 프로그램이 여러개라면 적당한 순서로 자원을 배분하고 적절한 시점에 자원을 회수해 다른 응용프로그램에게 나눠줌
- 자원 보호 
  - 비정상적인 작업으로부터 컴퓨터 자원을 지킨다. 
- 하드웨어 인터페이스 제공
  - 다양한 하드웨어를 일관된 방법으로 사용할 수 있도록 지원해준다.
- 사용자 인터페이스 제공
  - 사용자가 운영체제를 편리하게 사용하도록 지원.
  - GUI, 터치 스크린 .. 이 이에 해당한다. 

### 운영체제 정의

응용 프로그램이나 사용자에게 컴퓨터 자원을 사용할 수 있는 인터페이스를 제공하고, 그 결과를 돌려주는 시스템

응용 프로그램이나 사용자에게 컴퓨터 자원을 숨기고 정해진 방법으로만 컴퓨터 자원을 사용 할 수 있도록 제한한다.

### 운영체제 역할

- 입출력 시스템 관리
- 리소스 관리
- 메모리 관리
- CPU 관리

### 운영체제 구조

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FS3U2H%2FbtqHxbOhB2V%2FWeQANBQKfm6F58xkWsJZy0%2Fimg.png)

### 커널

커널은 OS의 핵심 부분으로, 컴퓨터의 하드웨어와 소프트웨어 사이에서 중재 자 역할을 한다. 

기본적으로, 커널은 시스템의 모든 부분이 하드웨어 자원을 공정하고 효율적으로 사용할 수 있도록 관리하고 조정하는 책임을 지닌다. 

역할 및 기능 

- 프로세스 관리 
  - 프로세스의 생성, 실행, 중지 및 종료등 프로세스의 생명주기를 관리한다. 
  - 실행되는 프로그램들이 CPU 시간을 공정하게 사용할 수 있도록 스케쥴링 역할도 한다.
- 메모리 관리 
  - 시스템의 물리적 메모리(램)를 관리한다. 
  - 프로세스에 메모리를 할당하고, 필요하지 않게 된 메모리를 회수한다.
  - 가상 메모리 시스템을 통해 실제 메모리보다 더 많은 메모리를 사용할 수 있는 것처럼 관리할 수 있다. 
- 파일 시스템 관리
  - 파일 시스템을 통해 데이터를 저장하고 접근하는 방법을 제공한다. 
- 입출력 관리
  - 필요한 입력과 출력 서비스를 제공
- 프로세스 간 통신 관리
  - 공동 작업을 위한 각 프로세스 간 통신 환경을 지원 

커널의 유형으로는 대표적으로 다음이 존재한다.

- 모놀리식
- 마이크로 
- 하이브리드 

### 시스템 호출

System Call은 커널이 자신을 보호하기 위해 만든 인터페이스다. 

커널은 컴퓨터 자원을 보호하기 위해 사용자나 응용 프로그램이 자원에 직접 접근하는 것을 차단한다. 따라서 자원을 이용하려면 시스템 호출이라는 인터페이스를 이용해 접근해야한다. 

- 시스템 호출은 커널이 제공하는 시스템 자원을 사용하기 위한 함수
- 응용 프로그램이 하드웨어 자원에 접근하거나 운영체제가 제공하는 서비스를 이용하려면, 시스템 호출을 사용해야 한다.
- 운영체제는 커널이 제공하는 서비스를 시슽템 호출로 제한하고 다른 방법으로는 커널에 들어오지 못하게 막아 컴퓨터 자원을 보호한다.
- 시스템 호출은 커널이 제공하는 서비스를 이용하기 위한 인터페이스이며 사용자가 자발적으로 커널 영역에 진입할 수 있는 유일한 수단이다.

### 프로세스

### 프로세스 개념

프로세스란 프로그램이 메모리에 적재되어 CPU를 할당받아 실행되는 것을 의미합니다. 

### 프로세스 상태

일괄작업 / 시분할 작업인가에 따라 프로세스의 상태가 분류됨 

일괄 작업 

- 생성 상태 
  - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태  
- 준비 상태 
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태 
- 실행 상태 
  - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태. 
  - 실행 상태에 들어간 프로세스는 일정 시간동안 CPU를 사용할 권리를 가짐 
  - 만약 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면 준비상태로 돌아와 다음 차례를 기다림
- 완료 상태
  - 실행 상태의 프로세스가 주어진 시간동안 작업을 마치면 완료상태로 진입
  - 완료 상태는 PCB가 사라진 상태를 의미함.

시분할 작업 

- 대기상태
  - 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때 까지 기다리는 상태
  - 입출력 장치별로 마련된 큐에서 기다림
  - 입출력이 완료되면 인터럽트가 발생하고, 대기 상태에 있는 여러 프로세스 중 인터럽트로 깨어날 프로세스를 찾는다. 
  - 찾아낸 프로세스의 PCB를 준비 상태로 이동시킨다. 

### 프로세스 제어 블록

Process Control Block은 프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조이다. 

모든 프로세스에는 고유의 프로세스 제어 블록이 있으며, 프로세스가 생성될 때 만들어져 프로세스 실행이 완료되면 폐기된다. 

구성 요소 

- 포인터
  - PCB의 포인터
- 프로세스 상태
  - 현재 프로세스가 어떤 상태에 있는 지를 나타낸다.
  - 생성, 준비, 실행, 대기, 완료 등이 있다. 
- 프로세스 구분자
  - 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장한다.
- 프로그램 카운터
  - 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장한다. 

### 프로세스 문맥 교환

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbo7AAl%2Fbtq4NJ9k7ZR%2FL4NTd0A2iIlyZ0GXhmcz6K%2Fimg.png)

문맥 교환이란 한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것을 말한다. 

이 때, 이전의 프로세스의 상태를 PCB에 저장하여 보관하고, 새로운 프로세스의 PCB를 읽어 보관된 상태를 복구하는 작업이 이루어진다. 