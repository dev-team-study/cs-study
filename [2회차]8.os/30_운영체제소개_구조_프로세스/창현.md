# 1. Java 컬렉션
 ## 1.1 List
  ### 1.1.1 ArrayList
  - 중복을 허용하고 입력되는 순서를 유지하며 배열을 이용해서 원소들을 관리
  - Array와 다른 점으로는 Array는 크기가 고정되지만, ArrayList는 크기가 유동적
  - 특정 인덱스를 조회할 경우 O(1) 시간으로 바로 접근하여 값을 가져올 수 있음
  - 데이터 삽입, 삭제시 요소들을 모두 옮겨 담아야하므로 O(N)이 걸림
  ### 1.1.2 LinkedList
  - 연결된 노드들의 집합이며, 각 노드는 데이터와 포인터로 이루어져있음
  - 특정 노드를 가져오고 싶을 때는 무조건 O(N)으로 첫번째 노드부터 순차적으로 탐색해야 함
  - 데이터 삽입, 삭제시 ArrayList와는 다르게 삽입, 삭제해야하는 곳으로 찾아가는 시간 + 삽입, 삭제 작업 O(1)을 수행하여 삽입, 삭제에 있어서는 더 빠름
  
 ## 1.2 Map
  - Map은 Key-Value의 쌍들을 저장하는 자료구조

  ### 1.2.1 HashTable
  - 배열과 해시 함수를 이용한 Map의 구현체
  - 해시 함수를 이용해서 동작하는데, 키 값을 이용하여 해시 함수에 넣어주고 리턴되는 정수 값을 나머지 연산을 통해 배열의 인덱스에다가 키와 값을 넣어줌 
    - hascode() % M 값으로 산출
  - HashTable은 테이블 자체에 싱크로나이즈드가 걸려있어 멀티쓰레드 환경에서 사용하기에 좋으나 단일 키에 대한 락이 아닌 모든 데이터에 대한 락으로 성능상 좋지 못함

  ### 1.2.2 HashMap
  - HashTable과 거의 비슷한 구조로 쓰레드 간의 동기화를 지원하지 않아 Thread-Safe하지 않음
  - HashMap은 Key가 Null인 것도 허용
  - Hash 충돌이 발생하면 내부적으로 구현되어있는 연결리스트를 통해 새로운 노드를 만들고 해당하는 인덱스에 맞게 연결 됨
    - 내부적으로 연결리스트를 통해 연결된 노드의 숫자가 8을 넘어가는 경우 데이터 저장방식 효율이 떨어지는데 이때, RedBlackTree를 이용하여 처리 함
    - 이때 일반 Node에서 TreeNode로 변경됨
    - RedBlackTree는 균형이 무너지는 것을 막기위함 -> O(log N), 일반 이진트리에서는 균형이 무너지면 O(N)까지도 걸림

  ### 1.2.3 LinkedHashMap
  - HashMap과 구조는 비슷하나, 배열안에 구현되어있는 노드에 이전 노드값과 이후 노드 값을 가지고 있어 순서를 유지하는 자료구조
  - 순서 보장에 필요한 값들이 필요하여 더 많은 메모리가 필요함
  - 동기화 처리되어있지 않아 Thread-Safe하지 않음.

  ### 1.2.4 TreeMap
  - 이진 트리를 기반으로 한 Map 컬렉션
  - TreeMap에 객체를 저장하면 자동으로 정렬 됨, 키는 저장과 동시에 자동 오름차순으로 정렬 
  - 부모 키 값과 비교해서 키 값이 낮은 것은 왼쪽 자신 노드, 높은 것은 오른쪽 자식노드에 객체를 저장
  - 정렬된 상태를 유지하기 위해서나 범위 검색이 필요한 경우
  - 내부적으로는 레드 블랙 트리의 자료구조를 이용함

 ## 1.3 HashMap vs ConcurrentHashMap
 - ConcurrentHashMap은 동시성에 있어서 안전, 추가 및 삭제와 같은 수정 작업만 동기화되고 읽기 작업은 동기화 X
 - ConcurrentHashMap은 null키과 null값을 허용하지 않음
 - 버킷 단위로 Lock을 걸어서 성능에 있어서 HashTable 보다 뛰어남
 - 다중 처리에 능함

# 2. 운영체제
 ## 2.1 운영체제 소개
  ### 2.1.1 운영체제 필요성 및 역할
  - 사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 응용 프로그램이 동작하도록 지원
    - 시스템 자원을 효율적으로 관리하여 응용프로그램이 원활하게 동작할 수 있도록 함

  ### 2.1.2 운영체제 정의
  - 컴퓨터 하드웨어와 응용 프로그램 간의 상호작용을 관리하고 제어해주는 소프트웨어를 의미

 ## 2.2 운영체제 구조
  ### 2.2.1 커널
  - 운영체제의 핵심으로서 부팅 이후 메모리에 상주하는 부분. 메인 메모리와 CPU, 입출력장치등을 관리하며 주로 자원 관리와 자원 사용에 대한 관리를 함

  ### 2.2.2 시스템 호출
  - 응용 프로그램과 커널이 만나는 접점이 되어주는 것을 의미하며
  - 응용 프로그램이 시스템 호출을 통해 하드웨어를 조작하고 사용하는 것을 의미 함

  ### 2.2.3 유저모드 & 커널모드
  - 응용프로그램을 사용할 때는 유저모드를 사용함
  - 프로그램 실행중에 인터럽트나 시스템 콜이 일어나면 커널모드로 변경 됨
  - 커널 모드가 없는 경우 -> 모든 응용프로그램이 마음대로 커널에 접근해서 처리할 수 있기 때문에 이런 것들을 커널 모드를 통해 시스템을 보호하기 위해서 임

 ## 2.3 프로세스
  ### 2.3.1 프로세스 개념
  - 실행중인 프로그램을 의미함
    - 실행중인 프로그램이라하면 작성한 코드를 메모리에 얹혀서 실행시키고 있는 상태를 의미

  ### 2.3.2 프로세스 상태
  - new: 프로세스가 생성된 상태
  - ready: 프로세스가 할당되기 전인 상태
  - running: 프로세스가 할당되어 실행중인 상태
  - waiting: 프로세스가 오래걸리는 작업이나 이벤트로 인해서 반납하고 대기하는 상태
  - terminate: 프로세스가 종료된 상태

  - 준비 -> 실행: 레디큐 맨 앞에 있는 프로세스에게 프로세스를 할당하는 것을 디스패치라고 함
  - 실행 -> 준비: 한 프로세스가 독점하는 것을 막기 위해 타이머를 두어 특정 프로세그가 할당한 시간 만큼만 점유하게하고, 타이머가 끝나면 인터럽트를 발생시켜 시간을 전부 소진한 프로세스는 준비상태로 돌아감
  - 실행 -> 대기: 프로세스를 진행하다가 입출력 명령이나 시간이 많이 필요한 이벤트가 발생하면 프로세스를 스스로 반납하고 대기 상태가 됨
  - 대기 -> 준비: 대기 상태에서 입출력 작업이 끝나면 준비 상태가 됨
  ### 2.3.3 프로세스 제어 블록
  - 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널내의 자료구조
  - 프로세스의 상태관리와 문맥 교환 때문에 필요함
  
  PCB
  - 프로세스 식별자: PID
  - 프로세스 상태: CPU 할당 가능 여부
  - 프로그램 카운터: 다음에 수행할 명령의 위치
  - 레지스터 저장 영역: 레지스터 관련 정보
  - 프로세스 스케줄링 정보: 우선순위 등
  - 계정 정보: CPU 사용시간, 계정 번호 등등

  ### 2.3.4 프로세스 문맥 교환
  - 하나의 프로세스로부터 다른 프로세스로 CPU 제어권이 이양되는 과정을 의미
  - 컨텍스트 스위칭이라고도 이야기하며, 잦은 컨텍스트 스위칭은 성능이 좋아지지 않음.

  ### 2.3.5 프로세스 메모리 구조
  - 스택: 지역변수를 저장하고, 함수에 대한 정보를 저장함
  - 힙: 동적으로 메모리를 할당하는데 사용되는 영역
  - 데이터: 전역 변수나 정적 변수를 저장하거나 할당
  - 코드: 프로그램의 코드 자체를 저장하는 영역, 기계어로 제어되는 메모리 영역



## 질문
1. ArrayList와 LinkedList의 차이에 대해서 설명해주세요.
2. LinkedList가 ArrayList보다 항상 삽입/삭제에 있어서 빠를까요?
3. Hash Collision에 대해서 설명해주시고, 극복할 수 있는 방법에 대해서 설명해주세요.
4. HashMap이 내부적으로 어떻게 구현되어있는지 아는지? 동작 방법에 대해서 설명해주세요.
5. ConcurrentHashMap의 특징에 대해서 설명해주세요.
6. 시스템 콜에 대해서 설명해주세요.
7. 프로세스에 대해서 설명해주세요.
8. 프로세스 문맥 교환이 무엇인지 설명해주세요.