## 메모리 관리

### 메모리 관리 필요성

메모리는 한정된 자원이기 때문에 효율적으로 사용하고 관리해야한다. 

메모리 관리의 주요 목적은 메모리 공간을 최대한 효율적으로 사용해 프로그램의 실행 속도와 시스템의 성능을 최적화 하는 것이다. 

### 고정 분할 방식

고정 분할 방식에서는 메모리가 고정된 크기의 여러 영역으로 나뉘어진다. 

각각의 분할된 영역은 하나의 프로그램만을 수용할 수 있다. 

장점

- 구현이 간단하고, 메모리 할당 및 회수가 용이하다.

단점

- 내부 단편화 (Internal Fragmentation)
  - 프로그램의 크기가 할당된 분할보다 작을 경우, 남은 공간은 낭비된다.
- 유연성 부족
  - 모든 프로그램이 같은 크기의 메모리를 필요로 하지 않기 때문에, 크기가 다양한 프로그램을 효율적으로 관리하기 어렵다.
- 메모리 용량 제한
  - 큰 프로그램은 큰 분할에만 할당될 수 있으므로, 메모리에 여유 공간이 있더라도 큰 프로그램을 수용하지 못할 수 있다.

### 가변 분할 방식

가변 분할 방식에서는 메모리를 프로그램의 크기에 따라 동적으로 분할한다. 

프로그램이 메모리에 로드될 때 필요한 만큼의 메모리를 할당받는다.

장점

- 메모리를 보다 효율적으로 사용할 수 있으며, 메모리 공간의 낭비를 줄일 수 있다.

단점

- 외부 단편화 문제가 발생할 수 있다. 
- (충분한 총 메모리가 있음에도 불구하고, 사용가능한 메모리 공간이 작은 조각으로 분산되어 큰 프로그램을 수용하기 어려울 수 있다.)



## 가상 메모리 개요

### 가상 메모리 정의

물리 메모리(주로 RAM)의 크기를 초과하는 프로그램을 실행할 수 있게 해주는 방법이다. 

이 기법은 물리 메모리와 보조 기억 장치를 함께 사용해, 운영체제가 더 큰 메모리 공간을 프로그램에 제공하는 것처럼 만듬.

가상 메모리는 프로그램에게 더 넓은 주소 공간을 제공하며, 실제 물리 메모리의 크기에 구애받지 않고, 여러 프로그램을 동시에 실행할수 있는 환경을 만든다.

### 가상 메모리 필요성

- 메모리 공간의 확장 
  - 가상 메모리를 사요앟면, 물리 메모리의 크기를 초과하는 양의 데이터를 처리할 수 있다.
  - 작업 공간의 제약 없이 대형 프로그램을 실행할 수 있게 해준다.
- 메모리 보호
  - 각 프로세스에 독립된 가상 주소 공간을 제공함으로써, 프로세스 간 메모리 충돌을 방지하고, 시스템의 안정성을 높인다.
- 데이터 관리의 용이성
  - 프로세스는 물리 메모리의 실제 위치에 대해 신경 쓰지 않고, 연속적인 가상 주소공간을 사용할 수 있다.
  - 이는 프로그래밍의 복잡성을 줄이고, 데이터 관리를 용이하게 한다.
- 효율적인 메모리 사용
  - 가상 메모리 시스템은 사용 중인 메모리 영역만을 물리 메모리에 유지함으로써, 물리 메모리를 보다 효율적으로 사용할 수 있게 한다.

### 페이징 기법

페이징 기법은 process가 할당받은 메모리 공간을 일정한 page 단위로 나누어, 물리 메모리에서 연속되지 않는 서로 다른 위치에 저장하는 메모리 관리 기법.

페이징 기법에서는 주소바인딩을 위해 모든 프로세스가 각각의 주소 변환을 위한 page table을 가진다.

### 세그먼테이션 기법

세그멘테이션 기법이란 process가 할당받은 메모리 공간을 논리적 의미 단위 (segment)로 나누어, 연속되지 않는 물리 메모리 공간에 할당될 수 있도록 하는 메모리 관리 기법이다. (특히 code, data, heap, stacke 등의 기능(의미)단위로 나눔)

세그멘테이션 기법에서는 주소 바인딩을 위해 모든 프로세스가 각각의 주소 변환을 위한 segment table을 가진다.

## 가상 메모리 관리

### 요구 페이징

프로그램 실행 과정에서 실제로 필요할 때에만 해당 페이지를 물리 메모리로 가져오는 방식이다.

물리 메모리를 미리 로딩하지 않음으로써, 메모리 사용 효율성을 극대화한다.

Page fault라는 메커니즘을 통해 필요한 페이지를 식별한다. 

page fault는 프로세스가 접근하려는 페이지가 물리 메모리에 없을 때 발생하며, 운영체제는 페이지 폴트가 발생하면 해당 페이지를 보조 저장 장치에서 찾아 물리 메모리로 로드한다.

### 페이지 교체 알고리즘

메모리가 가득 찼을 때, 새로운 페이지를 로드하기 위해 기존 페이지 중 하나를 교체해야 하는 경우 페이지 교체 알고리즘이 사용된다.

#### FIFO(First In First Out)

- 가장 간단한 페이지 교체 알고리즘으로, 물리 메모리에 가장 먼저 들어온 페이지를 가장 먼저 교체한다.
- queue를 사용해 구현된다.
- 단점 : 오래된 페이지가 자주 사용됨에도 불구하고 교체 되어야 한다. (Belady의 모순), page fault가 증가할 수 있다.

#### OPT

- 미래에 어떤 페이지가 사용될지를 알고 있다고 가정하고, 가장 오랫동안 사용되지 않을 페이지를 교체한다.
- 실제 시스템에서 구현이 불가능하다는 단점이 있으나, 페이지 교체 알고리즘의 성능 비교 기준으로 사용된다.
- 이론적으로 가장 낮은 페이지 폴트율을 보장한다.

#### LRU

- 가장 오랫동안 사용되지 않은 페이지를 교체한다. (마지막으로 사용된 시간을 추적해, 가장 오래 전에 사용된 페이지를 선정한다.)
- FIFO의 단점을 일정 부분 해결하며, 실제 사용 패턴을 반영해 보다 효율적인 페이지 교체를 수행한다.
- 구현 복잡성과 오버헤드가 존재하지만, OPT에 비해 실제 시스템에서 구현 가능하고 효율적인 성능을 제공한다.