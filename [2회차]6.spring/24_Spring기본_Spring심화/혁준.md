# 1. IoC와 DI에 대해 설명해 주세요.

  - IoC(Inversion of Control, 제어의 역전)
    - 프로그램의 제어 흐름 구조가 뒤바뀌는 것을 말합니다.
    - 전통적인 프로그래밍에서는 사용자가 작성한 코드가 제어의 흐름을 담당하지만,
    - IoC를 적용한 경우에는 프레임워크나 컨테이너가 주도권을 가지고 객체의 생성부터 생명주기 관리까지를 담당합니다.
  - DI(Dependency Injection, 의존성 주입)
    - IoC를 구현하는 방법 중 하나입니다.
    - 객체가 필요로 하는 의존성을 외부에서 주입해주는 방식으로, 객체 간의 결합도를 낮추고 코드의 재사용성과 유지보수성을 높입니다.

  <details>
    <summary>후보 없이 특정 기능을 하는 클래스가 딱 1개라면, 구체 클래스를 사용해도 되지 않을까요? 근데, 왜 Spring에선 Bean을 사용 할까요?</summary>

     - Spring에서는 Bean을 사용하여 객체의 생명 주기를 관리합니다. 
     - Bean을 사용하면 개발자는 객체 생성, 소멸 등의 생명 주기 관리와 같은 부수적인 작업을 하지 않아도 되며, 객체의 의존성을 자동으로 관리해줍니다. 
     - 또한, Bean을 사용하면 하나의 객체를 여러 컴포넌트에서 공유하여 사용할 수 있어 메모리 사용량을 줄일 수 있습니다.
  </details>
  <details>
    <summary>Spring의 Bean 생명 주기(Life Cycle)에 대해 자세히 설명해 주세요.</summary>

    1. Bean 정의 읽기: 
      - Spring IoC 컨테이너는 Bean 정의를 읽어 들입니다. 
      - 이는 XML 파일, Java Config, Annotation 등 여러 방식으로 제공될 수 있습니다.
    2. Bean 인스턴스 생성: 
      - Bean 정의에 따라 Spring 컨테이너는 Bean 인스턴스를 생성합니다.
    3. 의존성 주입: 
      - Bean이 다른 Bean에 의존하는 경우, Spring 컨테이너는 이 의존성을 주입합니다. 
      - 이는 생성자 주입, 세터 주입, 필드 주입 등 여러 방식으로 이루어질 수 있습니다.
    4. Bean 초기화: 
      - Bean이 org.springframework.beans.factory.InitializingBean 인터페이스를 구현하는 경우, afterPropertiesSet() 메서드가 호출됩니다. 
      - 또는, @PostConstruct 애노테이션이나 init-method 속성을 사용하여 초기화 메서드를 지정할 수 있습니다.
    5. Bean 사용: 
      - 이제 애플리케이션은 Bean을 사용하여 비즈니스 로직을 수행할 수 있습니다.
    6. Bean 소멸: 
      - Bean이 org.springframework.beans.factory.DisposableBean 인터페이스를 구현하는 경우, destroy() 메서드가 호출됩니다. 
      - 또는, @PreDestroy 애노테이션이나 destroy-method 속성을 사용하여 소멸 메서드를 지정할 수 있습니다.
  
    이렇게 Spring 컨테이너는 Bean의 생성부터 소멸까지 전체 생명 주기를 관리합니다. 
    이를 통해 개발자는 비즈니스 로직에 집중하고, 객체의 생명 주기 관리와 같은 부수적인 작업을 Spring에게 맡길 수 있습니다.
  </details>
  <details>
    <summary>Spring Bean의 생명 주기 활용 방법에 대해 알려주세요.</summary>

    1. 초기화 메서드 사용: 
      - Bean이 생성되고 의존성이 주입된 후, 초기화 작업이 필요할 경우 사용합니다. 
      - 예를 들어, 데이터베이스 커넥션 풀을 초기화하거나, 캐시를 미리 로딩하는 등의 작업을 수행할 수 있습니다. 
      - 초기화 메서드 방법은 다음과 같습니다.
        - @PostConstruct 애노테이션 사용
        - InitializingBean 인터페이스의 afterPropertiesSet() 메서드를 오버라이드
        - XML 설정에서 init-method 속성을 지정하여 사용
    2. 소멸 메서드 사용: 
      - Bean이 컨테이너에서 제거되기 전에 리소스를 해제하거나, 종료에 필요한 작업을 수행할 경우 사용합니다. 
      - 소멸 메서드 방법은 다음과 같습니다.
        - @PreDestroy 애노테이션 사용
        - DisposableBean 인터페이스의 destroy() 메서드를 오버라이드
        - XML 설정에서 destroy-method 속성을 지정하여 사용
    3. BeanFactoryPostProcessor와 BeanPostProcessor 사용:
      - 이들은 Bean의 생성과 초기화 과정을 좀 더 세밀하게 제어할 수 있게 해줍니다. 
      - BeanFactoryPostProcessor : Bean 정의가 컨테이너에 로드되고, Bean 인스턴스가 생성되기 전에 작업을 수행합니다.
      - BeanPostProcessor : Bean 인스턴스가 생성된 후, 초기화 메서드가 호출되기 전과 후에 작업을 수행합니다.
    4. ApplicationListener 사용: 
      - Spring에서 발생하는 이벤트를 처리하기 위해 사용합니다. 
      - 예를 들어, 컨테이너가 시작하거나 종료될 때 특정 작업을 수행하고 싶다면 ContextStartedEvent나 ContextClosedEvent를 처리하는 ApplicationListener를 구현할 수 있습니다.

    이처럼 Spring Bean의 생명주기를 활용하면, 
    Bean의 생성과 소멸 시점에 특정 작업을 수행하거나, 
    Bean의 생성과 초기화 과정을 세밀하게 제어하거나, 
    Spring의 이벤트를 처리하는 등 다양한 작업을 할 수 있습니다.
  </details>
  <details>
    <summary>생성자 주입, 세터 주입과 필드 주입의 장단점에 대해 알려주세요.</summary>

    1. 생성자 주입
      - 장점: 
        - 객체가 생성될 때 모든 의존성이 주입되므로, 객체의 불변성을 보장할 수 있습니다. 
        - 순환 참조를 방지할 수 있습니다. 순환 참조가 발생하면, 애플리케이션 구동 시점에 오류가 발생합니다. 
        - 테스트에 유리합니다. 생성자를 통해 의존성을 주입하면, 테스트 시에도 쉽게 Mock 객체 등을 주입할 수 있습니다.
      - 단점:
        - 의존성이 많아지면 생성자의 파라미터가 많아져 복잡해질 수 있습니다.
    2. 세터 주입
      - 장점: 
        - 선택적인 의존성을 가질 수 있습니다. 
        - 생성자 주입과 달리, 필요한 의존성만 주입할 수 있습니다. 
        - 의존성이 추가되거나 변경되더라도 기존 코드를 변경하지 않아도 됩니다.
      - 단점:
        - 객체가 생성된 후에도 의존성이 변경될 수 있으므로, 객체의 상태를 추적하기 어렵습니다.
        - 순환 참조가 발생할 가능성이 있습니다.
    3. 필드 주입
      - 장점: 
        - 코드가 간결합니다. 세터 메서드가 필요 없으므로 코드량이 줄어듭니다.
      - 단점:
        - 객체가 생성된 후에도 의존성이 변경될 수 있으므로, 객체의 불변성을 보장할 수 없습니다.
        - 테스트가 어렵습니다. 필드에 직접 주입하므로, 테스트 시에 Mock 객체 등을 주입하기 어렵습니다.
        - 의존성 주입을 강제할 수 없습니다. 세터나 생성자가 없으므로, 필요한 의존성을 누락할 가능성이 있습니다.

    이러한 장단점을 고려하여 상황에 맞는 주입 방식을 선택하는 것이 중요합니다. 
    그러나 일반적으로는 생성자 주입 방식을 권장하며, 필요에 따라 세터 주입을 사용하고, 필드 주입은 가능한 피하는 것이 좋습니다.
  </details>
  <details>
    <summary>생성자 주입 방식을 사용하는 이유가 있나요?</summary>

    생성자 주입 방식을 사용하면, 객체가 생성될 때 모든 의존성이 주입되므로 객체의 불변성을 보장할 수 있습니다. 
    또한, 순환 참조를 방지할 수 있으며, 테스트에도 유리합니다. 
    이런 이유로 Spring에서는 생성자 주입 방식을 권장하고 있습니다.
  </details>
  <details>
    <summary>Bean Scope 에 대해서 아시나요? 안다면, 해당 Scope들을 설명해주세요.</summary>

    - Singleton: 기본 Scope로, Spring 컨테이너 내에 하나의 Bean 인스턴스만 생성합니다. 
    - Prototype: 요청할 때마다 새로운 Bean 인스턴스를 생성합니다. 
    - Request: HTTP 요청당 하나의 Bean 인스턴스를 생성합니다. 
    - Session: HTTP 세션당 하나의 Bean 인스턴스를 생성합니다. 
    - Application: Servlet Context당 하나의 Bean 인스턴스를 생성합니다. 
    - WebSocket: WebSocket당 하나의 Bean 인스턴스를 생성합니다.
  </details>
  <details>
    <summary>default scope 가 어떤 scope인지 이유와 함께 설명하세요.</summary>
    
    - Spring의 기본 Bean Scope는 Singleton입니다. 
    - 이는 Spring이 객체의 생명 주기를 관리하고, 객체 간의 의존성을 관리하는 DI 컨테이너의 특성상, 
    - 대부분의 경우에 하나의 Bean 인스턴스만을 생성하여 재사용하는 것이 효율적이기 때문입니다.
  </details>
  <details>
    <summary>인스턴스를 새로 만들지 않고 재사용하는 것은 어떤 장점이 있나요?</summary>

    - 인스턴스를 재사용하면 메모리 사용량을 줄일 수 있고, 객체 생성에 드는 비용도 절약할 수 있습니다. 
    - 또한, 상태를 공유해야 하는 경우에도 인스턴스 재사용이 유용합니다.
  </details>
  <details>
    <summary>prototype scope 는 어떨 때 사용하는 지 아시나요?</summary>

    - Prototype Scope는 요청할 때마다 새로운 Bean 인스턴스를 생성하므로, 
    - 상태를 유지해야 하는 경우나 여러 요청에서 독립적인 인스턴스가 필요한 경우에 사용합니다. 
  </details>
  <details>
    <summary>스프링 컨테이너란 무엇인가요?</summary>

    - 스프링 컨테이너는 스프링 프레임워크의 핵심 부분으로, Bean 객체의 생성과 관리, 그리고 Bean 간의 의존성을 처리하는 역할을 합니다. 
    - 스프링 컨테이너는 ApplicationContext 인터페이스를 구현하여 제공되며, BeanFactory 인터페이스를 확장한 고급 컨테이너입니다. 
    - 이를 통해 개발자는 객체의 생명 주기 관리와 같은 부수적인 작업을 스프링 컨테이너에게 맡기고, 비즈니스 로직에 집중할 수 있습니다.
  </details>
  <details>
    <summary>어노테이션이란 무엇이란 무엇인가요?</summary>

    - 어노테이션은 자바 소스 코드에 메타데이터를 제공하는 방법입니다. 
    - 이는 코드의 의미를 설명하거나, 컴파일 시점이나 실행 시점에 특정 기능을 수행하도록 정보를 제공합니다. 
    - 예를 들어, @Override 어노테이션은 메서드가 상위 클래스의 메서드를 오버라이드한다는 것을 컴파일러에게 알려줍니다.
    - 예를 들어, @Autowired 어노테이션은 스프링 프레임워크에게 의존성 주입을 요청합니다.
  </details>
  <details>
    <summary>빈 혹은 컴포넌트 등록을 위한 각 어노테이션을 설명해주세요.</summary>

    - @Bean: 
      - 개발자가 직접 제어가 불가능한 외부 라이브러리 등을 빈으로 등록하고 싶을 때 사용합니다.
    - @Component: 
      - 일반적인 컴포넌트를 등록합니다. 
      - @Service, @Repository, @Controller 등은 @Component의 특별한 형태입니다. 
        - @Service: 비즈니스 로직을 수행하는 서비스 레이어의 컴포넌트를 등록합니다. 
        - @Repository: 데이터베이스 연산을 수행하는 DAO 컴포넌트를 등록합니다. 
        - @Controller: 사용자의 요청을 처리하는 컨트롤러 컴포넌트를 등록합니다.
  </details>
  <details>
    <summary>Spring에서 @Controller 와 @RestController 은 어떤 차이가 있나요?</summary>

     - @Controller: 
       - 일반적인 웹 페이지 요청을 처리하는 컨트롤러를 정의합니다. 
       - 메서드가 뷰 이름을 반환하며, 
       - 이 뷰 이름과 실제 뷰를 연결하는 작업이 필요합니다. 
     - @RestController: 
       - RESTful 웹 서비스 요청을 처리하는 컨트롤러를 정의합니다. 
       - 메서드가 데이터를 반환하며, 이 데이터는 HTTP 응답 본문에 직접 쓰여집니다. 
       - @RestController는 사실상 @Controller와 @ResponseBody가 결합된 형태입니다.
  </details>
  <details>
    <summary>그렇다면, @Controller 로 작성했을 땐 Rest 방식인 String JSON 으로 반환하지 못하나요?</summary>

    - @Controller로 작성된 컨트롤러에서 JSON을 반환하려면, 메서드에 @ResponseBody 어노테이션을 추가하면 됩니다. 
    - 이는 메서드가 반환하는 값을 HTTP 응답 본문에 직접 쓰도록 합니다. 
    - 따라서 @Controller로도 JSON을 반환하는 것이 가능합니다.
  </details>
  <details>
    <summary>빈과 컴포넌트 차이에 대해 설명해주세요.</summary>

    - 빈(Bean): 
      - 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용합니다. 
      - 스프링 IoC(Inversion of Control) 컨테이너가 관리하는 객체를 의미합니다. 
      - 개발자가 직접 생성과 관리를 하지 않고, 스프링 컨테이너가 대신 생성, 관리, 제거하는 객체입니다. 
      - @Bean 어노테이션을 이용해서 등록할 수 있습니다.
    - 컴포넌트(Component): 
      - 개발자가 직접 컨트롤이 가능한 Class들의 경우엔 @Component를 사용합니다.
      - 스프링에서 직접 관리하는 빈 중에서 특별한 역할을 가진 빈을 가리키는 용어입니다. 
      - @Component 어노테이션을 이용해서 등록할 수 있으며, @Controller, @Service, @Repository 등이 이에 속합니다.
  </details>
  <details>
    <summary>@Component 을 메서드 레벨에 선언할 수 있을까? 혹은 @Bean 을 클래스 레벨에 선언할 수 있을까?</summary>

    - 사용할 수 없습니다.
    - @Bean과 @Component 는 각자 선언할 수 있는 타입이 정해져있어 해당 용도 외에는 컴파일 에러를 발생시킨다.
    - 예를 들어 @Bean 같은 경우에는 @Target이 METHOD로 지정되어 있지만, TYPE은 없습니다.
    - 반대로 @Component 는 @Target이 TYPE로 지정되어 Class위에서만 선언될수 있음을 알 수 있습니다.

  </details>
  <details>
    <summary>BeanFactory vs ApplicationContext 차이에 대해 설명해주세요.</summary>

    - BeanFactory와 ApplicationContext는 둘 다 스프링 컨테이너로 빈의 생성과 관리를 담당합니다. 
    - 하지만 ApplicationContext는 BeanFactory의 모든 기능을 포함하면서도 그 이상의 기능을 제공합니다.
    - 또한 BeanFactory 는 요청 시 빈을 로드하고, ApplicationContext는 시작 시 모든 빈을 로드합니다. 
    - 따라서 BeanFactory 는 ApplicationContext 에 비해 가볍습니다.

    - BeanFactory: 
      - 빈의 생성, 설정, 보관, 재사용 등의 기본적인 기능을 제공합니다.
      - BeanFactory는 모든 기능이 Lazy 하게 동작합니다. 즉, Lazy-loading 방식을 사용합니다.
      - 실제 빈이 요청될 때까지 빈의 생성을 늦추기에, 빈을 사용할 때 빈을 로딩하기 때문에, 경량 컨테이너로, 성능상 이점이 있습니다.
      - 하지만 실제 다 작동하기 전까지는 어떤 부분에서 문제가 발생하는 것인지를 알 수 없다는 단점이 있기에, 사용하는 경우는 많지 않습니다.
    - ApplicationContext: 
      - BeanFactory의 기능을 모두 포함하고, 추가로 메시지 소스 처리(국제화 지원), 이벤트 발행, 웹 애플리케이션에 필요한 여러 기능 등을 제공합니다.
      - BeanFactory와는 다르게 런타임 실행시 모든 빈을 미리 로딩시킵니다. 즉, Eager-loading 방식을 사용합니다.
  
    따라서 대부분의 경우 ApplicationContext를 사용하는 것이 좋습니다. 
    ApplicationContext는 BeanFactory를 상속받아 확장한 인터페이스이므로, 필요한 경우 BeanFactory의 기능도 사용할 수 있습니다.
  </details>

<br/>

# 2. AOP(Aspect Oriented Programming)에 대해 설명해 주세요.

  - AOP, 즉 관점 지향 프로그래밍은 횡단 관심사를 분리하여 모듈화하는 프로그래밍 패러다임입니다. 
  - 로깅, 트랜잭션 관리, 보안 등 여러 곳에서 공통으로 사용되는 코드를 분리하여 중복을 제거하고, 코드의 가독성을 높이는 데 도움을 줍니다.

  <details>
    <summary>AOP 동작원리에 대해 설명해보세요.</summary>

    - AOP는 프록시 패턴을 기반으로 동작합니다. 
    - 스프링 AOP에서는 특정 빈에 대한 프록시 객체를 생성한 후, 이 프록시 객체를 통해 원래의 빈을 대신하여 동작하게 합니다. 
    - 이 프록시 객체에서는 원래의 빈의 메서드 실행 전후에 추가적인 로직(Advice)를 실행하여, 횡단 관심사를 처리합니다. 
  </details>
  <details>
    <summary>AOP 용어들을 설명해보세요. (Advice, Joinpoint, Pointcut, Weaving, Aspect, Target, Proxy, Introduction)</summary>

    - Advice: 
      - 횡단 관심사의 코드를 가리키며, 언제 실행할 지를 정의합니다. 
      - 예를 들어, 메서드 호출 전후에 실행하는 등의 설정이 가능합니다. 
    - Joinpoint: 
      - Advice가 적용될 수 있는 위치를 말합니다. 
      - 스프링 AOP에서는 메서드 호출이 Joinpoint에 해당합니다. 
    - Pointcut: 
      - 어떤 Joinpoint에 Advice를 적용할 지를 정의하는 것입니다. 
      - 표현식을 통해 특정 메서드를 선택하는 등의 설정이 가능합니다. 
    - Weaving: 
      - Advice를 Joinpoint에 적용하는 과정을 말합니다. 
      - 컴파일, 로드, 런타임 등 다양한 시점에서 수행될 수 있습니다. 
    - Aspect: 
      - 횡단 관심사를 모듈화한 것을 말합니다. 
      - Advice와 Pointcut을 포함합니다.
    - Target: 
      - Advice가 적용되는 대상 객체를 말합니다. 
      - 스프링 AOP에서는 빈 객체가 Target에 해당합니다.
    - Proxy: 
      - Target에 Advice를 적용하여 생성한 객체를 말합니다. 
      - 스프링 AOP에서는 런타임에 프록시 객체를 생성하여 AOP를 구현합니다.
    - Introduction: 
      - 기존 클래스에 새로운 메서드나 필드를 추가하는 것을 말합니다. 
      - 스프링 AOP에서는 @DeclareParents 어노테이션을 이용하여 Introduction을 구현할 수 있습니다. 
      - 이를 통해 특정 클래스가 특정 인터페이스를 구현하도록 할 수 있습니다.
  </details>
  <details>
    <summary>@Aspect는 어떻게 동작하나요?</summary>

    - @Aspect 어노테이션은 클래스 레벨에서 적용되며, 해당 클래스를 Aspect로 정의합니다. 
    - 이 클래스 내부에서 Pointcut과 Advice를 정의하며, 이를 통해 어떤 Joinpoint에 어떤 Advice를 적용할 지를 설정합니다.
  </details>
  <details>
    <summary>AspectJ 란 무엇인가요?</summary>

    - AspectJ는 AOP를 구현하기 위한 자바 프레임워크입니다. 
    - 스프링 AOP는 실행 시점에 동적으로 프록시 객체를 생성하여 AOP를 구현하는 반면, AspectJ는 컴파일 시점에 바이트 코드를 조작하여 AOP를 구현합니다. 
  </details>
  <details>
    <summary>AOP와 필터, 인터셉터의 차이점에 대해 자세하게 설명해보세요.</summary>

    1. 작동 시점 
      - 필터: 
        - 스프링의 디스패처 서블릿이 작동하기 전과 후로 동작합니다.
        - 즉, 서블릿 컨테이너 단에서 동작하며, HTTP 요청이 웹 애플리케이션에 들어오고 나가는 시점에 동작합니다. 
        - 따라서 필터는 스프링의 컨텍스트 외부에서 작동하며, 스프링과 관련이 없는 웹 리소스에 대해서도 작동합니다. 
      - 인터셉터: 
        - 스프링의 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청을 가로챕니다. 
        - 따라서 인터셉터는 스프링의 컨텍스트 내부에서 작동하며, 스프링 MVC의 컨트롤러에 대해서만 작동합니다. 
      - AOP
        - 특정 Joinpoint에서 동작하며, 이는 메서드 호출 전/후, 메서드 실행 중 예외 발생 시 등 다양한 시점에 해당될 수 있습니다.
        - 즉, 특정 메서드 호출 전/후에 실행됩니다.
    2. 접근 가능한 객체
      - 필터: 
        - HttpServletRequest와 HttpServletResponse 객체에만 접근할 수 있습니다. 
        - 스프링의 컨텍스트에 접근하는 것은 불가능합니다.
      - 인터셉터: 
        - HttpServletRequest와 HttpServletResponse 뿐만 아니라,  HandlerMapping이 선택한 Controller(핸들러)에 대한 정보에도 접근이 가능합니다. 
        - 또한, 스프링의 컨텍스트에 접근하는 것도 가능합니다.
        - 이를 통해 특정 컨트롤러에 대한 요청인지를 판단하거나, 컨트롤러의 실행 여부를 결정하는 등의 로직을 구현할 수 있습니다. 
      - AOP
        - 클래스, 메서드, 필드 등 다양한 객체에 접근이 가능합니다. 
        - 스프링의 컨텍스트에도 접근이 가능합니다. 
    3. 사용 목적
      - 필터: 
        - 인코딩, CORS 설정, 로깅 등의 공통적인 웹 처리를 위해 사용됩니다. 
        - 즉, 공통적으로 설정해야 하는 HTTP 헤더 처리 등 HTTP 요청과 응답에 대한 전/후처리를 합니다.
      - 인터셉터: 
        - 인증, 권한 체크, 세션 체크 등의 스프링 MVC와 관련된 처리를 위해 사용됩니다.
        - 즉, Controller의 실행 전/후로 공통 처리가 필요한 경우에 사용됩니다.
      - AOP
        - 로깅, 트랜잭션 관리, 보안 등 전체 애플리케이션에 걸쳐 공통적으로 적용되어야 하는 횡단 관심사를 처리하는 데 사용됩니다.

    정리하자면, Filter와 Interceptor는 주로 웹 관련 처리에 초점을 맞추는 반면, 
    AOP는 애플리케이션 전체에 걸친 공통 로직을 처리하는 데 주로 사용됩니다. 
    또한, Filter와 Interceptor는 주로 HTTP 요청의 전/후 처리를, AOP는 특정 로직의 전/후 처리를 담당합니다.
  </details>
  <details>
    <summary>AOP 를 실제로 사용해 본 경험이 있나요?</summary>
    로깅을 위해.. 어쩌구.. 저쩌구..
  </details>
  <details>
    <summary>AOP 를 동작시키기 위해 어떤 조건 혹은 어떤 코드를 구성을 해야 AOP 가 정상적으로 동작하는지 아시나요?</summary>

    - Aspect 클래스에 @Aspect 어노테이션을 붙여야 합니다. 
      - Aspect 클래스를 스프링 컨테이너에 빈으로 등록해야 합니다. 
      - 이는 @Component 어노테이션을 이용하거나, XML 설정 등을 통해 가능합니다. 
    - Advice 메서드에 @Before, @After, @Around 등의 어노테이션을 붙여 언제 실행될 지를 설정해야 합니다. 
    - Pointcut 표현식을 통해 어떤 Joinpoint에 Advice를 적용할 지를 설정해야 합니다.
  </details>
  <details>
    <summary>AOP 적용할 수 있는 포인트가 메서드라고 했을 때 메서드의 시작과 끝에 AOP 를 걸 수가 있습니다. 이때, 메서드를 호출하는 과정에서 메서드가 다른 외부에서의 호출이거나 동일한 클래스 내부에서의 호출이 될 수도 있습니다. 이런 경우에 모두 AOP가 동작하나요? 근거와 함께 설명해주세요.</summary>

    - 스프링 AOP는 프록시 기반의 AOP를 사용하므로, 메서드를 호출하는 주체에 따라 AOP가 적용되지 않을 수 있습니다. 
    - 예를 들어, 동일한 클래스 내부에서의 메서드 호출은 프록시를 거치지 않으므로 AOP가 적용되지 않습니다. 
    - 반면, 외부에서의 호출은 프록시를 거치므로 AOP가 적용됩니다. 
    - 이러한 이유로, AOP를 적용하려는 메서드는 외부에서 호출 가능하도록 public으로 선언되어야 합니다.
  </details>

<br/>

# 3. 프록시가 무엇인지 아시나요?

  - 프록시는 '대리인'이라는 의미를 가지며, 다른 객체를 대신하여 그 객체의 기능을 사용하거나 제어하는 역할을 합니다. 
  - 컴퓨터 과학에서는 프록시를 통해 인터페이스를 제공하고, 이를 통해 실제 객체의 기능을 사용하거나 추가적인 기능을 제공합니다

  <details>
    <summary>프록시 패턴이란 무엇인가요?</summary>

    - 프록시 패턴은 디자인 패턴 중 하나로, 어떤 객체에 대한 접근을 제어하거나 추가적인 작업을 수행하기 위해 그 객체의 대리 객체를 제공하는 패턴입니다. 
    - 프록시 객체는 원래 객체와 같은 인터페이스를 가지므로, 클라이언트는 원래 객체인지 프록시 객체인지 구별 없이 사용할 수 있습니다.
  </details>
  <details>
    <summary>프록시 객체란 무엇인가요?</summary>

    - 프록시 객체는 원래 객체를 대신하여 그 객체의 기능을 사용하거나 제어하는 객체를 말합니다. 
    - 프록시 객체는 원래 객체와 같은 인터페이스를 가지므로, 클라이언트는 원래 객체인지 프록시 객체인지 구별 없이 사용할 수 있습니다.
  </details>
  <details>
    <summary>동적 프록시(JDK Dynamic Proxy)에 대해 설명해주세요.</summary>

    - 이 방식은 자바에서 제공하는 동적 프록시 기능으로, 인터페이스를 구현하는 프록시 객체를 런타임에 동적으로 생성합니다. 
    - 이는 런타임에 특정 인터페이스를 구현하는 클래스 또는 인스턴스를 만드는 기술로 Reflection API의 프록시 클래스를 이용하여 구현할 수 있습니다.
    - 이를 통해 원래 객체의 기능을 사용하면서 추가적인 기능을 제공할 수 있습니다.
    
    단, 이 방식은 인터페이스가 있어야만 가능한 방법이고 Reflection을 사용하기 때문에 컴파일러 최적화를 전혀 받지 못해 성능상 좋지 않습니다. 
    그리고 사실 여러 부가기능을 적용해야할 때, 계속해서 무거워집니다.
  </details>
  <details>
    <summary>CGLIB(Code Generation Library)에 대해 설명해주세요.</summary>
    
    - CGLIB는 바이트 코드 조작 라이브러리로, 클래스 파일을 동적으로 생성하여 프록시 객체를 만드는 데 사용됩니다. 
    - 이를 통해 인터페이스가 없는 클래스에 대해서도 프록시 객체를 생성할 수 있습니다. 
    - 즉, 동적 프록시와는 다르게 클래스 기반으로 동작을 하고 특정 라이브러리를 사용하여 프록시를 만듭니다.
    - 이 기능은 스프링 AOP에서 사용되며, JDK Dynamic Proxy로 처리할 수 없는 경우에 CGLIB를 사용하여 프록시 객체를 생성합니다.

    결론적으로 CGLIB은 동적 프록시와는 다르게 외부 의존성을 사용하기 때문에, 의존성을 추가해야 합니다. 
    하지만 CGLIB은 메소드가 처음 호출 됐을 때, 동적으로 타겟 클래스의 바이트 코드를 조작하고 이후 호출 시에는 조작된 바이트 코드를 재사용합니다. 
    즉, 성능면에서 Reflection을 사용하는 동적 프록시보다 좋을 수밖에 없습니다.
  </details>

<br/>

# 4. DTO, VO, DAO, ENTITY
  
  <details>
    <summary>VO, DTO 차이에 대해 설명하세요.</summary>

    - VO(Value Object): 
      - 값 객체로, 불변의 속성을 가집니다. 
      - 같은 속성 값을 가진 VO 객체는 동일한 객체로 취급합니다. 
      - 예를 들어, 좌표, 날짜, 금액 등을 VO로 사용할 수 있습니다. 
    - DTO(Data Transfer Object): 
      - 데이터 전송 객체로, 계층간 데이터 교환을 위해 사용합니다. 
      - 일반적으로 로직을 가지지 않고, 속성과 그에 접근하기 위한 getter, setter 메서드만을 가집니다.
  </details>
  <details>
    <summary>엔티티, VO 차이에 대해 설명하세요.</summary>

    - 엔티티(Entity): 
      - DB에서 영속적으로 저장되는 객체를 말합니다. 
      - 각각의 엔티티는 고유한 식별자를 가지고 있습니다. 
      - 엔티티의 속성이 변경되더라도 식별자는 변경되지 않습니다. 
    - VO(Value Object): 
      - 값 객체로, 불변의 속성을 가집니다. 
      - 같은 속성 값을 가진 VO 객체는 동일한 객체로 취급합니다. 
      - VO는 엔티티와 달리 식별자를 가지지 않습니다.
  </details>
  <details>
    <summary>DAO(Data Access Object)란 무엇인가요?</summary>

    - DAO는 데이터베이스의 데이터에 접근하기 위한 객체입니다. 
    - DAO는 데이터베이스에 대한 CRUD 연산을 캡슐화하여 제공합니다. 
    - 이를 통해 데이터 접근 로직과 비즈니스 로직을 분리하여 코드의 가독성과 유지보수성을 높일 수 있습니다. 
    - 또한, DAO를 사용하면 데이터베이스 엔진이 변경되더라도 비즈니스 로직을 변경하지 않고 DAO만 변경하면 되므로, 유연성도 높일 수 있습니다.
  </details>

# 5. 스프링 전체 동작 과정

1. 클라이언트의 요청: 
  - 사용자가 웹 브라우저를 통해 특정 URL에 요청을 보냅니다.
2. DispatcherServlet: 
  - 스프링 MVC에서 가장 먼저 요청을 받는 것은 디스패처 서블릿입니다. 
  - 이는 프론트 컨트롤러 패턴을 구현한 것으로, 모든 클라이언트의 요청을 한 곳에서 받아 적절한 컨트롤러에게 요청을 위임합니다.
3. HandlerMapping: 
  - 디스패처 서블릿은 HandlerMapping에게 어떤 컨트롤러(핸들러)에게 요청을 위임할지 물어봅니다. 
  - HandlerMapping은 요청 URL을 분석하여 해당 URL을 처리할 수 있는 가장 적합한 컨트롤러를 찾아 반환합니다.
4. 컨트롤러 실행: 
  - 디스패처 서블릿은 HandlerMapping이 반환한 컨트롤러를 실행시킵니다. 
  - 컨트롤러는 비즈니스 로직을 처리하고, 그 결과를 저장하는 모델 객체와 결과를 보여줄 뷰 이름을 반환합니다.
5. ViewResolver: 
  - 디스패처 서블릿은 컨트롤러가 반환한 뷰 이름을 ViewResolver에게 전달합니다. 
  - ViewResolver는 이 뷰 이름을 기반으로 실제로 결과를 보여줄 뷰 객체를 찾아 반환합니다.
6. 뷰 처리: 
  - 디스패처 서블릿은 ViewResolver가 반환한 뷰 객체에 모델 데이터를 전달하여 처리를 요청합니다. 
  - 뷰 객체는 모델 데이터를 사용하여 결과 페이지를 생성합니다.
7. 클라이언트에게 응답 반환: 
  - 디스패처 서블릿은 생성된 결과 페이지를 클라이언트에게 반환합니다. 
  - 이로써 클라이언트의 요청 처리가 완료됩니다.

이처럼 스프링 프레임워크는 클라이언트의 요청을 받아 처리하고 결과를 반환하는 전체 과정을 통합적으로 관리합니다. 
이를 통해 개발자는 비즈니스 로직에 집중할 수 있으며, 애플리케이션의 유지보수와 확장성도 향상시킬 수 있습니다.
