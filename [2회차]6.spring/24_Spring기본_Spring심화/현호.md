# Spring 기본
## IoC
답변 1) IoC : 제어의 역전. 일반적으로 개발자는 자신이 작성하는 프로그램의 흐름을 직접 제어합니다. 그러나 이 흐름에 대한 제어권을 프레임워크 등에 넘겨줄 때가 있는데 이런 상황을 제어의 역전이라고 표현합니다. 예를 들어 필요한 객체를 직접 생성해서 사용하는 작업은 개발자가 프로그램 흐름을 직접 제어하는 것이라고 볼 수 있습니다. 하지만 IoC 프레임워크를 통해 제공되는 객체를 받아서 사용하게 되면, 어떤 객체를 사용할지 선택할지 결정하는 책임은 프레임워크에게 넘어갔고, 자신은 수동적으로 주입받은 객체를 사용하게 되므로 IoC가 일어났다고 볼 수 있습니다. 
답변 2) 일반적으로 개발자는 자신이 작성하는 프로그램의 흐름을 직접 제어합니다. 하지만 스프링과 같은 프레임워크는 개발자가 작성한 코드를 프레임워크가 호출하는 구조를 가지고 있습니다. 이 때문에 프레임워크가 개발자의 코드를 제어하는 방향으로 제어의 방향이 바뀌었다는 의미에서 제어의 역전이라고 표현합니다.  
-> 둘 중에 어떤게 더 나은 답변일까?

## DI(의존성 주입)
DI : 의존성 주입. 사용하고 싶은 의존성을 직접 생성하는 대신에, 외부로 부터 주입받아서 사용하는 방식입니다. 스프링에서는 IoC컨테이너에 미리 빈들을 등록해두고 컨테이너로 부터 빈을 주입받아서 사용하게 되는데요. 스프링이 제공하는 IoC컨테이너와 다양한 주입 방식 덕분에 DI를 더 효율적으로 활용할 수 있게 되었습니다.  

## 다양한 DI 방법
1. 생성자 주입 : 생성자 주입은 생성자의 호출 시점에 1회 호출 되는 것이 보장된다. 그렇기 때문에 주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다. 또한 Spring 프레임워크에서는 생성자 주입을 적극 지원하고 있기 때문에, 생성자가 1개만 있을 경우에 @Autowired를 생략해도 주입이 가능하도록 편의성을 제공하고 있다.  
2. setter 주입 : setter 주입은 필드 값을 변경하는 Setter를 통해서 의존 관계를 주입하는 방법이다. Setter 주입은 생성자 주입과 다르게 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다. (그러나 런타임 중에 의존하는 객체의 변경이 필요한 경우는 극히 드물다.)
3. 필드 주입 : 필드에 바로 의존 관계를 주입하는 방법이다. 필드 주입을 이용하면 코드가 간결해져서 과거에 상당히 많이 이용되었던 주입 방법이다. 하지만 필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는 필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양해야 한다. 그렇기에 애플리케이션의 실제 코드와 무관한 테스트 코드나 설정을 위해 불가피한 경우에만 이용하도록 하자.
4. 일반 메서드 주입 : 일반 메소드를 통해 의존 관계를 주입하는 방법이다. 수정자 주입과 동일하며 마찬가지로 거의 사용할 필요가 없는 주입 방법이다. 수정자 주입을 사용하면 한 번에 여러 필드를 주입 받을 수 있도록 메소드를 작성할수도 있다.

### 생성자 주입을 사용해야 하는 이유
1. 객체 간 의존 관계가 변경될 가능성이 제거 됨.
런타임 중에 객체 간의 의존관계가 변경되어야 하는 상황은 거의 없다. 하지만 setter주입이나 메서드 주입을 사용하면 불필요하게 수정의 가능성을 열어두어 유지보수성을 떨어뜨린다. 그러므로 생성사 주입을 통해 변경의 가능성을 배제하고 객체의 불변성을 보장하는 것이 좋다.
2. 테스트 코드 작성시 DI 프레임워크에 의존하지 않을 수 있음.
테스트 작성 시 DI 프레임워크에 의존하지 않고 테스트를 작성하고 싶을 수 있다. 프레임워크를 이용할 시 빈들을 등록하고 초기화하는 시간 때문에 테스트 비용이 증가하는 단점이 있고, DI 프레임워크에 의존하는 테스트를 단위 테스트로 보기 어렵기 때문이다.
필드 주입을 사용하면 DI 프레임워크를 어쩔 수 없이 사용해야하지만, 생성자 주입을 사용하면 프레임워크를 사용하지 않아도 직접 객체를 만들어 주입해주는 방식으로 단위 테스트를 작성할 수 있다.   
3. final 키워드 사용이 가능해짐. Lombok과의 시너지
생성자 주입 외에 다른 주입 방식들은 객체의 생성 이후에 관계가 주입되므로 final 키워드를 사용할 수 없다.  
생성자 주입의 경우 fianl키워드를 사용한 필드 + Lombok 조합으로 간결한 코드를 작성할 수 있다.
4. 순환 참조 에러 방지
생성자 주입을 사용하면 애플리케이션 구동 시점에 순환 참조 에러를 예방할 수 있다. 그러한 이유는 생성자 생성자 주입은 객체의 생성과 의존관계 주입이 동시에 실행되기 때문이다. 하지만 필드 주입은 모든 객체의 생성이 완료된 후에 의존관계 주입이 시작된다. 그러다 보니 위와 같이 순환 문제가 있는 두 메서드가 호출이 되서 콜 스택이 가득차고 나서야 순환 이슈를 확인할 수 있는 것이다.   

출처: https://mangkyu.tistory.com/125 [MangKyu's Diary:티스토리]


## Bean, Component
@Bean과 @Component 모두 목적이 명확하지 않은 Bean을 생성할 때 사용하는 어노테이션입니다. 하지만 @Bean은 개발자가 컨트롤 할 수 없는 클래스를 빈으로 등록하고 싶을 때 사용하고, @Component는 개발자가 컨트롤할 수 있는 클래스를 등록하고 싶을 때 사용합니다. 좀 더 구체적으로 말씀드리자면 직접 작성한 클래스의 경우 클래스 위에 Component어노테이션을 붙여서 빈으로 등록할 수 있는데요. 라이브러리에서 import해오는 클래스의 경우 해당 라이브러리 소스코드에 직접 Component 어노테이션을 달 수는 없으니까 메서드 안에서 객체를 생성한 뒤에 메서드에 @Bean어노테이션을 붙여서 등록하는 식으로 처리합니다.

## @Component @Service @Controller @Repository
먼저 @Component 의 경우 IoC컨테이너에 객체를 등록시키기 위해 사용되는 가장 기본적인 어노테이션입니다. 이 어노테이션을 붙이면 **빈 자동 스캔**이나 **DI** 등의 적용대상이 됩니다.    
다음으로 @Controller나 @Repository 같은 어노테이션의 경우 @Component 어노테이션을 상속받은 어노테이션들 입니다. 따라서 @Component를 붙였을 때 수행되는 기능을 모두 적용받을 수 있습니다. 여기에 더해 **@Controller의 경우 이 어노테이션이 붙은 클래스에서만 @RequestMapping 어노테이션이 붙을 수 있습니다.**  **@Repository어노테이션의 경우 각 DB접근 플랫폼이 발생시키는 예외를 잡아서 Spring에서 약속된 데이터 접근 계층의 예외로 다시 던져주는 추가작업을 수행**합니다.

## Bean Scope & 생명주기
빈 생명주기는 빈의 타입에 따라 조금씩 다릅니다.

싱글톤 빈:
- 어플리케이션에 해당 클래스의 빈이 딱 하나만 생성되어 컨테이너에 등록된다. 이후 주입이 필요한 클래스에 모두 같은 참조를 가진 싱글톤 빈이 주입된다. 싱글톤 특성 상 stateless하게 구성하는게 좋다는 특징을 가지고 있다.
- **싱글톤 빈의 생명주기는 IoC컨테이너의 생명주기와 거의 비슷하다. 컨테이너가 생성될 때 등록되서, 스프링이 종료되면서 컨테이너가 내려갈 때까지 계속 컨테이너에서 관리된다.**  

프로토타입 빈:
- 싱글톤과 달리 프로토타입 빈은 클라이언트들이 빈을 요구할 때마다 컨테이너에서 빈을 생성하고 의존성을 주입해주게 됩니다.
- **생명주기도 싱글톤 빈과는 조금 다른데 컨테이너에서 의존성 주입을 해주고 난 뒤 부터는 컨테이너가 프로토타입 빈을 관리하지 않기 때문에 각 빈의 생명주기가 제각각이게 됩니다.**

## IoC Container
IoC 컨테이너는 스프링 어플리케이션이 실행될 때 함께 생성되어서 빈을 등록하고, 의존성을 주입하는 등 스프링에서 빈을 관리하는 역할을 수행합니다.    
IoC 컨테이너를 구현하는 클래스에는 대표적으로 Bean Factory와 Application context 두 가지 클래스가 있습니다.

### Application context VS Bean Factory
Application context는 Bean Factory를 상속받은 클래스이기 때문에 기존 기능을 모두 가지면서도 몇 가지 기능이 추가된 클래스입니다. 추가된 기능 중에 대표적인 기능이 바로 @Profile어노테이션인데요. 빈을 등록할 때 특정 프로파일에서만 이 빈이 주입되도록 설정해주는 어노테이션입니다. 예를 들어서 운영환경과 개발환경의 DB가 다르고 빈 설정을 통해서 이를 변경한다고 할 때, 실행될 환경에 맞게 빈이 등록되고 주입되도록 설정해줄 수 있습니다.  

## VO vs DTO vs DAO
DTO : 레이어 간 데이터 전달용
- DTO는 레이어 간 데이터를 전달하기 위해 자주 사용됩니다. getter, setter외에 비즈니스 로직을 가지지 않고 오롯이 데이터 전달만을 위해서 사용되는 것이 특징입니다.

VO : 값 표현
- VO는 값을 표현하기 위해 사용되는 불변 객체입니다. 객체의 참조 값이 달라도, 객체가 가지고 있는 상태가 서로 같으면 같은 객체로 취급한다는 특징이 있습니다. 불변성이 보장되면 좋고, 내부에 비즈니스 로직을 포함하는 값 객체가 필요할 때 VO를 자주 활용합니다.
