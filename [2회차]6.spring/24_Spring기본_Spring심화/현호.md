# Spring 기본
## IoC
답변 1) IoC : 제어의 역전. 일반적으로 개발자는 자신이 작성하는 프로그램의 흐름을 직접 제어합니다. 그러나 이 흐름에 대한 제어권을 프레임워크 등에 넘겨줄 때가 있는데 이런 상황을 제어의 역전이라고 표현합니다. 예를 들어 필요한 객체를 직접 생성해서 사용하는 작업은 개발자가 프로그램 흐름을 직접 제어하는 것이라고 볼 수 있습니다. 하지만 IoC 프레임워크를 통해 제공되는 객체를 받아서 사용하게 되면, 어떤 객체를 사용할지 선택할지 결정하는 책임은 프레임워크에게 넘어갔고, 자신은 수동적으로 주입받은 객체를 사용하게 되므로 IoC가 일어났다고 볼 수 있습니다. 
답변 2) 일반적으로 개발자는 자신이 작성하는 프로그램의 흐름을 직접 제어합니다. 하지만 스프링과 같은 프레임워크는 개발자가 작성한 코드를 프레임워크가 호출하는 구조를 가지고 있습니다. 이 때문에 프레임워크가 개발자의 코드를 제어하는 방향으로 제어의 방향이 바뀌었다는 의미에서 제어의 역전이라고 표현합니다.  
-> 둘 중에 어떤게 더 나은 답변일까?

## DI(의존성 주입)
DI : 의존성 주입. 사용하고 싶은 의존성을 직접 생성하는 대신에, 외부로 부터 주입받아서 사용하는 방식입니다. 스프링에서는 IoC컨테이너에 미리 빈들을 등록해두고 컨테이너로 부터 빈을 주입받아서 사용하게 되는데요. 스프링이 제공하는 IoC컨테이너와 다양한 주입 방식 덕분에 DI를 더 효율적으로 활용할 수 있게 되었습니다.  

## 다양한 DI 방법
1. 생성자 주입 : 생성자 주입은 생성자의 호출 시점에 1회 호출 되는 것이 보장된다. 그렇기 때문에 주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용할 수 있다. 또한 Spring 프레임워크에서는 생성자 주입을 적극 지원하고 있기 때문에, 생성자가 1개만 있을 경우에 @Autowired를 생략해도 주입이 가능하도록 편의성을 제공하고 있다.  
2. setter 주입 : setter 주입은 필드 값을 변경하는 Setter를 통해서 의존 관계를 주입하는 방법이다. Setter 주입은 생성자 주입과 다르게 주입받는 객체가 변경될 가능성이 있는 경우에 사용한다. (그러나 런타임 중에 의존하는 객체의 변경이 필요한 경우는 극히 드물다.)
3. 필드 주입 : 필드에 바로 의존 관계를 주입하는 방법이다. 필드 주입을 이용하면 코드가 간결해져서 과거에 상당히 많이 이용되었던 주입 방법이다. 하지만 필드 주입은 외부에서 접근이 불가능하다는 단점이 존재하는데, 테스트 코드의 중요성이 부각됨에 따라 필드의 객체를 수정할 수 없는 필드 주입은 거의 사용되지 않게 되었다. 또한 필드 주입은 반드시 DI 프레임워크가 존재해야 하므로 반드시 사용을 지양해야 한다. 그렇기에 애플리케이션의 실제 코드와 무관한 테스트 코드나 설정을 위해 불가피한 경우에만 이용하도록 하자.
4. 일반 메서드 주입 : 일반 메소드를 통해 의존 관계를 주입하는 방법이다. 수정자 주입과 동일하며 마찬가지로 거의 사용할 필요가 없는 주입 방법이다. 수정자 주입을 사용하면 한 번에 여러 필드를 주입 받을 수 있도록 메소드를 작성할수도 있다.

### 생성자 주입을 사용해야 하는 이유
1. 객체 간 의존 관계가 변경될 가능성이 제거 됨.
런타임 중에 객체 간의 의존관계가 변경되어야 하는 상황은 거의 없다. 하지만 setter주입이나 메서드 주입을 사용하면 불필요하게 수정의 가능성을 열어두어 유지보수성을 떨어뜨린다. 그러므로 생성사 주입을 통해 변경의 가능성을 배제하고 객체의 불변성을 보장하는 것이 좋다.
2. 테스트 코드 작성시 DI 프레임워크에 의존하지 않을 수 있음.
테스트 작성 시 DI 프레임워크에 의존하지 않고 테스트를 작성하고 싶을 수 있다. 프레임워크를 이용할 시 빈들을 등록하고 초기화하는 시간 때문에 테스트 비용이 증가하는 단점이 있고, DI 프레임워크에 의존하는 테스트를 단위 테스트로 보기 어렵기 때문이다.
필드 주입을 사용하면 DI 프레임워크를 어쩔 수 없이 사용해야하지만, 생성자 주입을 사용하면 프레임워크를 사용하지 않아도 직접 객체를 만들어 주입해주는 방식으로 단위 테스트를 작성할 수 있다.   
3. final 키워드 사용이 가능해짐. Lombok과의 시너지
생성자 주입 외에 다른 주입 방식들은 객체의 생성 이후에 관계가 주입되므로 final 키워드를 사용할 수 없다.  
생성자 주입의 경우 fianl키워드를 사용한 필드 + Lombok 조합으로 간결한 코드를 작성할 수 있다.
4. 순환 참조 에러 방지
생성자 주입을 사용하면 애플리케이션 구동 시점에 순환 참조 에러를 예방할 수 있다. 그러한 이유는 생성자 생성자 주입은 객체의 생성과 의존관계 주입이 동시에 실행되기 때문이다. 하지만 필드 주입은 모든 객체의 생성이 완료된 후에 의존관계 주입이 시작된다. 그러다 보니 위와 같이 순환 문제가 있는 두 메서드가 호출이 되서 콜 스택이 가득차고 나서야 순환 이슈를 확인할 수 있는 것이다.   

출처: https://mangkyu.tistory.com/125 [MangKyu's Diary:티스토리]


## Bean, Component
@Bean과 @Component 모두 목적이 명확하지 않은 Bean을 생성할 때 사용하는 어노테이션입니다. 하지만 @Bean은 개발자가 컨트롤 할 수 없는 클래스를 빈으로 등록하고 싶을 때 사용하고, @Component는 개발자가 컨트롤할 수 있는 클래스를 등록하고 싶을 때 사용합니다. 좀 더 구체적으로 말씀드리자면 직접 작성한 클래스의 경우 클래스 위에 Component어노테이션을 붙여서 빈으로 등록할 수 있는데요. 라이브러리에서 import해오는 클래스의 경우 해당 라이브러리 소스코드에 직접 Component 어노테이션을 달 수는 없으니까 메서드 안에서 객체를 생성한 뒤에 메서드에 @Bean어노테이션을 붙여서 등록하는 식으로 처리합니다.

## @Component @Service @Controller @Repository
먼저 @Component 의 경우 IoC컨테이너에 객체를 등록시키기 위해 사용되는 가장 기본적인 어노테이션입니다. 이 어노테이션을 붙이면 **빈 자동 스캔**이나 **DI** 등의 적용대상이 됩니다.    
다음으로 @Controller나 @Repository 같은 어노테이션의 경우 @Component 어노테이션을 상속받은 어노테이션들 입니다. 따라서 @Component를 붙였을 때 수행되는 기능을 모두 적용받을 수 있습니다. 여기에 더해 **@Controller의 경우 이 어노테이션이 붙은 클래스에서만 @RequestMapping 어노테이션이 붙을 수 있습니다.**  **@Repository어노테이션의 경우 각 DB접근 플랫폼이 발생시키는 예외를 잡아서 Spring에서 약속된 데이터 접근 계층의 예외로 다시 던져주는 추가작업을 수행**합니다.

## Bean Scope & 생명주기
빈 생명주기는 빈의 타입에 따라 조금씩 다릅니다.

싱글톤 빈:
- 어플리케이션에 해당 클래스의 빈이 딱 하나만 생성되어 컨테이너에 등록된다. 이후 주입이 필요한 클래스에 모두 같은 참조를 가진 싱글톤 빈이 주입된다. 싱글톤 특성 상 stateless하게 구성하는게 좋다는 특징을 가지고 있다.
- **싱글톤 빈의 생명주기는 IoC컨테이너의 생명주기와 거의 비슷하다. 컨테이너가 생성될 때 등록되서, 스프링이 종료되면서 컨테이너가 내려갈 때까지 계속 컨테이너에서 관리된다.**  

프로토타입 빈:
- 싱글톤과 달리 프로토타입 빈은 클라이언트들이 빈을 요구할 때마다 컨테이너에서 빈을 생성하고 의존성을 주입해주게 됩니다.
- **생명주기도 싱글톤 빈과는 조금 다른데 컨테이너에서 의존성 주입을 해주고 난 뒤 부터는 컨테이너가 프로토타입 빈을 관리하지 않기 때문에 각 빈의 생명주기가 제각각이게 됩니다.**

## IoC Container
IoC 컨테이너는 스프링 어플리케이션이 실행될 때 함께 생성되어서 빈을 등록하고, 의존성을 주입하는 등 스프링에서 빈을 관리하는 역할을 수행합니다.    
IoC 컨테이너를 구현하는 클래스에는 대표적으로 Bean Factory와 Application context 두 가지 클래스가 있습니다.

### Application context VS Bean Factory
Application context는 Bean Factory를 상속받은 클래스이기 때문에 기존 기능을 모두 가지면서도 몇 가지 기능이 추가된 클래스입니다. 추가된 기능 중에 대표적인 기능이 바로 @Profile어노테이션인데요. 빈을 등록할 때 특정 프로파일에서만 이 빈이 주입되도록 설정해주는 어노테이션입니다. 예를 들어서 운영환경과 개발환경의 DB가 다르고 빈 설정을 통해서 이를 변경한다고 할 때, 실행될 환경에 맞게 빈이 등록되고 주입되도록 설정해줄 수 있습니다.  

## VO vs DTO vs DAO
DTO : 레이어 간 데이터 전달용
- DTO는 레이어 간 데이터를 전달하기 위해 자주 사용됩니다. getter, setter외에 비즈니스 로직을 가지지 않고 오롯이 데이터 전달만을 위해서 사용되는 것이 특징입니다.

VO : 값 표현
- VO는 값을 표현하기 위해 사용되는 불변 객체입니다. 객체의 참조 값이 달라도, 객체가 가지고 있는 상태가 서로 같으면 같은 객체로 취급한다는 특징이 있습니다. 불변성이 보장되면 좋고, 내부에 비즈니스 로직을 포함하는 값 객체가 필요할 때 VO를 자주 활용합니다.

# Spring 심화
## 동적 프록시
- 프록시 패턴은 로깅, 접근 제어, 트랜젝션 등 대상 객체에 대한 수정 없이 추가 동작을 가미하고 싶을 때 사용하는 코드 패턴이다. 이 패턴을 적용하면 개방 패쇄 원칙(OCP)의 효과를 얻을 수 있어 코드 수정없이 유연하게 확장이 가능하여 유지보수 측면에서 좋은 효과를 얻을 수 있다는 장점이 있다.
- 하지만 프록시 패턴은 프록시를 적용하고 싶은 원본 클래스 수만큼 프록시 클래스를 만들어줘야한다는 단점이 존재한다. 이를 해결하기 위해 프록시 객체를 컴파일 시점이 아닌 런타임 시점에 동적으로 만들어주는 기술이 바로 동적 프록시 기술이다.
## JDK Dynamic Proxy && CGLIB
- JDK Dynamic Proxy: 인터페이스 기반으로 바이트 코드를 조작
- CGLIB: 클래스 기반으로 바이트 코드를 조작
빈이 등록될 때 AOP적용 대상이 되는 빈들에 대한 동적 프록시 객체가 만들어지는데 이 떄, 해당 객체가 Interface를 하나라도 구현하고 있으면 JDK Bynamic Proxy를, Interface를 구현하고 있지 않으면 CGLIB을 이용한다.

## AOP
### 개념
- Aspect Oriented Programming의 약자로, '관점 지향 프로그래밍'을 의미한다.
- AOP는 핵심적인 비즈니스 로직으로부터 '횡단 관심사'를 분리하는 것에 목적을 둔다. 즉, 부가기능을 따로 관리하는 것을 의미한다.
### 장점
- 프로젝트 곳곳으로 흩어질 수 있는 관심 사항이 하나의 장소로 응집한다. 그에 따라, 비즈니스 로직이 부가기능에 대한 코드를 포함하지 않아 코드가 간결해진다.
- 즉, 객체지향적으로 코드를 짤 수 있게 도우며 유지보수가 용이해진다.
### AOP 용어
Target : 부가기능을 적용할 대상 객체 (ex. XXService)
Advice : 부가기능이 작성되는 클래스. 어느 시점에 부가기능을 주입해 줄 것인지에 대한 정보도 포함되어있다.
Join Point : Advice가 적용될 수 있는 위치(스프링 AOP에서는 메서드 실행 단계를 의미)
Point Cut : Advice를 적용할 Join Point들을 선택하는 작업(스프링 AOP에서는 메서드가 Pointcut의 대상)
Advisor: Advice와 Point Cut을 하나씩 가지고 있는 오브젝트(결과적으로 어떤 기능을, 어느 시점에, 어디에 주입해줄 것인지가 모두 기술되어있음)
Weaving : 조인 포인트에 어드바이스를 적용하는 방법.(스프링 AOP에서는 Runtime Weaving이라는 것을 사용해서 런타임 중에 Advice를 적용해준다)

### 스프링 AOP의 빈 등록 과정
- 어플리케이션이 실행되면서 IoC컨테이너에 빈이 등록될 때 AOP가 적용됩니다.
- 컨테이너가 Bean 객체를 생성한 뒤에 최종적으로 컨테이너에 등록하기 전 '빈 후처리기'라는 것을 통해서 이 Bean 객체에 적용해야할 AOP가 있는지 조사합니다.(좀 더 구체적으로는 Point Cut 정보를 가지고 있는 Advisor 리스트를 모두 순회해서 현재 등록 중인 Bean에 적용해야할 AOP가 있는지 찾게 됩니다).
- 적용되어야할 AOP기능이 존재하면 동적으로 프록시 객체를 생성해서 Bean 객체에 부가기능을 부여 해줍니다. 그 뒤에 프록시 객체를 빈으로 등록하면 빈의 메서드가 호출될 때 마다 부가기능과 본래 비즈니스 로직이 함께 수행됩니다.

## 인터셉터
### 필터와 인터셉터의 차이
- 가장 큰 차이점으로는, 필터는 웹 컨테이너 영역에 속해있는 자바 표준 스펙이고, 인터셉터는 스프링의 스펙이라는 차이점이 있습니다. 이런 차이점로 인해서 문제를 겪은 적이 있는데요. 필터와 인터셉터를 활용해서 인증/인가 기능을 개발하는 상황이었습니다. 이 때 필터에서 발생하는 예외는 컨트롤러 어드바이스가 잡아주지 못하고, 인터셉터에서 발생하는 예외만 컨트롤러 어드바이스가 처리해주는 문제가 있었습니다. 이게 컨트롤러 어드바이스는 디스패처 서블릿에서 동작하는데 필터는 디스패처 서블릿의 앞 단에 위치해있기 때문에 예외가 발생되어도 디스패처 서블릿에 예외가 가지 못하고, 그렇기에 컨트롤러 어드바이스도 예외를 처리하지 못하는 문제를 겪은 적이 있습니다. 이렇게 두 기술이 서로 다른 스펙에 속해있고, 동작의 시점이 다르다는 점이 가장 큰 차이점이라고 생각합니다.  


<details>
<summary> 1. IoC에 대해 설명해주세요.</summary>
<div>
IoC, 즉 제어의 역전은 일반적으로 개발자가 작성하는 프로그램의 흐름을 직접 제어하는 것을 프레임워크 등에 넘겨주는 개념입니다.
예를 들어, 필요한 객체를 직접 생성해서 사용하는 경우, 개발자가 프로그램 흐름을 직접 제어하는 것이라고 볼 수 있습니다. 
그러나 IoC 프레임워크를 통해 제공되는 객체를 받아 사용하게 되면, 어떤 객체를 사용할지 결정하는 책임은 프레임워크에게 넘어갔고, 개발자는 수동적으로 주입받은 객체를 사용하게 되므로 IoC가 일어났다고 볼 수 있습니다.
</div>
</details>

<details>
<summary> 2. 다양한 DI 방법과 그 차이점에 대해 설명해주세요.</summary>
<div>
DI 방법은 크게 생성자 주입, setter 주입, 필드 주입, 일반 메서드 주입이 있습니다. 생성자 주입은 생성자 호출 시점에 1회 호출되며, 주입받은 객체가 변하지 않거나 반드시 객체의 주입이 필요한 경우에 사용합니다. 
setter 주입은 필드 값을 변경하는 setter를 통해 의존 관계를 주입하며, 주입받는 객체가 변경될 가능성이 있는 경우에 사용합니다.
필드 주입은 필드에 바로 의존 관계를 주입하는 방법으로, 코드가 간결해지는 장점이 있지만 외부에서 접근이 불가능한 단점이 있습니다. 
일반 메서드 주입은 일반 메소드를 통해 의존 관계를 주입하는 방법으로, 여러 필드를 한 번에 주입 받을 수 있도록 메서드를 작성할 수 있습니다.
</div>
</details>


<details>
<summary> 3. 스프링 빈의 생명주기에 대해 설명해주세요.</summary>
<div>
스프링 빈의 생명주기는 빈의 타입에 따라 달라집니다. 
싱글톤 빈의 경우, 어플리케이션에서 해당 클래스의 빈이 하나만 생성되어 컨테이너에 등록되며, 스프링이 종료되면서 컨테이너가 내려갈 때까지 계속 관리됩니다. 
반면, 프로토타입 빈의 경우, 클라이언트가 빈을 요구할 때마다 컨테이너에서 새로운 빈을 생성하고 의존성을 주입합니다. 이후 빈의 생명주기는 컨테이너가 아닌 클라이언트에 의해 관리됩니다.
</div>
</details>

<details>
<summary> 4. @Bean과 @Component의 차이점은 무엇인가요?</summary>
<div>
@Bean과 @Component는 모두 빈을 생성할 때 사용하는 어노테이션입니다.
그러나 @Bean은 개발자가 컨트롤 할 수 없는 클래스를 빈으로 등록하고 싶을 때 사용하고, @Component는 개발자가 컨트롤할 수 있는 클래스를 등록하고 싶을 때 사용합니다.
즉, @Component는 직접 작성한 클래스에 사용하고, @Bean은 라이브러리에서 가져온 클래스에 사용하여 메서드 안에서 객체를 생성하고 빈으로 등록합니다.
</div>
</details>


