# 1. JPA
 ## 1.1 JDBC, Spring JDBC 
 ### 1.1.1 JDBC (Java DataBase Connectivity)
 - 자바와 데이터베이스를 연결하기 위한 Java 표준 인터페이스
 - MySQL, PostgreSQL, SQL Server 등의 다양한 DB 미들웨어의 드라이버를 제공하고, Java 표준이기 때문에 JVM 위에서 운영되는 애플리케이션 어디에서든지 사용 가능
  
 #### 동작 원리
 1. 사용할 Database Driver 선택
 2. 커넥션을 생성
 3. 처리해야 할 질의를 executeSQL에 넣어준 후, ResultSet으로 받기

 #### 단점
 - 커넥션 종료시 Statement, Connection, ResultSet에 모두 close()함수로 종료처리해야 메모리에 누수가 생기지 않고 안전하게 종료할 수 있음
 - 여러가지 종류의 클래스와 함수를 사용하기 때문에 코드의 가독성이 떨어짐

 ### 1.1.2 Spring JDBC
 - 스프링에서 DB를 사용하기 위한 오리지널 의존성
 - MyBatis 처럼 XML이나 자바 코드를 이용해서 의존성 주입을 한 후 사용하는 방식 (DataSource)
 - JdbcTemplate이나, NamedParameterJdbcTemplate 같은 것을 의미
 
 #### Spring JDBC가 제공해주는 역할
 - Connection 열고 닫기
 - Statement를 준비하고 닫기
 - Statement의 실행
 - ResultSet 반복 처리
 - 예외 처리 반환
 - Transcation 처리
 
 #### 장점
 - 여러 클래스 코드를 작성하지 않고 간결하게 작성할 수 있는 장점이 있음
   - 예를 들어, ResultSet으로 받은 데이터를 직접 모두 돌면서 객체에 생성자로 넣어줘야했는데 좀 더 편하게 작성할 수 있음
 - 템플릿 패턴을 이용해서 JDBC를 사용할 때 발생하는 반복 작업을 대신 처리 해줌

#### 단점
- 동적 SQL을 처리하기 어려움
 - IF문이나 switch case로 코드가 굉장히 길어지고 지저분해질 수 있음

 ## 1.2 Sql Mapper(MyBatis), ORM
 ### 1.2.1 SQL Mapper
 - 객체와 SQL의 필드를 매핑하여 데이터를 객체화 하는 기술
 - 객체와 테이블 간의 관계를 매핑하는 것이 아니라, SQL문을 직접 작성하고 쿼리 수행결과를 어떠한 객체에 매핑
 - JDBCTemplate이나 MyBatis를 의미
 
 #### MyBatis
 - SQL을 xml파일로 분리하여 관리하고, SQL 결과와 객체 인스턴스의 매핑을 도와주는 역할을 수행
 - 동적쿼리를 지원하여 다이나믹하게 변경되는 쿼리 작성 가능
 - 단점
   - SQL을 개발자가 직접 작성하는 문제
   - DBMS에 종속적임
   - 비슷한 쿼리를 반복적으로 작성해야하는 문제
   - 객체와 관계형 테이블 구조간 패러다임 불일치 발생

 #### 패러다임 불일치
 - 상속
   - 객체는 상속이 있지만, 테이블에는 존재하지 않음
 - 연관관계
   - 객체는 참조, 테이블은 외래 키
 - 객체 그래프 탐색
   - 객체는 마음껏 객체 그래프로 탐색이 가능
 - 비교
   - 객체는 동일성 비교와 동등성 비교가 존재
   - 데이터베이스는 기본 키 값으로만 비교

 ### 1.2.2 ORM
 - 객체와 DB 테이블을 매핑하여 데이터를 객체화하는 기술
 - CURD 관련 메서드를 사용하면 자동으로 SQL이 만들어져 개발자가 반복적인 SQL을 직접 작성하지 않아도 됩니다.
 - Java ORM 표준을 JPA라고 합니다.

 #### 특징
 - DBMS에 의존하지 않음으로써 도메인과 비지니스 로직 설계에 더 집중할 수 있음
 - 요구사항 변화에 빠른 대처가 가능한 장점
 - 통계성 쿼리보다는 실시간 처리용 쿼리에 적합
 
 ## 1.3 @Transactional
 - 선언적 데이터베이스 트랜잭션 관리 방법을 제공
 - 메서드 또는 클래스 레벨에서 사용 가능
 - Spring AOP로 동작
 - JDBC로 처리하려면 굉장히 

 ### 1.3.1 동작 방식
 - 메서드를 실행할 때 스프링은 트랜잭션을 시작
 - 메서드가 정상적으로 종료되면 commit, 예외가 발생하면 rollback 처리
 - 비정상적 종료로 인한 rollback이 발생하는 경우 트랜잭션의 일부 작업만 데이터베이스에 반영 되는 것을 방지하여 데이터 일관성을 유지
 - JDBC를 이용할 때 사용되는 코드를 엄청나게 단축 시켜줌

### 1.3.2 고려 사항
- public 메서드로 선언되어야 함
  - 프록시 객체로 외부에서 접근 가능한 인터페이스를 제공해야 함
- 다른 AOP 기능들과의 충돌을 고려해야 함
- Exception을 고려해야 함
  - Checked Exception은 롤백이 되지 않음

### 1.3.3 @Transactional(readOnly=true)
- JPA의 세션 플러시 모드를 MANUAL로 설정
  - 수동으로 flush로 호출하지 않으면 flush가 자동으로 되지 않음
  - 조회용으로 가져온 Entity의 예상치 못한 수정 방지
- 조회용임을 인식하여 변경 감지를 위한 Snapshot을 따로 보관하지 않아 메모리상 절약되는 성능상 이점
- OSIV가 꺼져있을 때 트랜잭션의 범위를 벗어나는 순간 Entity는 준영속 상태가 되는데 이때, Lazy Loading이 불가능
  - 결국 OSIV를 false로하고 @Transactional 어노테이션을 제거했을 때, LazyLoadingException이 발생
  - OSIV가 기본적으로는 true이지만 OSIV가 true인 경우 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지해서 커넥션 부족으로 이어질 수 있음
 
 ## 1.4 JPA, Hibernate
 ### 1.4.1 JPA
 - Java ORM 기술에 대한 API 표준 명세를 의미
 - ORM을 사용하기 위한 인터페이스를 모아둔 것
 - 자바 어플리케이션에서 관계형 데이터베이스를 어떻게 사용해야 하는지를 정의
 - 단순 명세여서 구현이 없음

 ### 1.4.2 Hibernate
 - JPA를 구현한 ORM 프레임워크
 - SQL을 사용하지 않고 직관적인 메서드를 이용하여 데이터를 조작할 수 있음
 - SQL을 사용하지 않는다해서 JDBC를 사용하지 않는 것이 아니고 근간이 됨

 ### 1.4.3 Spring Data JPA
 - Spring에서 제공하는 모듈 중 하나로, 개발자가 JPA를 더 쉽고 편하게 사용할 수 있도록 도와줌
 - JPA를 한 단계 추상화 시킨 Repository라는 인터페이스를 제공
  

  #### 장점
- SQL을 직접 사용하지 않고, 메서드 호출만으로 쿼리가 실행되어 생산성이 높음
- 쿼리에 집중하기 보다 비즈니스 로직에 집중할 수 있음
- 추상화된 데이터 접근 계층을 이용하여 DB에 종속적이지 않음

#### 단점
- 배울 것이 많음
- 메서드 호출로 쿼리를 실행한다는 것은 내부 로직이 많다는 것인데 SQL을 호출하는것보다 성능이 떨어질 수 있음
- 세밀함이 떨어짐
  - 제대로 공부하지 않으면 의도치 않게 동작할 수 있음

 ## 1.5 영속성 컨텍스트
 - 서버와 데이터베이스 사이에 엔티티를 저장하는 논리적인 영역
 - 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
 - 엔티티 매니저를 생성할 때 하나 만들어짐
 
 ### 1.5.1 영속성 컨텍스트가 엔티티를 관리하면 얻게되는 이점
 - 1차 캐시
 - 동일성 보장
   - 같은 객체를 반환하게 되면 새로운 객체가 아니라 동일한 객체가 반환
 - 트랜잭션으로 인한 쓰기 지연
   - 트랜잭션이 끝나야 commit 되어 끝날 때 쓰기가 됨
 - 지연 로딩

 ## 1.6 즉시/지연 로딩
 ### 1.6.1 지연 로딩
 - 실제 객체가 사용되는 시점에 쿼리가 나가는 방식
 - 예를 들어, getTeam()으로 팀을 불러올 때는 프록시 객체가 사용되나 Team안에 있는 특정 메서드를 수행할 때 실제 객체의 메서드로 접근하여 쿼리를 실행하게 됨

 ### 1.6.2 즉시 로딩
 - 조회시에 join을 이용하여 한방 쿼리로 전부 다 조회 해옴
 - 실행하여 받아오는 객체는 프록시 객체가 아닌 실제 객체로 조회 해옴

 ### 프록시와 즉시 로딩 주의할 점
 - 실무에서는 가급적이면 지연 로딩만 사용함
   - 즉시 로딩을 적용할 경우 예상하지 못한 SQL 예를 들어, 조인이 너무 많이 일어나는 경우가 생김
   - 즉시 로딩은 JPQL에서 N+1문제를 발생시킴
  
 가급적이면 즉시 로딩은 연관관계로 맺어진 두개의 생명주기가 같아서 같이 사용될 때 사용하면 좋음

 ## 1.7 프록시
- 초기화 지연, 접근 제어, 로깅, 캐싱 등, 기존 대상 원본 객체를 수정 없이 추가 동작 기능들을 가미하고 싶을 때 사용하는 코드 패턴
- 개방 폐쇄 원칙의 효과를 얻을 수 있어 코드 수정 없이 유연하게 확장 가능
- 하지만 프록시 패턴은 원본 클래스 수 만큼 프록시 클래스를 일일이 하나씩 만들어야하는 단점이 있음
- JPA에서의 프록시
  - em.getReference()를 이용하여 실제로 필요한 시점에 쿼리가 날아가도록 함
    - em.getReference()를 요청하는 경우 원본 엔티티를 상속받은 프록시 객체가 생성되고 타겟으로 해당 원본 객체에 대한 참조를 하고 있음
    - 실제로 데이터를 불러오는 메서드를 요청시 target으로 접근하여 데이터를 조회하는 쿼리가 날아감
    - 최초 지연 로딩 시점에는 참조 값이 없어 실제 객체의 메서드를 호출할 때 DB에서 조회하여 참조 값을 채우게 됨. -> 프록시의 초기화라 부름



# 면접 예상 질문
<details>
<summary>1. 현업에서는 JPA를 많이 사용하기도하지만 JdbcTemplate을 많이 사용하기도 합니다. 그 이유는 무엇인 것 같나요?</summary>
<div>
기본적으로 JPA는 Entity를 기준으로 데이터를 불러오고 저장하기 때문에, 조회한 값을 바로 DTO로 만들어주는 역할은 JdbcTemplate이 더 편하기 때문입니다. 예를 들어, 여러 개의 데이터를 조인해서 하나의 데이터로 넘겨주어야하는 상황이 발생할 때를 이야기합니다.

<div>
</details>

<details>
<summary>2. 객체와 테이블 간의 패러다임 불일치에 대해서 설명해주세요.</summary>
<div>
말씀하시는 객체와 테이블 간의 패러다임 불일치는 객체와 테이블 간의 이론적인 틀이나 체계가 다른 것을 의미하며 4가지 정도가 있습니다.

첫번째로 상속이며 객체는 상속이 있지만, 테이블에서는 상속 구조를 표현할 수 없습니다. 두번째로는 연관 관계입니다. 테이블은 외래키로 표현하지만 객체는 참조로 표현하게됩니다. 세번째는 객체 그래프 탐색으로 
객체는 그래프로 계속 탐색이 가능해야하는데 테이블은 불가합니다. 마지막으로는 비교입니다. 데이터베이스에서는 Row의 ID값을 기준으로 조회하는데 객체는 동등성과 동일성 비교가 있습니다.

동일성은 동일하다는 뜻으로 두 개의 객체가 완전히 같은 경우를 의미하며, 주소 값이 같은 경우 두 변수가 같은 객체를 가르키게 됩니다. 동등성은 값이 동등하다는 뜻으로 두 개의 객체가 같은 정보를 갖고 있는 경우를 의미합니다. 객체의 주소가 서로 달라도 내용만 같으면 두 변수는 동등하다고 보는 것을 말합니다.
<div>
</details>

<details>
<summary>3. @Transactional(readOnly=true)가 무엇인지 설명해주세요.</summary>
<div>
조회용 메서드에 붙이는 것으로 영속성 컨텍스트에 snapshot을 찍지 않고, flush를 수동으로 바꿔 의도치 않은 수정이 일어나지 않게 하는 장점이 있어서 사용합니다. 메모리의 성능을 높여주는 장점이 있습니다.

근데 만약 조회용이라고해서 @Transactional을 붙이지 않을 경우 OSIV가 꺼져있을 때 Lazyloading이 불가능하여 문제가 생길 수도 있습니다.
<div>
</details>

<details>
<summary>4. JPQL을 사용하게 되면 기존 영속성 컨텍스트의 데이터는 갱신되나요?</summary>
<div>
JPQL은 데이터베이스에서 직접 데이터를 가져오기 때문에 동기화를 위해 JQL 쿼리가 실행 전에 flush 됩니다. 

<div>
</details>

<details>
<summary>5. 즉시 로딩과 지연로딩에 대해서 설명해주세요.</summary>
<div>
지연 로딩은 연관 관계로 맺어진 실제 객체에 접근할 때 쿼리가 나가는 방식이고, 즉시 로딩은 Join으로 묶어 한 번에 연관 관계가 맺어진 객체들도 함께 조회하는 방식입니다. 보통 의도치 않은 쿼리가 나갈 수 있기 때문에 즉시로딩 보다는 지연로딩을 사용하며 즉시로딩 사용시 N+1과 같은 문제가 생길 수 있기 때문에 지연로딩을 이용한 fetch join과 배치 사이즈 조절로 해결할 수 있습니다.

<div>
</details>

<details>
<summary>6. JPA에서 사용되는 프록시가 어떻게 사용되고 작동되는지 아는대로 설명해주세요.</summary>
<div>
우선 JPA에서 프록시는 지연 로딩을 구현하기 위해 사용됩니다. 지연 로딩을 사용하는 연관관계의 엔티티 필드에 프록시 객체를 주입하여 실제 객체가 있는 것 처럼 동작하도록 합니다. 이 프록시는 사실 실제 객체를 상속한 타입을 가지고 있으며 final을 붙일 수 없고 기본 생성자는 최소 protected를 가져야합니다.

<div>
</details>

<details>
<summary>7. JPA에서 ID를 조회할 때는 프록시가 초기화 될까요 안될까요?</summary>
<div>
ID는 그대로 출력하고 select 쿼리는 발생하지 않습니다. 식별자를 조회할 때는 프록시를 초기화하지 않습니다. 엔티티의 식별자를 조회하는 메서드를 호출하게되면 프록시 객체 내부의 인터셉터 클래스의 로직에 의해 ID값을 반환하게 됩니다.

<div>
</details>

# 참고
## JDBC, Spring JDBC
https://blog.neonkid.xyz/223
https://www.baeldung.com/spring-jdbc-jdbctemplate

## SQL Mapper, ORM
https://deveun.tistory.com/entry/SQL-Mapper%EC%99%80-ORM-%EC%B0%A8%EC%9D%B4
https://wisdom-cs.tistory.com/6
https://ultrakain.gitbooks.io/jpa/content/chapter1/chapter1.2.html


### @Transactional
https://medium.com/gdgsongdo/transactional-%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%95%8C%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-7b0105eb5ed6
https://hungseong.tistory.com/74

### JPA, Hibernate, Spring Data JPA
https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/

### 영속성 컨텍스트
https://incheol-jung.gitbook.io/docs/q-and-a/spring/persistence-context
https://ittrue.tistory.com/254


### 지연로딩/즉시로딩
https://ict-nroo.tistory.com/132

### 프록시
https://tecoble.techcourse.co.kr/post/2022-10-17-jpa-hibernate-proxy/