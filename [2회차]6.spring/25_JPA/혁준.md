# JDBC, MyBayis(SQL Mapper), JPA(ORM), Hibernate

## JDBC(Java Database Connectivity)란 무엇인가요?

- 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API입니다.
- 이를 통해 자바 프로그램은 SQL을 사용해 데이터베이스와 상호작용할 수 있습니다.
- JDBC는 각종 SQL 명령을 수행하고, 그 결과를 받아 처리하는 기능을 제공합니다.

  <details>
    <summary>JDBC의 이점에 대해 설명해주세요.</summary>

    JDBC는 JDBC 표준 인터페이스를 이용해 각 데이터베이스에 맞도록 JDBC 드라이버를 구현하여,
    데이터베이스와 커넥션 연결, SQL 전달 및 결과 응답 기능들을 제공합니다.
  </details>
  <details>
    <summary>Spring JDBC에 대해 설명해주세요.</summary>

    Spring JDBC는 스프링 프레임워크에서 제공하는 JDBC 기반의 데이터 액세스 기술로
    JDBC를 보다 쉽고 효율적으로 사용할 수 있도록 추상화된 기능을 제공합니다.
    이를 통해 개발자는 반복적이고 번거로운 JDBC 작업을 간소화하고 생산성을 향상시킬 수 있습니다.

    Spring JDBC에서 제공하는 것은 다음과 같습니다.
    1. DataSource 추상화
      - Database 커넥션 풀을 관리하기 위한 DataSource 인터페이스를 제공
      - 이를 이용해, Database 연결 및 트랜잭션 관리가 편리
    2. 예외 처리 및 자원 관리
      - JDBC에서 발생하는 예외를 일괄 처리
      - 연결 및 리소스 관리를 자동으로 처리 해 개발자가 명시적으로 관리해야 하는 부분 간소화
    3. SQL 문 실행 및 매핑
      - 간단하고 직관적인 방식으로 SQL문을 실행하고 자바 객체로 매핑하는 기능 제공
      - ResultSet을 자동으로 객체로 변환하고 PreparaedStatement, CallableStatement를 사용해 SQL 파라미터 설정
    4. 트랜잭션 관리
      - 스프링의 트랜잭션 관리 기능과 통합
      - 트랜잭션 경계 설정, 롤백, 커밋 등의 작업을 편리하게 처리 가능
    5. 다양한 Callback 및 템플릿
      - JdbcTemplate, NamedParameterJdbcTemplate, SimpleJdbcTemplate 등 다양한 템플릿과 콜백 기능 제공
      - 반복적인 JDBC 코드 작성 간소화 및 일관성 있게 데이터베이스 엑세스 작업 수행 가능
  </details>

## ORM(Object Relational Mapping)이란 무엇인가요?

- ORM은 객체지향 프로그래밍 언어를 사용해 호환되지 않는 시스템 간에 데이터를 매핑해주는 도구입니다.
- 즉, 객체와 데이터베이스 테이블 간의 매핑을 도와줍니다.
- 이를 통해 개발자는 SQL을 직접 다루지 않고도 데이터베이스를 CRUD 작업을 수행할 수 있습니다.
  
  <details>
    <summary>MyBatis에 대해 설명해주세요.</summary>
  
    - MyBatis는 SQL Mapper로 JPA와 달리 데이터베이스와 상호작용을 위해 개발자가 직접 SQL을 작성해서 사용해야 합니다.
    - 따라서, 최적화된 쿼리를 직접 구현할 수 있고 엔티티에 종속받지 않으면서 다양한 테이블을 조합할 수 있습니다.
    - 하지만 직접 쿼리를 작성해야 하고 데이터 매핑을 위해 XML 또는 어노테이션을 사용해야 합니다.
    - 때문에, 지루하고 반복적인 코드를 작성하게 되고 최종적으로 SQL에 종속적이게 됩니다.

    DB와 상호작용 방식
      - MyBatis : 개발자가 직접 SQL 작성하며 데이터 매핑을 위해 XML or 어노테이션 사용
      - JPA : 객체와 관계형 데이터베이스 간의 매핑을 제공하며 JPQL을 사용      
  </details> 
  <details>
    <summary>SQL 중심적인 개발의 문제점에 대해 설명하세요.</summary>

    SQL에 의존적인 개발이 되기 때문에, 비지니스 로직이 SQL에 종속적이게 됩니다.
    즉, SQL에 의존적인 상황에서 개발자들이 엔티티를 신뢰하고 사용할 수 없게 됩니다.
    예를 들어, SQL 변경 시, 자바 코드도 변경해야 하므로 유지보수도 어려워집니다.
    
    최종적으로 패러다임 불일치 문제가 발생합니다. 객체지향 프로그래밍과 관계형 데이터베이스는 서로 다른 패러다임을 가지고 있습니다. 
    이 둘의 차이를 중앙에서 해결해주지 않으면 개발자가 많은 코드를 작성해야 하며, 복잡성이 증가합니다.
  </details>
  <details>
    <summary>JPA와 Hibernate란 무엇인가요?</summary>

    JPA는 자바 ORM 기술에 대한 표준 API 명세이기 때문에, JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 합니다.
    자바 진영에 다양한 ORM 프레임워크 중 대표적으로 사용되는 것이 바로 하이버네이트입니다.    
  </details>
  <details>
    <summary>JPA ORM을 왜 사용해야 할까요?</summary>

    데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있기 때문에, 지루하고 반복적인 쿼리 작성을 JPA가 대신 처리해줍니다.
    이처럼 패러다임 불일치 문제가 자연스레 해결되면서 유지보수성이 향상됩니다.
    또한 JPA는 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해 특정 데이터베이스 언어에 종속되지 않게 됩니다.
    그 외에도 다양한 성능 최적화 기능을 제공하기 때문에, 성능면에서도 이점이 있습니다.
  </details>
  <details>
    <summary>JPQL(Java Persistence Query Language)이란 무엇인가요?</summary>

    JPQL은 SQL과 비슷한 문법을 가지고 있지만, JPQL은 엔티티 객체를 대상으로 쿼리를 수행합니다. 
    또한 JPQL은 SQL을 추상화하여 특정 데이터베이스에 의존되지 않기 때문에, 데이터베이스 방언이 바뀌어도 수정하지 않아도 됩니다.
    이를 통해 SQL과 같은 데이터베이스 테이블이 아닌 자바 객체에 집중할 수 있습니다. 즉, JPQL은 객체지향 쿼리라고 할 수 있습니다.
  </details>

## 영속성 컨텍스트

- 영속성 컨텍스트는 엔티티를 영구 저장하는 환경입니다.
- 영속성 컨텍스트는 엔티티매니저를 통해 접근할 수 있습니다.
- 예를 들어, EntityManager.persist() 메서드를 통해 영속성 컨텍스트에 엔티티를 저장할 수 있습니다.

  <details>
    <summary>영속성 컨텍스트의 이점 5가지를 설명해주세요.</summary>

    영속성 컨텍스트를 쓰는 이유는 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연로딩이 있습니다.

    - 1차 캐시: 
      - 엔티티 조회 시, 1차 캐시에 있다면 1차 캐시에서 조회하고 없다면 Database에서 조회 후 1차 캐시에 올립니다.
      - 1차 캐시가 REPEATABLE READ 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공합니다.
    - 동일성(Identity, ==) 보장: 
      - 동일한 트랜잭션 내에서 동일성 비교가 가능합니다.
      - 영속성 컨텍스트는 특정 엔티티를 여러번 조회해도, 1차 캐시에 있는 동일한 엔티티를 반환하기 때문에 동일성이 보장됩니다.
    - 쓰기 지연:
      - 트랜잭션을 지원하는 쓰기 지연이 가능합니다.
      - 즉, SQL을 바로 보내지 않고 쓰기 지연 SQL 저장소에서 관리됩니다.
      - 쓰기 지연 SQL 저장소는 Flush 발생 시, 날라갑니다.
    - 변경 감지(Dirty checking): 
      - 플러시가 일어날 때, 1차 캐시에 들어있는 엔티티와 스냅샵을 비교해서 값이 다르면 쓰기 지연 저장소에 업데이트 쿼리를 저장합니다. 
        마지막으로 쓰기 지연 저장소 SQL을 데이터베이스에 전송하고 커밋이 완료됩니다.
      - 단, 변경 감지는 영속 상태의 엔티티에만 적용됩니다.
      - 스냅샷 : 값을 읽어온 최초 시점
    - 지연 로딩(Lazy Loading)
      - 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연한다.
      - 지연 로딩을 위해 실제 엔티티 대신 프록시 객체를 제공한다.
  </details>
  <details>
    <summary>엔티티 생명주기를 설명해주세요.</summary>

    - 비영속(new/transient)
      - 영속성 컨텍스트와 전혀 관계가 없는 상태
      - 즉, 순수한 객체 상태를 말한다.
    - 영속(managed)
      - 영속성 컨텍스트에 저장된 상태
      - 즉, 영속성 컨텍스트가 관리하는 엔티티를 말한다.
      - `EntityManager.persist(..);`, `EntityManager.find(..);`
    - 준영속(detached)
      - 영속성 컨텍스트에 저장됐다가 분리된 상태
      - `EntityManager.detach(..);`, `EntityManager.clear(..);`, `EntityManager.close(..);`
    - 삭제(removed)
      - 삭제된 상태.
      - 즉, 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제된 것을 말한다.
      - EntityManager.remove(..);
  </details>
  <details>
    <summary>플러시란 무엇인지 설명하고 플러시 발생 시, 일어나는 일을 설명하세요.</summary>

    플러시는 영속성 컨텍스트의 내용을 데이터베이스에 반영하는 것을 말합니다. 이때 영속성 컨텍스트를 비우지는 않습니다.
    즉, 영속성 컨텍스트의 내용을 데이터베이스와 동기화하는 것입니다.

    때문에, 플러시가 발생한다면 가장 먼저, 변경 감지가 일어납니다.
    그리고 변경된 것이 있다면, 데이터베이스에도 반영하기 위해 쓰기 지연 SQL 저장소에 해당 변경 쿼리를 추가합니다.
    마지막으로 쓰기 지연 저장소의 쿼리를 데이터베이스에 전송합니다.

    - 플러시 방법
      - EntityManager.flush() : 직접 호출
      - 트랜잭션 커밋 : 자동 호출
      - JPQL 쿼리 실행 : 자동 호출
  </details> 
</details>

## 즉시 로딩과 지연 로딩에 대해 설명해주세요.

- 즉시 로딩(EAGER LOADING)
  - 엔티티를 조회할 때 연관된 엔티티도 함께 조회합니다.
  - @ManyToOne(fetch = FetchType.EAGER)
  - 엔티티를 조회할 때 연관된 엔티티도 같이 조회하므로 쿼리를 2번 이상 실행할 것 같지만, 대부분 JPA는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용합니다.
    때문에, 조인 쿼리를 사용하여 즉시 로딩할 때 null을 허용하면 외부 조인, null을 허용하지 않으면 내부 조인으로 됩니다.
- 지연로딩(LAZY LOADING)
  - 연관된 엔티티를 실제 사용할 때 조회한다.
  - @ManyToOne(fetch = FetchType.LAZY)
  - 엔티티를 조회할 때 연관된 엔티티가 영속성 컨텍스트에 없다면, 프록시 객체로 조회하고 이 프록시 객체를 실제 사용할 때까지 데이터 로딩을 미룹니다.

## @Transactional 어노테이션은 어떤 기능을 하나요?

- 해당 어노테이션을 메소드나 클래스에 적용하면 해당 메소드 혹은 클래스 내의 작업들이 하나의 트랜잭션으로 묶입니다.
- 즉, @Transactional 어노테이션이 적용된 메소드에서 오류가 발생하면, 그 동안의 모든 데이터베이스 작업이 롤백되어 데이터의 일관성을 유지할 수 있습니다. 
- 반대로 오류 없이 모든 작업이 성공적으로 마무리되면, 데이터베이스에 변경 사항이 커밋되어 반영됩니다.

  <details>
    <summary>@Transactional(readonly=true)는 어떤 기능인가요? </summary>

    이는 해당 트랜잭션이 읽기 전용이라는 것을 나타내는 것으로 데이터의 변경이 없는 조회 작업에 사용되며, 성능 최적화를 위해 사용됩니다. 
    일반적으로, 읽기 전용 트랜잭션에서는 더티 체킹 등의 불필요한 연산을 생략하여 처리 성능을 향상시킬 수 있습니다. 
  </details>
  <details>
    <summary>읽기에 트랜잭션을 걸 필요가 있을까요? @Transactional 어노테이션을 안 붙이면 되지 않을까요?</summary>

    읽기 작업에 대해 트랜잭션을 걸지 않으면, 데이터의 일관성을 보장할 수 없습니다. 
    동시에 다른 트랜잭션에서 데이터 변경이 일어날 경우, 읽기 작업 중인 트랜잭션에서는 변경 전의 데이터를 읽거나, 변경 중인 데이터를 읽는 등의 문제가 발생할 수 있습니다. 
    따라서 읽기 작업에도 트랜잭션을 걸어 데이터의 일관성을 보장하는 것이 중요합니다.
  </details>  
  <details>
    <summary>JPA Propagation 전파 단계를 설명해주세요.</summary>

    JPA Propagation은 트랜잭션 동작 도중 다른 트랜잭션을 호출하는 상황에 선택할 수 있는 옵션입니다.
    이는 @Transactional 어노테이션의 propagation 속성을 통해 설정하여 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있습니다.

    예를 들어, 기본값은 REQUIRED로 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성합니다.
  </details>
</details>

## Reference

- [https://www.inflearn.com/course/ORM-JPA-Basic](https://www.inflearn.com/course/ORM-JPA-Basic)
- [https://hongguri.tistory.com/](https://hongguri.tistory.com)
- [https://code-lab1.tistory.com/](https://code-lab1.tistory.com/)
