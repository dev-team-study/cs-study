# Servlet
## 개념
웹 어플리케이션이 동적인 응답을 생성하기 위해서 사용하는 프로그램.

## 출현 배경
- 과거 웹 서버는 정적인 컨텐츠를 응답하는 기능만을 가지고 있었다.
- 이를 해결하기 위해 CGI가 등장하여 동적인 서비스를 제공할 수 있게 되었다.
- 그러나 CGI도 문제점을 가지고 있었는데 1) 요청이 올 때마다 프로세스가 생성된다는 점, 2) 요청을 처리하는 객체가 요청 당 하나씩 생성된다는 점이었다.
- 이 문제를 해결하기 위해 하나의 요청을 프로세스가 아닌 스레드가 처리하도록 하고, 요청을 처리하는 객체를 싱글톤으로 만들어 요청마다 객체가 생성되지 않도록 개선한 것이 Servlet이다.

## servlet container
- 요청이 들어오면 스레드를 할당하고, 요청에 알맞은 서블릿을 실행시킨다.
- 요청을 처리할 서블릿을 생성하고, 실행하고, 파괴하는 등의 서블릿 생명주기 관리도 수행한다.

## 동작과정
1. 요청이 들어오면 웹 컨테이너가 스레드를 할당한다.
2. 할당 된 스레드는 서블릿 설정파일을 참고하여 요청을 처리할 수 있는 서블릿 객체를 찾는다.
3. 컨테이너 내에 서블릿 객체가 생성되어 있지 않다면 Init() 메서드를 호출하여 서블릿 객체를 생성한다.
4. 서블릿 객체의 Service() 메서드를 호출한다. Service() 메서드 내에서 HTTP Method에 따라 doGet(), doPost(), doPut(), doDelete() 메서드를 호출한다. 이 때 호출되는 메서드가 개발자가 구현한 동적인 기능을 수행하는 메서드이다.
5. 컨테이너가 종료되거나 더 이상 서블릿 객체를 사용할 필요가 없을 떄 Destory()메서드를 호출하여 서블릿 객체를 파괴한다. 

## **Dispatcher Servlet** : 스프링 웹 MVC가 서블릿을 사용하는 방식 
- 모든 요청이 들어왔을 때, 디스패처 서블릿으로 간다. 디스패처 서블릿은 프론트 컨트롤러 패턴으로 구현되었다. 컨트롤러에서 처리해야하는 중복되는 문제들을 프론트 컨트롤러에서 모아 한 곳에서 처리한다.
1. 디스패처 서블릿에 요청이 들어오면 핸들러 매핑을 통해 요청을 처리할 수 있는 핸들러를 검색한다.
2. 찾은 핸들러를 호출하여 요청을 처리한다.
3. 응답 데이터를 담은 모델과 호출할 뷰 템플릿의 이름을 받아서 타임 리프 등의 뷰에 모델 데이터를 넣어서 동적인 페이지를 생성한뒤 사용자에게 반환한다.
4. 원래는 적절한 컨트롤러를 선택하고 뷰를 그리는 작업 모두 개발자가 신경써야했던 부분들인데, 디스패처 서블릿이 이러한 작업을 대신 처리해주는 덕분에 개발자는 컨트롤러 메서드의 기능 구현만 신경쓰면 된다.  

## tomcat
- 웹 서버와 웹 컨테이너의 결합(아파치의 일부 기능 + 서블릿 컨테이너)
- 현재 가장 일반적고 많이 사용되는 **WAS**
- JSP와 서블릿 처리, 서블릿 수명 주기 관리, 요청 URL을 서블릿 코드로 매핑, HTTP 요청 수신 및 응답, 필터 체인 관리 등을 처리해준다.

## filter
- WAS의 디스패처 서블릿 앞 단에서 요청 및 응답에 대한 처리를 해줄 수 있는 기능.
- 보통 인증/인가나 요청 로깅 등을 위해 사용된다.
- 비슷한 기능을 제공하는 스프링의 인터셉터가 있다.

# Spring 기본
## Spring vs Spring Boot
Spring Boot는 복잡한 Spring 설정을 대신 처리해주고, WAS가 내장 되어있어 실행 가능한 독립적인 애플리케이션을 생성해준다. 스프링을 사용할 때는 배포시 서버에 먼저 WAS를 설치하고, WAS내에 자바 어플리케이션을 넣어주는 작업이 필요했는데, 이제는 자바 어플리케이션을 실행시키는 것 만으로도 내장 WAS가 작동해서 웹 어플리케이션을 배포할 수 있게 되었다.
## Spring MVC
Spring프레임 워크의 일부로, 웹 어플리케이션을 Movel-View-Controller의 세 가지 역할로 분리하여 개발과 유지 보수를 용이하게 한다. 스프링 구성 요소들 중 네트워크와 가장 가까운 계층이라고 볼 수 있다.

### MVC1 vs MVC2
- MVC1 : 모든 요청과 응답 처리를 JSP가 담당하는 구조. 이는 JSP만을 이용하여 개발하는 방식으로 간단하고 빠르게 개발할 수 있다는 장점이 있지만, 프로젝트가 커지면 코드 재사용성과 유지보수성이 떨어진다.
- MVC2 : MVC2는 서블릿이 컨트롤러 역할을, JSP가 뷰 역할을 담당하는 구조로 역할 분리가 더욱 명확하다. 이는 각 계층의 역할이 분명하므로 코드의 재사용성과 유지보수성이 높아진다.

(dispatcher servlet은 Servlet 하위에 정리했음)

# 질문
<details>
<summary> 1. 서블릿이 동작하는 과정을 설명해주세요.</summary>
<div>
WAS에 요청이 들어오면 쓰레드 풀에서 하나의 쓰레드를 할당 받아 요청을 처리할 수 있는 서블릿을 찾게 됩니다.
찾은 서블릿 객체가 아직 생성되지 않았다면 init메서드를 통해 싱글톤 객체를 생성합니다.
이후 서블릿의 service()메서드를 호출하여 요청을 처리하고 WAS는 웹 서버나 클라이언트에서 응답을 반환합니다.
응답을 반환한 뒤에 요청 및 응답 객체는 파괴하며 할당 받았던 쓰레드는 쓰레드 풀에 반납하게 됩니다.
</div>
</details>

<details>
<summary> 2. 스프링의 디스패처 서블릿이 동작하는 과정을 설명해주세요.</summary>
<div>
스프링의 디스패처 서블릿은 기존 서블릿과 달리 하나의 서블릿이 우선 모든 요청을 받게 됩니다. 모든 요청을 건네 받는 하나의 서블릿을 디스패처 서블릿이라 부르며, 이런 처리 방식을 프론트 컨트롤러 패턴이라고합니다. 요청을 건네 받은 디스패처 서블릿을 핸들러 매핑을 통해 요청을 처리할 수 있는 핸들러를 찾고, 핸들러를 호출하여 요청을 처리한 뒤, 뷰를 생성하는 등의 작업을 수행합니다. 이 같은 작업을 통해 컨트롤러 계층에서 발생할 수 있는 중복적인 작업이 상당 부분 디스패처 서블릿으로 이동하게 되었고, 개발자는 비즈니스 코드만을 신경쓰게 되었습니다.      
</div>
</details>

<details>
<summary> 3. 웹 서버와 WAS를 분리해야하는 이유가 무엇인가요?</summary>
<div>
우선 WAS도 웹 서버의 역할을 수행할 수 있지만 이미 동적인 처리를 담당하고 있는 WAS가 정적인 처리까지 담당하게 되면 WAS가 과부하될 수 있습니다. 따라서 정적인 처리는 그에 특화되어있는 웹 서버에 맡김으로서 어느 한 부분에 과부하가 생기는 것을 방지하고자 하는 목적이 있습니다.  
그리고 프로젝트를 하면서 리버스 프록시로서 웹 서버를 둔 경우도 있었습니다. 웹 서버를 WAS 앞 단에 두어서 우선적으로 모든 HTTPS 요청을 받아서 복호화하도록 하면, 이러한 복호화의 역할을 웹 서버에 맡길 수 있게되고 뒷 단의 WAS는 보안적으로 좀 더 안전해지는 한편 WAS가 늘어날 때 로드밸런싱까지도 웹 서버에서 처리해줄 수 있다는 장점이 있습니다.      
</div>
</details>