### 객체지향 4가지 특징
추상화 : 객체들의 공통된 특징을 파악해 정의하는 과정

캡슐화 : 객체의 필드와 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것(비즈니스 로직 보호)

상속 : 부모 클래스의 필드와 메소드를 자식 클래스가 물려받는 것 (재사용성, 다형성)

다형성 : 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것

### SOLID 5원칙
### 1. SRP (단일 책임 원칙)
하나의 클래스는 하나의 책임만 가진다. 왜?
수정이 필요한 경우 수정되는 이유는 단 하나 때문이어야 한다. 변경의 연쇄작용이 일어나면 안되기 때문

### 2. OCP (개방 폐쇄 원칙)
높은 응집도 : 하나의 모듈 클래스가 하나의 책임 혹은 관심사에 집중되어있다. 같은 책임과 관심사에 집중되어 있다.
객체에 변경이 발생해도 다른 곳에 미치는 영향이 적다.
<br>
낮은 결합도 : 책임과 관심사가 다른 객체나 모듈과는 낮은 결합도를 유지해야 한다. 변경이 발생해도 다른 객체나 모듈에 미치는 영향이 적다.

### 3. LSP (리스코프 치환 원칙)
추상 객체로 사용되는 부분에 구상 객체가 들어가도 아무 문제가 없어야 한다.
자식 클래스는 언제든 부모 클래스르 ㄹ대체할 수 있다. is-a 관계가 성립해야 한다.
결국 이런 것들은 모두 다형성을 지키기 위함이다.

### 4. ISP (인터페이스 분리 원칙)
SRP가 클래스의 단일 책임의 원칙을 강조한다면 ISP는 인터페이스의 단일 책임의 원칙을 강조한다.
변경이 있을 경우 인터페이스에 변경이 있어야지 클래스에 변경이 있어서는 안된다.
결국 사용자 관점에서 요구사항에 맞춰 적절하게 대응할 수 있는 인터페이스 설게가 필요하다. 

### 5. DIP (의존 역전 원칙)
추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
고수준 모듈은 저수준 모듈에 의존해선 안된다.

### 객체지향 vs 절차지향 vs 함수형 프로그래밍
- 절차지향<br>
일이 진행되는 순서대로 프로그래밍 하는 방법<br>
가독성이 좋고, 실행속도가 빠르다. 하지만 유지보수가 어렵다.
- 함수형 프로그래밍<br>
함수를 조합해 프로그래밍 하는 방법<br>
동일한 값을 넣을때 항상 동일한 결과를 반환한다. 멀티 쓰레드 환경에서 안전하다.<br>
외부에서 들어오는 값에 영향을 받지 않는다.
- 객체지향 프로그래밍<br>
객체를 조합해 프로그래밍 하는 방법<br>
1. 객체는 상태와 행위를 가진다.
2. 객체는 다른 객체와 상호작용을 한다. 
3. 객체는 다른 객체의 상태를 변경할 수 있다.<br>
차이? 객체지향 = 절차지향 + 객체

### jdk
jre와 컴파일러, 디버거를 모두 포함해 자바 프로그램의 개발에 필요한 도구를 제공한다.
jdk의 bin의 실행 파일
- javac.exe : 자바 컴파일러
- java.exe : 자바 인터프리터(바이트코드를 해석하고 실행)
- javap.exe : 클래스 파일의 바이트코드 역어셈블러(바이트코드를 자바소스로 변환)
- javadoc.exe : 자바 문서 생성기(소스파일의 주석을 이용해 문서를 자동생성)
- jar.exe : 자바 아카이브 파일 생성기
- jdb.exe : 자바 디버거(자바 프로그램의 실행과정중 오류를 찾음)

### jre
- jvm과 자바 프로그램을 실행시킬 때 필요한 라이브러리 api를 묶어서 배포되는 패키지이다.
- 개발에는 jdk, 실행에는 jre를 사용한다.
- 자바 프로그램을 실행하는 jvm 인스턴스나 로컬 복사본을 만든다.
- jre는 모든 유형의 jvm에서 실행되는 단일 자바코드 복사본을 생성한다. => 어디에서나 실행할 수 있다.

### jvm
운영 체제에 관계 없이 자바 프로그램을 실행할 수 있도록 설계된 가상 머신

### 자바 메모리 구조
스레드마다

PC register : 현재 실행중인 jvm 명령어를 가지고 있음

stack : 호출된 메소드의 매개변수, 지역변수 리턴 정보들이 저장된다.

native method stack : 자바 이외의 언어로 작성된 코드를 위한 stack(ex system.out.println은 c언어 내용도 혼재되어있음)

스레드 공통

heap : 런타임중 생성되는 객체들이 동적으로 할당되는 영역

method area : 클래스, 메소드, 상수, static변수 등이 저장되는 영역

### 자바 어플리케이션 실행 과정 
0. 자바는 우선 java파일로 가지고 있음
1. 컴파일러를 통해 컴파일 진행,class파일인 바이트코드로 가지게 됨
2. 클래스 로더가 jvm메모리에 업로드 시킴 (필요한 상황에서만)
3. 실행엔진에서 jvm 메모리에 올라온 바이트코드를 명령어 단위로 하나씩 가져와서 실행한다.

    3-1 인터프리터 : 바이트코드를 한줄씩 실행한다. (한줄당 실행은 빠르나 전체 속도가 느림)
    
    3-2 jit 컴파일러 : 바이트코드 전체를 컴파일해 바이너리 코드로 변경하고 바이너리 코드로 직접 실행한다.
    
    3-3 gc : 더이상 참조되지 않는 객체를 제거한다.
 
###  자바는 jit 컴파일러를 컴파일 방식과 인터프리터 방식을 혼용해서 사용한다.
1. 컴파일러가 소스코드를 바이트코드로 변환해 최적화한다.
2. 바이트코드가 실행되는 과정에서 실시간으로 jit 컴파일ㄹ러가 바이트코드를 기계어로 변환한다.
3. 필요한 부분만 변환 + 변환된 코드는 캐싱되어 다시 컴파일할 필요가 없어진다.<br>
즉, 필요한 만큼만 컴파일하고, 캐싱해두어서 실행속도가 빠르다.

### 클래스 로드 과정
1. 로딩 .class를 jvm에 로드
2. 링킹 .class파일을 참조하는 다른 클래스와 연결
<br>
2-1. 검증 클래스 바이트코드가 자바의 규칙을 잘 따르고 있는지 검사한다.
<br>
2-2. 준비 클래스가 필요로 하는 메모리를 미리 할당한다.
<br>
2-3. 분석 클래스가 참조하는 객체의 메모리 주소값을 대입한다.
3. 초기화 static변수의 값을 할당하고 초기화하는 단계

### 클래스 로더 
메모리에 없는 클래스가 필요할 때 파일로부터 읽어 메모리에 로딩한다.
1. 캐시에 해당 클래스가 있는지 먼저 확인한다. (이전에 로드된 클래스인지)
2. 상위 클래스 로더에서 확인을 한다.
3. 하위 클래스 로더에서 확인을 하고 가져온다.

### 클래스 로더 종류
bootstrap class loader  : jvm이 실행될 때 가장 먼저 실행된다. 자바의 기본적인 클래스를 로드한다.
extension class loader  : 자바 기본 클래스를 제외한 확장된 클래스를 로드한다.
system class loader     : classpath라는 옵션이 붙은 클래스들을 로드한다. 
user-defined class loader : 사용자가 직접 정의한 클래스를 로드한다.

### grabageCollector 동작과정
프로그램이 동적으로 할당한 메모리(힙영역)중 필요없는 영역을 알아서 해제한다.<br>
### 특징
메모리 누수 방지, 해제한 메모리에 접근 방지
### 단점
- 순수 오버헤드 작업이다. gc가 진행되는 과정은 프로그램의 실행시간을 느리게 한다.
- 메모리 타임을 개발자가 파악하기 어렵다.(자동관리이긴 하지만)
- 실시간성이 중요한 경우 gc에게 메모리를 맡기기 더욱 어렵다.
### gc가 해제해야할 동적 메모리를 알아서 판단하는 방법
- 참조 카운팅 방식 : 참조 카운트가 0이 되면 해제한다. (참조 카운트가 0이 되는 경우는 참조하는 변수가 없을 때)
순환참조 문제가 발생해 메모리 leak이 발생한다. 
- mark and sweep : 객체의 연결을 파악해 참조가 되지 않는 객체를 해제한다.
gc를 의도적으로 실행ㅎ애야 하고, gc가 실행되는 동안 프로그램이 멈춘다.
### 실행
young(eden, survivor space), old, permanent 영역으로 나뉜다.
eden에서 minor gc가 실행되고, survivor space로 이동한다.
survivor space에서 일정한 age-bit이 되면 old generation으로 이동한다.(parallel gc의 경우 15)
old 영역이 가득차면 major gc가 실행된다.
permanent 영역은 jvm이 실행되는 동안 계속 유지되는 영역이다. (메타데이터, 클래스정보 등)
### gc 종류
- serial gc : gc를 실행하는 스레드가 1개이다. gc가 실행되는 동안 프로그램이 멈춘다.
- parallel gc : gc를 실행하는 스레드가 여러개이다. gc가 실행되는 동안 프로그램이 멈춘다.
- cms gc : gc를 실행하는 스레드가 여러개이다. gc가 실행되는 동안 프로그램이 멈추지 않는다.
- g1 gc : gc를 실행하는 스레드가 여러개이다. gc가 실행되는 동안 프로그램이 멈추지 않는다. (young, old 영역을 동적으로 나눈다.)

### Java8의 큰 특징 + Java11과의 차이점
람다 표현식<br>
메서드로 전달할 수 있는 익명 함수를 하나의 식으로 표현하도록 단순화한 것, 일회용 객체를 만들지 않고, 간단하게 작성이 가능하다.

스트림 api<br>
자바에서 배열이나 collection의 데이터를 함수형으로 처리할 수 있도록 도와주는 api<br>
멀티스레드를 활용해 병렬연산과, 내부 반복연산을 수행해 코드가 간결해진다.

Optional<br>
null을 직접 다루는 것이 아닌, Optional 객체를 통해 간접적으로 다룬다. npe를 해결할 수 있고 가독성 높은 코드를 작성할 수 있다.

인터페이스의 default 메소드<br>
이미 개발한 인터페이스 메소드들이 있는데, 거기에 새로운 메소드를 추가해야 하는 경우, 기존에 개발한 인터페이스를 구현한 모든 클래스들에 새로운 메소드를 추가해야 한다.

이런 관점에서 바라보았을때 협업과, 인터페이스를 활용하는 목적에 있어서 이런 메소드를추가해 사용함으로써 유연한 대처가 가능해진다.

JVM의 PermGen 영역 제거<br>
JVM의 PermGen 영역은 클래스 메타데이터를 담는 곳이다. 
이 영역은 고정된 크기를 가지고 있어서, 클래스 메타데이터를 담기에 부족한 경우 OOM이 발생한다.
이를 해결하기 위해 PermGen 영역을 제거하고, Metaspace 영역을 추가했다.

Metaspace 영역은 native memory 영역으로 PermGen 영역과 달리, 힙 영역에 할당되어 동적으로 메모리를 할당받는다.
 