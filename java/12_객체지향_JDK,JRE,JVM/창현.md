# 1. 객체지향
- 많은 객체들이 모여서 상호 협력하면서 데이터를 처리하는 방식을 의미
- 프로그램을 묶음 단위로 잘게 쪼개서, 추후에 가져다 쓰기 편하게 만들어 놓은 프로그래밍 방식
- 대부분의 프로그래밍 언어는 Class를 지원하여 객체 지향 언어 방식을 지원하고 있음

## 1.1 4가지 특징
### 1.1.1 추상화
- 클래스를 정의할 때 불필요한 부분들을 생략하고 객체의 속성 중 중요한 것에만 중점을 두어 개략화 하는 것을 말함

#### 1.1.1.1 제어 추상화
- 어떤 클래스의 메소드를 사용하는 사용자에게 해당 메소드의 작동방식과 같은 내부 로직을 숨기는 것
- 예를 들어, JPA 라이브러리를 사용할 때 저장하는 메서드인 save를 하게 되면 저장한다라는 것만 알고 내부의 동작 원리는 몰라도 됨.
  - 즉, 구체적이지 않고 추상적으로 메서드 동작을 가늠해 결과 값만 받고 끝냄
  - 생산성 증가, 가독성 증가

#### 1.1.1.2 데이터 추상화
- 대상을 간단한 개념으로 일반화 하는 과정
- 예를 들어, 삼각형, 사각형, 원이라는 객체가 있을 때, 이 객체들을 하나로 묶을 때 객체들의 공통 특징인 도형으로 묶어 이름을 붙이는 것
  - 이렇게 추상화 하면 객체의 디테일 함이 사라지고 공통된 특징만 남음

### 1.1.2 상속
- 객체들 간의 관계를 구축하는 방법을 의미
- 상위 클래스의 속성과 기능을 상속하여 하위 클래스가 전부 물려받는 것을 의미
- 상위 클래스의 특징을 하위 클래스에서 상속받게되어 코드의 중복 제거, 코드 재사용성 증대 효과를 누릴 수 있음

### 1.1.3 다형성
- 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질을 의미
- 자바에서는 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상메소드, 추상클래스 방법
- 예를 들어, 우리가 ArrayList를 사용할 때 List로 선언해서 쓰는 것 처럼 List라는 인터페이스를 선언하고 하위에 ArrayList나 LinkedList등 여러 리스트를 두어 다양한 결과를 얻어낼 수 있음

### 1.1.4 캡슐화
- 캡슐로 감싸서 안보이게하는 정보 은닉 개념중 하나
- 속성(필드)와 행위(메서드)를 하나로 묶고 외부로 부터 내부를 감싸 숨겨 은닉
- 외부의 잘못된 접근으로 값이 변하는 의도치 않는 동작을 방지하는 보호 효과
  - 필드를 private으로 두어 은닉하고 get를 통해서만 사용할 수 있게 하는 것
  - String 객체도 필드가 모두 private으로 되어있고 불변


## 1.2. SOLID 5원칙
- 객체지향 설계에서 지켜줘야 할 5개의 소프트웨어 개발 원칙
- 적용시 코드를 확장하고 유지보수 관리가 쉬워지며, 복잡성을 제거해 개발의 생산성을 높일 수 있음

### 1.2.1 SRP(단일 책임 원칙)
- 클래스(객체)는 단 하나의 책임만 가져야 함
- 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하도록 설계해야 함
- 하나에 여러 책임이 있을 때 수정이 일어나면 수정해야할 코드가 많아짐
- 예를 들어, 직원이라는 클래스가 있을 때 직원의 초과 근무 시간에 따라 초과 근무 비용을 측정하는 메서드가 있다고 치고 개발팀, 인사팀, 회계팀이 모두 같이 사용하는데 어느날 개발팀의 초과 근무 비용만 늘린다고 하면 코드를 바꿔야하는데 인사팀, 회계팀에도 영향을 미침

### 1.2.2 OCP(개방 폐쇄 원칙)
- 확장에는 열려있어야 하며, 수정에는 닫혀있어야 함
- 클래스를 확장할 때 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야하는 설계 기법
- OCP 원칙은 추상화 사용을 통한 관계 구축을 권장
  - 즉, 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙

### 1.2.3 LSP(리스코프 치환 원칙) 
- 서브 타입은 언제나 부모 타입으로 교체할 수 있어야 함
- 다형성 원리를 이용하기 위한 원칙
- 예를 들어, Collection 인터페이스를 보았을 때 LinkedList를 구현체로 사용하든 HashSet을 구현체로 사용하든 add 메서드는 동일하게 수행 됨

### 1.2.4 ISP(인터페이스 분리 원칙)
- 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야한다는 설계 원칙
- SRP가 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조
- 한 번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 하면 안됨
- 예를 들어 핸드폰이라는 인터페이스를 두고, 통화 기능, 메시지 등 여러 기능들을 추상화 했을 때 갤럭시 S1은 기능이 단순해서 핸드폰이라는 인터페이스로 사용 가능하지만, 갤럭시 S21에 들어가는 기능이 없어 별도로 구현해야 함.
  - 그래서 핸드폰이라는 인터페이스에는 기본적인 기능 통화, 메시지만 두고 나머지 기능들은 별도의 인터페이스로 분리해서 여러 개의 인터페이스를 구현한다.

### 1.2.5 DIP(의존 역전 원칙)
- 어떤 Class를 참조해서 사용해야하는 상황이 생긴다면, 그 Class를 직접 참조하지않고 그 대상의 상위 요소로 참조
- 구현 클래스에 의존하지말고, 인터페이스에 의존
- 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것 보다는, 변화하기 어려운 것 거의 변화가 없는 것에 의존


## 1.3 객체지향 vs 절차지향 vs 함수형 프로그래밍
### 1.3.1 객체지향
- 객체라는 기본 단위로 나누고 이들의 상호작용 의존 관계로 나타내는 방식
- OOP를 사용해서 코드의 중복을 어느정도 줄일 수 있음

### 1.3.2 절차지향
- 하나의 큰 기능을 처리하기 위해 작은 단위의 기능들로 나누어 처리하는 Top-Down 방식으로 처리
- 비교적 작은 규모의 작업을 수행하는 함수를 생성
- 특정 기능을 수행하려면 그 일을 해주는 메서드를 직접 호출
  - 상대적으로 빠름
  - 유지보수가 어려움
  - 순서로 적용되기 때문에 결과 값 도출이 어려움

### 1.3.3 함수형 프로그래밍
- 거의 모든 것을 순수 함수로 나누어 문제를 해결하는 기법
- 작은 문제를 해결하기 위한 함수를 작성하여 가독성을 높이고 유지보수를 용이하게 함
- 함수형 프로그래밍에서는 출력하는 함수를 파라미터로 넒길 수 있음
  - 자바에서 Stream 처리할 때 받은 값을 출력하는 메서드를 사용할 수 있는 것 처럼 메서드를 넘겨 사용할 수 있음
- 예를 들어, 자바에서 어떠한 배열에서 단어의 크기가 2이상인 경우를 필터링하고, 모든 단어를 대문자로 바꾸고, 앞글자만 잘라내어 반환한다 했을 때
  함수형 프로그래밍 없이 만든다면 여러번의 메서드 호출에 호출로 클래스를 넘나들을 수도 있고 굉장히 복잡해지지만 메서드 체이닝을 통한 함수형 프로그래밍으로 간단하게 처리가 가능함

# 2. JDK, JRE, JVM
- JDK: 개발자들이 자바로 개발하는데 사용되는 SDK 키트, 자바를 개발할 때 필요한 라이브러리와 JRE가 포함
- JRE: 자바 실행환경으로 JVM과 자바 프로그램을 실행시킬 때 필요한 라이브러리 API를 함께 묶어서 배포되는 패키지
- JVM: 자바 가상머신으로 자바를 돌리는 프로그램, 자바 프로그램을 실행하기 위해서는 반드시 자바 가상 머신이 필요(JRE에 포함)
  - Java는 OS에 종속적이지 않다는 특징을 가지고 있음.
    - C언어를 컴파일하면 기계어로 변환이 되는데 다양한 환경의 OS에서는 윈도우에서 컴파일한 기계는 리눅스에서 이해하지 못함
  - 자바는 JVM을 거쳐서 운영체제와 상호작용을 함
    - JVM이 컴파일된 코드와 OS 중간 단계에서 환경에 맞게 바이트 코드로 변환 시켜줌

## 2.1 컴파일 과정
1. 소스코드를 작성(.java)
2. 컴파일러는 자바 소스코드를 이용하여 클래스 파일을 생성, 컴파일 된 클래스 파일은 JVM이 인식할 수 있는 바이트 코드 파일
   - 컴퓨터는 이해할 수 없음
3. 컴파일된 바이트 코드를 JVM의 클래스로더에게 전달
4. 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역, JVM의 메모리에 올림
5. 실행 엔진을 통해 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행
   - 인터프리터: 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
   - JIT 컴파일러: 인터프리터의 단점을 보완하기 위해서 나온 것으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 바이너리 코드로 실행하는 방식

## 2.2 컴파일 언어 vs 인터프리터 언어
### 2.2.1 컴파일 언어
- 소스코드를 기계어로 컴파일해서 실행파일을 만들어 실행하는 방식
  - 컴파일 언어는 소스코드를 한 번에 기계어로 변환하여 실행 파일을 만ㄷ름
  - 컴파일은 단 한번만 수행
  - 런타임 상황에서는 이미 기계어로 모든 소스코드가 변환되어 있기 때문에 인터프리터에 비해 빠름
- 컴파일러: 고급 언어로 작성된 소스코드를 저급 언어로 번역하는 프로그램
- 한 번에 모든 코드를 컴파일하기 때문에 실행 전에 오류를 파악할 수 있음

### 2.2.2 인터프리터 언어
- 코드를 한 줄씩 읽어 내려가며 실행하는 방식
- 소스코드를 기계어로 변환하는 과정 없이 한줄씩 해석하여 바로 명령어를 실행하는 언어
- 컴파일 시간은 없지만 실행 시마다 수행되어야하므로 실행 속도가 느림
- 실행 과정에서 오류를 파악할 수 있음

### 2.2.3 자바는 컴파일 언어인가? 인터프리터 언어인가?
- 자바는 컴파일과 인터프리터 2가지를 모두 사용
- 자바 소스 코드를 자바 바이트 코드로 컴파일하고, JVM에서 바이트 코드를 기계어가 이해할 수 있는 기계어로 변환
- JVM은 런타임에 인터프리터를 사용

## 2.3 JVM 메모리 구조
- JVM의 런타임 데이터 영역이라고도 부름
- 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역

### 2.3.1 메서드 영역(static)
- JVM에서 읽어들인 클래스와 인터페이스에 대한 런타임 상수 풀, 메서드와 필드, Static 변수 등, 메서드 바이트 코드 등을 보관
- 명시적으로 null 선언시 GC대상
- 메서드 영역안에 Runtime Constant Pool이 있음 -> 클래스와 인터페이스 상수, 메서드와 필드에 대한 모든 레퍼런스 저장
- 간단하게 정적 필드와 클래스 구조만을 갖고 있음
### 2.3.2 힙 영역
- 프로그램 상에서 데이터를 저장하기 위해 런타임시 동적으로 할당하여 사용하는 메모리 영역
- new 연산자를 통해 생성한 객체 또는 인스턴스와 배열을 저장
- 객체가 더 이상 쓰이지 않거나, 명시적으로 Null 선언시 GC 대상
### 2.3.3 스택 영역
- 메서드 호출 시 생성되는 스레드 수행정보를 기록 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
- 코드 블럭이나 메서드가 종료될 때 삭제 됨

### 2.3.4 PC Register
- 연산 및 결과 값을 메모리에 전달하기 전 CPU내 기억장치

### 2.3.5 네이티브 메서드
- 자바 외 언어로 작성된 네이티브 코드를 위한 메모리

메서드 영역과, 힙 영역은 모든 쓰레드가 공유하는 영역이고 나머지는 각 쓰레드마다 생성되는 개별 영역


## 2.4 Garbage Collector
- 자바의 메모리 관리 방법으로 Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스
- GC가 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있음
  - STW(Stop The World): GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미
    - GC 관련된 쓰레드를 제외하고 모든 쓰레드는 멈추고 서비스 이용에 차질이 생김
    - GC가 너무 많이 실행되면 소프트웨어 성능 하락의 문제가 됨.
### 2.4.1 청소 방식
- Mark And Sweep
  - GC에서 사용되는 객체를 찾는 내부 알고리즘
  - 아주 기초적인 청소 과정으로 대상 객체를 식별하고, 제거하며 파편화된 메모리 영역을 앞에서부터 채워나가는 작업을 수행
  - Mark: 그래프 순회를 통해 연결된 객체들을 찾아내어 어떤 객체를 참조하고 있는지 찾아서 마킹
  - Sweep: 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거
  - Compact: Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축

### 2.4.2 동작 과정
- GC의 대상인 힙 영역은 대부분의 객체는 금방 접근 불가능한 상태로 되고, 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재
  - 즉, 객체는 대부분 일회성되며, 메모리에 오랫동안 남아있는 경우는 드뭄
- Young과 Old 2가지 영역으로 나뉨
- Young
  - Eden: new를 통해 새로 생성된 객체가 위치, 정기적인 쓰레기 수집 후 살아남은 객체들은 Suvivor 영역으로 보냄
  - Survivor0: 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역

Minor GC
- Young 영역은 짧게 살아남는 메모리들이 존재하는 공간
1. 처음 생성된 객체가 Young 영역의 일부인 Eden에 위치
2. 객체가 계속 생성되어 Eden영역이 꽉차고 Minor GC가 실행
3. Mark 동작을 통해 살아남은 객체들은 Survivor영역으로 이동
4. Eden 영역에서 사용되지 않는 객체들은 메모리 해제
5. 살아남은 모든 객체들은 age 값을 1씩 증가
6. age 값의 임계 값에 다다르면 Old 영역으로 이동(기본 31)

Major GC
- Old 영역은 길게 살아남는 메모리들이 존재하는 공간
1. Young 영역에서 age값이 임계 값에 다다르면 Old 영역으로 이동(이를 프로모션이라 부름)
2. Old 영역에 계속 차면 영역의 메모리가 부족하게 되는데 그때 Major GC가 발동

- 일반적으로 Old영역의 MajorGC는 Minor GC보다 오래걸리며 10배 이상의 시간을 사용
- Java 9+ 부터는 G1 GC 방식으로 동작..


## 2.5 Java8의 큰 특징 + Java11과 다른 점
### 2.5.1 Java8의 특징
- Oracle의 지원 기간이 김
- 자바는 객체지향형 프로그래밍이지만 함수형 프로그래밍도 지원하기 시작
#### 2.5.1.1 추가 된 기능
- 람다식, 스트림
- 함수형 인터페이스
- 디폴트 메서드
- 새로운 날짜, 시간 API(LocalDateTime)
- Optional

### 2.5.2 Java11
- Java8 이후부터 GC의 방식이 바뀜(페레럴 GC에서 G1 GC)
- Java 파일을 javac로 컴파일 하지 않고도 바로 java 파일을 실행할 수 있게 됨