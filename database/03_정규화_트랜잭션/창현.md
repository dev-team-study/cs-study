# 3. 정규화, 트랜잭션
## 3.1 이상 현상과 정규화
  ### 3.1.1 이상 현상
  불필요한 데이터 중복으로 인해 릴레이션에 대한 데이터 삽입, 수정, 삭제 연산을 할 때 발생할 수 있는 부작용.

   1. 삽입 이상
      - 데이터 삽입 시 의도와 다른 값들도 삽입됨
      - 예) 수강 내역과 학생 정보를 같은 테이블에서 사용할 경우 학생이 추가되면 수강 내역을 추가해야하는데 이때 추가되는 수강 내역은 불 필요한 값이므로 삽입 이상 현상이 생김
   2. 삭제 이상
      - 데이터 삭제 시 의도와 다른 값들도 연쇄 삭제됨
      - 예) 수강 내역과 학생 정보를 같은 테이블에서 사용할 경우 수강 내역만 삭제하고 싶은데 학생 정보까지 삭제됨
   3. 갱신 이상
      - 속성 값 갱신 시 일부 튜플만 갱신되어 모순 발생
      - 예) 수강 내역과 학생 정보를 같은 테이블에서 사용할 경우 ID가 2번인 학생의 수강 내역의 레코드가 2개가 있을 때 한 레코드의 이름만 변경하는 경우 갱신 이상이 일어남

  ### 3.1.2 정규화
  **기본 목표**: 테이블 간에 중독된 데이터를 허용하지 않는 것
   - 이상현상이 있는 릴레이션을 분해하여 이상현상을 없애는 것
   - 무결성을 유지할 수 있고 DB의 저장 용량을 줄일 수 있음
     - 무결성: 저장된 데이터 값과 표현하는 현실 세계의 실제 값이 일치하는 것

  #### 3.1.2.1  1정규화
   - 테이블의 컬럼이 원자 값(하나의 값)을 갖도록 테이블을 분리
   - 하나의 컬럼안에 배열로 값을 넣을 수 없음.
  #### 3.1.2.2  2정규화
   - 1정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해
   - 기본키의 부분집합이 결정자가 되어선 안됨
  #### 3.1.2.3  3정규화
   - 2정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해
   - 이행적 종속: A -> B, B -> C
  #### 3.1.2.4  BCNF 정규화
   - 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것

  #### 3.1.2.5 정규화 장점
   - 이상 현상 제거
  #### 3.1.2.6 정규화 단점
   - 릴레이션의 분해로 인해 JOIN 연산이 많아진다.
   - 조인으로 인한 성능 저하시 반정규화를 적용 할 수 있다.

  #### 3.1.2.7 반정규화
   - 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법 -> 데이터 무결성이 깨질 수 있음.
   - 테이블을 병합 시켜 성능 향상, 중복 칼럼을 추가해서 조인 감소 시킴 등

## 3.2 트랜잭션
  ### 3.2.1 트랜잭션 개념
   - 트랜잭션이란, 데이터베이스의 상태를 변화시키기 위해서 수행하는 **작업의 단위**
   - 예를 들면 CRUD를 하는 작업이라고도 볼 수 있으며 C, R, U, D 각각의 하나의 작업 단위가 아닌 여러개가 한꺼번에 묶인 작업이 단위가 될 수도 있음

  ### 3.2.2 ACID
  데이터베이스 내에서 일어나는 하나의 트랜잭션의 안전성을 보장하기 위해 필요한 성질

   - 원자성(Atomicity)
     - 트랜잭션이 데이터베이스에 모두 반영되거나, 아니면 전혀 반영되지 않아야 한다는 점
   - 일관성(Consistency)
     - 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 점
   - 독립성(Isolation)
     - 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점 
   - 지속성(Durability)
     - 트랜잭션이 성공적으로 완료되었을 경우, 결과는 영구적으로 반영되어야 한다는 점
     - 런타임 오류나 시스템 오류가 발생하더라도, 해당 기록은 영구적이어야 함
  
  ### 3.2.3 Commit, Rollback
  - **Commit**
     - 트랜잭션의 모든 작업을 정상적으로 처리하겠다고 확정하는 명령어
  - **Rollback**
     - 작업 중 문제가 생겼을 때, 트랜잭션의 처리 과정에서 발생한 변경 사항을 취소하고 트랜잭션을 종료시킴
  #### 장점
   - 데이터 무결성이 보장된다.
   - 논리적으로 연관된 작업을 그룹화할 수 있다.
    
  ### 3.2.4 트랜잭션 격리수준
   #### 3.2.4.1 SERIALIZABLE
  - 엄격한 격리 수준
  - 트랜잭션을 순차적으로 진행시킴
  - 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없어서 어떠한 데이터 부정합 문제도 발생하지 않음

   #### 3.2.4.2 REPEATABLE READ
  - 변경 전의 레코드를 언두 공간에 백업(변경 전/후 데이터가 모두 존재하여 여러버전인 MVCC)
  - MVCC를 이용해 한 트랜잭션 내에서 동일한 경과를 보장하지만 새로운 레코드가 추가되는 경우에는 부정합이 발생할 수 있음
  - Repeatable read는 보통 팬텀 리드가 발생하지 않음.
  - 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견되는 것을 팬텀 리드라고 함
  - 하지만 FOR UPDATE를 하는 경우 실제 테이블의 데이터를 읽어오므로 팬텀 리드가 발생함.

   #### 3.2.4.3 READ COMMITTED
  - 커밋된 데이터만 조회할 수 있음.
  - 팬텀 리드와 Non-Repeatable Read(반복 읽기 불가능) 문제까지 발생
  - Non-Repeatable Read: 한 트랜잭션 내에서 반복적으로 읽을 때 일관된 데이터를 읽어오는 것이 아니라 매번 다른 데이터를 가져올 수 있음.

   #### 3.2.4.4 READ UNCOMMITED
  - 커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준
  - 만약 Update 후 커밋하지 않아도 다른 트랜잭션에서는 Update한 데이터를 읽을 수 있음
  - 데이터 정합성에 문제가 많은 격리 수준
  
  ### 3.2.5 Lock, 교착상태
   LOCK: 트랜잭션의 처리의 순차성을 보장하기 위한 방법

   #### 3.2.5.1 Lock의 설정 범위
   ##### 데이터베이스
   - 전체 데이터베이스를 기준으로 Lock을 설정하여 1개 세션만이 DB 데이터 접근 가능
   ##### 파일
   - 데이터베이스 파일을 기준을 Lock을 설정
   ##### 테이블
   - 테이블을 기준으로 Lock을 설정
   ##### 페이지와 블럭
   - 파일의 일부만 페이지와 블록을 기준으로 Lock을 설정
   ##### 컬럼
   - 컬럼을 기준으로 Lock을 설정
   ##### 행
   - 1개의 행을 기준으로 Lock을 설정
  
   #### 3.2.5.2 Lock 종류
   ##### 공유 락
   - 공유 락은 데이터를 조회할 때 사용되며 Read Lock이라고도 불리고 Shared의 앞글자를 따서 S-Lock이라고도 표현
   
   ##### 베타 락
   - 데이터에 변경할 때 사용하는 Lock으로 Write Lock이라고도 불리며 X-Lock이라고도 표현
   
   ##### 업데이트 락
   업데이트 락은 데이터를 수정하기 위해 베타 락(X)을 걸기 전, 데드 락을 방지하기 위해 사용
   UPDATE쿼리의 필터가 실행되는 과정에서 적용

   ##### 내재 락
   내재 락은 사용자가 요청한 범위에 대한 락을 걸 수 있는지 여부를 빠르게 파악하기 위해 사용

   ##### 갭 락
   레코드와 레코드 사이의 간격을 잠금

   ##### 넥스트 키 락
   레코드 락과 갭 락을 합친 잠금

   ##### 자동 증가 락
   중복되지 않고 순차적으로 증가하는 일련번호를 제공하기 위해 테이블 수준의 잠금인 자동 증가 락

   #### 3.2.5.3 교착 상태
   두 트랜잭션이 각각 Lock을 설정하고 서로의 Lock에 접근하여 값을 얻어오려고 할 때
   각각의 트랜잭션이 Lock이 설정되어있어 양쪽 트랜잭션이 모두 영원히 처리가 되지 않는 상태


   # 질문
   ## 1. 이상 현상이란 무엇이고, 이상 현상의 종류에 대해서 설명해주세요.
   이상 현상이랑 불필요한 데이터 중복으로 인해 데이터베이스에서의 삽입, 삭제, 수정이 일어날 때 발생하는 문제들을 의미 합니다.

   우선 삽입 이상은 릴레이션에 데이터를 삽입할 때 불필요한 데이터까지 삽입되는 현상을 의미합니다.
   그리고 갱신 이상은 데이터를 갱신할 때 하나의 데이터만 갱신되어 다른 데이터와 데이터가 부정합하는 문제가 생기는 것을 의미하고 삭제 이상은 데이터를 삭제할 때 의도치 않게 다른 데이터까지 삭제되는 것을 의미합니다.

   ## 2. 정규화란 무엇이고, 정규화의 종류에 대해서 설명해주세요.
   정규화란 릴레이션을 최대한 나눠 데이터를 중복되지 않게 이상현상을 없애는 것 입니다.

   1NF, 2NF, 3NF, BCNF가 있습니다.

   1NF는 릴레이션의 컬럼이 하나의 값 즉 원자값을 가지고 있도록 만듭니다. 예를들면 컬럼안에 배열이 들어갈 수 없다는 뜻입니다.

   2NF는 완전 함수 종속을 만족하도록 테이블을 분해하고 기본키의 부분집합이 결정자가 되어서는 안된다는 의미입니다.

   3NF는 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것. 이행적 종속은 A가 B를 가르키고 B가 C를 가르킬 때 A가 C를 가르키는 것을 의미합니다.

   마지막으로 BCNF는 모든 결정자가 후보키가 되도록 테이블을 분해하는 것입니다.


   ## 3. 트랜잭션이 무엇인지 설명하시고, 트랜잭션의 특성 4가지를 말씀해주세요.
   트랜잭션은 데이터베이스에서 실행하는 일련의 작업 단위로 CRUD작업 하나하나를 의미할 수도 있으며 여러개의 작업을 묶는 단위가 될 수도 있습니다.

   트랜잭션의 특성으로는 ACID로 불리는 4가지가 있는데요.
   첫번째는 원자성으로 트랜잭션의 결과로 모든 작업이 커밋되거나 모든 작업이 롤백되어야한다는 뜻입니다.
   두번째는 일관성으로 트랜잭션의 결과 값은 항상 일관되어야 한다는 뜻이고
   세번째는 격리성으로 하나의 트랜잭션이 다른 트랜잭션에 개입할 수 없다라는 뜻입니다.
   마지막으로 네번째 지속성은 트랜잭션이 성공적으로 마쳤을 때 데이터가 영구적으로 저장된다는 뜻입니다.

   ## 4. 커밋하고 롤백에 대해서 설명해주세요.
   커밋은 트랜잭션에서 수행한 작업들을 데이터베이스에 실제로 적용시키는 것이고 롤백은 트랜잭션에서 수행한 작업들을 어떠한 오류나 예외로 인해 다시 되돌리는 작업을 의미합니다. 위 두가지 방법으로 인해 데이터 무결성을 지킬 수 있습니다.

   ## 5. 트랜잭션의 격리수준에 대해서 설명해주세요.
   가장 엄격한 것부터 말씀드리면 Serializable, Repeatable Read, Read Commited , Read UnCommited 4가지가 있습니다. 첫번째인 Serializable은 가장 엄격한 수준으로 트랜잭션이 무조건 순차적으로 실행되게끔 하는 격리수준입니다. 동시에 접근할 수 없어 정확한 데이터를 보장하지만 동시에 처리하는 능력은 많이 떨어집니다. 두번째인 Repeatable Read는 MVCC와 언두로그를 통해 항상 일관된 읽기를 제공하는데요. 예를 들어 한 트랜잭션이 데이터를 업데이트하여 커밋되기 이전에 트랜잭션이 시작되면 커밋되어도 언두로그에 있는 데이터를 읽게 됩니다. 그리고 Read Commited는 커밋된 데이터를 읽을 수 있고요. Read Uncommited는 커밋되기 이전에 업데이트 쿼리만 나가더라도 업데이트 된 내역을 읽어올 수 있는 격리수준입니다. 최소 DBMS를 사용하면 Read Uncommited는 사용해야 안전합니다. 데이터의 부정합성이 일어날 수 있기 때문에

   ## 6. 락은 무엇이고 종류에 대해서 간단하게 말씀해주세요.
   락은 트랜잭션의 순차적인 처리를 목적으로 만들어졌습니다.
   종류로는 여러가지가 있는데 일단 위치에 따라 데이터베이스, 파일, 테이블, 레코드 락이 있고요. 보통 흔하게 많이 얘기하는 레코드 락중에 배타락, 공유락이 있습니다. 공유락의 경우에는 읽기 작업을 할 때 쓰이는 락으로 여러 트랜잭션에서 동시에 공유락을 걸 수 있습니다. 하지만 배타락의 경우 쓰기를 제한하는 락으로 배타락이 걸려있는 경우 배타락이 해제될 때 까지는 해당 리소스에 접근할 수 없습니다.

   ## 7. 교착 상태란 무엇인가요?
   교착상태는 각각의 레코드에 락이 걸려있는데 서로 락이 걸려있는 데이터를 참조해서 사용하려고 할 때 사용하지 못해서 영영 처리될 수 없는 상태를 의미합니다.