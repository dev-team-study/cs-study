# 3. 정규화, 트랜잭션

> 김영주

<br>

## 3.1. 이상현상

> `이상(Anomaly)`이란, 데이터베이스를 잘못 설계하여 불필요한 데이터 중복이 발생해 릴레이션에 대한 CRUD를 실행할 때 부작용이 나타나는 것을 말한다.

이상현상은 보통 동일한 데이터가 여러 번 중복되어 저장될 때 발생한다.

즉, 쉽게 생각해서 서로 분리되어야 하는 릴레이션이 합쳐져 있을 때 발생하는데, 이는 같은 부류의 데이터에 대해 연산을 할 때 관련없는 부류의 데이터에도 영향이 가기 때문이다.



1. **삽입 이상(Insertion Anomaly)**
   - 새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제
   - 고객 데이터를 삽입하고 싶은데, 이벤트 참여 내역도 같은 릴레이션에 있는 경우, 이벤트에 참여하지 않았더라도 고객 데이터를 삽입함으로써 pk에 해당하는 이벤트 참여 내역이 NULL이 되어버려 개체 무결성 제약 조건을 위반한다.
2. **갱신 이상(Update Anomaly)**
   - 중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
   - 고객 데이터는 똑같고, 이벤트 참여 내역만 다른 여러 튜플이 있는 경우, 한 튜플의 고객 데이터를 변경하면 다른 튜플들의 고객 데이터도 변경되어야 하지만 그렇지 못하기 때문에 데이터의 불일치가 발생한다.
3. **삭제 이상(Deletion Anomaly)**
   - 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제
   - 이벤트 참여 내역만 지우고 싶은데, 같은 릴레이션에 있기 때문에 고객 데이터도 함께 삭제된다.



이러한 이상현상을 해결하려면 어떻게 해야할까? 바로 정규화가 필요하다.

`정규화(Normalization)`란, 이상현상이 발생하지 않도록 **관련있는 속성들로만 구성하기 위해 릴레이션을 분해하는 것을 의미**한다.

<br>

## 3.2. 함수 종속

정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야 한다. 이때 관련성을 `함수적 종속성(Functional Dependency, FD)`이라고 한다.



하나의 릴레이션을 구성하는 속성들의 부분 집합을 X와 Y라고 할 때,

`"Y가 X에 함수적으로 종속되어 있다."`

= X가 Y를 함수적으로 결정한다.

= 모든 튜플에서 하나의 X값에 대한 Y값이 항상 하나이다.

= X -> Y (X를 결정자, Y를 종속자)



예를 들어 아래와 같은 고객 릴레이션이 있다고 가정한다.

| 고객아이디 | 고객이름 | 등급   |
| ---------- | -------- | ------ |
| apple      | 정소화   | gold   |
| banana     | 김선우   | vip    |
| carrot     | 고명석   | gold   |
| orange     | 김용욱   | silver |

- 고객아이디가 고객이름과 등급을 결정한다.
- 고객아이디에 따라 (고객이름, 등급)의 묶음이 확실히 결정되기 때문이다.
- 고객아이디가 아닌 고객이름과 같이 중복 가능성이 있는 것으로 종속성을 따져보면, 고객이름만 가지고는 나머지 데이터를 결정지을 수 없으므로 함수적 종속성을 만족하지 못한다.
- 따라서 고객아이디는 결정자가 되고, 고객이름과 등급은 종속자가 된다.



**함수적 종속성의 특징은 다음과 같다.**

- 단순히 튜플 데이터 만으로 종속성을 판단하지는 않는다. 해당 속성의 특성을 고려해야 한다.
  - 고객아이디의 특성 상, 중복이 될 수 없기 때문에 고객아이디가 정해지면 나머지 속성들의 값들도 분명하게 결정된다.

- 기본키나 후보키만 결정자가 될 수 있는 것은 아니다. 다른 속성 값을 유일하게 결정할 수 있다면 해당 속성은 결정자가 될 수 있다.
- 결정자와 종속자가 동일하거나, 결정자가 종속자를 포함하는 것처럼 당연한 함수 종속 관계는 고려하지 않는다.
  - 예) 고객아이디 -> 고객아이디
  - 예) {고객아이디, 이벤트번호} -> 이벤트번호



**함수적 종속성의 종류는 다음과 같다.**

- `완전 함수 종속(Full Functional Dependency, FFD)` : 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어 있으나, X 전체에 종속 된 것이지 일부분에 종속된 것이 아님을 의미한다. 일반적으로 함수 종속이라고 하면 완전 함수 종속을 의미한다.
- `부분 함수 종속(Partial Functional Dependency, PFD)` : 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미한다. 이때는 결정자가 여러 개의 속성들로 구성되어 있어야 한다.
- `이행적 함수 종속(Transitive Functional Dependency, TFD)` : 3개의 속성 집합 X, Y, Z에 대해 함수 종속 관계 X -> Y와 Y -> Z가 존재하면 논리적으로 X -> Z가 성립하는 것을 의미한다. (속성 집합 Z가 속성 집합 X에 이행적으로 함수 종속되었다고 표현)

<br>

## 3.3. 정규형

> `정규화(Normalization)` : 함수 종속성을 이용해 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해하여, 이상현상이 발생하지 않도록 하는 것

릴레이션이 정규화된 정도는 정규형(Normal Form, NF)으로 표현한다.

각 정규형마다 만족시켜야 하는 제약조건이 존재한다. 릴레이션이 특정 정규형의 제약조건을 만족하면 해당 정규형에 속한다고 표현한다.

정규형의 차수가 높아질수록 제약조건이 많고 엄격하다. 따라서 릴레이션 특성을 고려해서 적합한 정규형을 선택해야한다.



### 기본 정규형

> 일반적으로 기본 정규형은 지키도록 릴레이션을 정규화하는 것이 대부분이다.

1. **제 1 정규형 (1NF)** 
   - `릴레이션에 속한 모든 속성이 도메인의 원자 값으로만 구성되어 있으면 제 1 정규형에 속한다.`
   - 하나의 속성에 다중 값이 삽입될 수 없다.
   - 제 1 정규형을 만족해도 삽입, 갱신, 삭제 이상이 발생할 수 있다. 단순히 다중 값을 없애고 튜플을 추가한 것 뿐이라 데이터 자체의 중복을 막지는 못한다. (아직 부분 함수 종속성이 남아있기 때문) => 따라서 부분 함수 종속성을 없애기 위해 릴레이션을 분리해야 한다.
2. **제 2 정규형 (2NF)**
   - `릴레이션이 제 1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제 2 정규형에 속한다.`
   - 부분 함수 종속을 모두 제거하고 모든 속성이 기본키에 완전 함수 종속이 되도록 릴레이션을 분해한다. (이제 같은 부류에 맞게 테이블 분리)
   - 분해할 때의 주의점은, 분해된 릴레이션들을 자연 조인하여 분해 전의 릴레이션으로 다시 복원할 수 있어야 한다는 점이다. (= `무손실 분해`)
   - 제 2 정규형을 만족해도 함수 종속성이 여러 개라면 이상 현상이 발생할 수 있다. (무조건 기본키에 완전 함수 종속되어야 함)
     - 함수 종속성이 여러 개라는 것은, 결정자와 종속자가 여러 개라는 것이므로 부류가 두 개이상 생길 수 있게되기 때문이다.
3. **제 3 정규형(3NF)**
   - `릴레이션이 제 2 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형에 속한다.`
   - 이행적 함수 종속이 나타나는 이유는 하나의 릴레이션에서 함수 종속 관계가 여러 개 나타나기 때문이다. (기본키를 제외한 추가적인 함수 종속 관계가 있다면 일단 릴레이션을 쪼개야 하지 않을까 생각하면 좋을 것 같다.)
   - X -> Y -> Z 와 같이 이행적 함수 종속성이 나타나면, X -> Y 와 Y -> Z가 될 수 있도록 릴레이션을 두 개로 쪼개는 것을 권장한다.
4. **보이스/코드 정규형(BCNF)**
   - `릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 보이스/코드 정규형에 속한다.` (= 강한 제 3 정규형, Strong 3NF)
   - 결정자에 해당하는 속성이 후보키가 아닌 경우가 있으면, 보이스/코드 정규형을 만족하지 못하며 이상현상이 발생할 수 있다.
   - 후보키는 아니라서 중복이 발생 가능한 데이터이지만, 결정자이긴 해서 해당 값이 삽입/갱신/삭제 될 때 다른 값에도 영향을 주기 때문이다.
   - 따라서 모든 결정자가 후보키에 속할 수 있도록 릴레이션을 분해해야 한다.



### 고급 정규형

5. **제 4 정규형(4NF)**
   - `릴레이션이 보이스/코드 정규형을 만족하면서, 함수 종속이 아닌 다치 종속(Multi Valued Dependency, MVD)를 제거해야 제 4 정규형에 속한다.`
   - 릴레이션에 3개 이상의 컬럼이 있고, 하나의 컬럼이 나머지 두 개의 컬럼을 결정 짓는 상황에서, 나머지 두 개의 컬럼이 서로는 독립적이나 1:N의 관계를 만족하는 경우 `다치 종속`이라고 표현한다.
   - 보통 하나의 속성 도메인이 다중 값이 되지 않도록 분리하면서 많이 발생한다.
   - 서로 독립적인 두 컬럼이 1:N 관계를 형성하면서, 결정자 속성을 포함하여 튜플을 보았을 때 중복된 데이터가 존재한다.
   - 따라서 결정자 -> 하나의 컬럼, 결정자 -> 다른 하나의 컬럼 이 될 수 있도록 릴레이션을 분해해야 한다.
6. **제 5 정규형(5NF)**
   - `릴레이션이 제 4 정규형을 만족하면서, 후보키를 통하지 않는 조인 종속(Join Dependency, JD)를 제거해야 제 5 정규형에 속한다.`
   - 하나의 릴레이션을 여러 개의 릴레이션으로 무손실 분해했다가 다시 결합했을 때 불필요한 데이터가 추가되는 경우를 `조인 종속`이라고 표현한다.
   - 제 4 정규형을 만족하기 위해 무손실 분해 했던 릴레이션들을 다시 조인했을 때, 결정자의 값이 여러 번 등장하는 경우 결정자에 종속된 종속자들 간의 묶음이 생기면서 무손실 분해 되기 전의 모습과 달라지는 경우가 생긴다.
   - 이런 경우에는 종속자들 간에도 결정자와 종속자로 나누어 별도의 릴레이션으로 구분하여, 무손실 분해 이후 조인 했을 때 분해 전 데이터와 동일하게 맞출 수 있다.
   - 제 5 정규형은 너무 이상적인 정규화라 현실적으로는 어려운 부분이 존재한다.



<br>

## 3.4. 트랜잭션, ACID, COMMIT / ROLLBACK

### 트랜잭션

> 트랜잭션(Transaction)이란, 하나의 작업을 수행하는 데 필요한 데이터베이스의 연산들을 모아놓은 것이다.

- 데이터베이스의 논리적 작업 단위가 된다.
- 장애가 발생했을 때 데이터를 복구하는 작업의 단위가 된다.
- 작업 수행에 필요한 SQL 문들의 모임이다.



### ACID

> 트랜잭션의 네 가지 주요 특성

- `원자성(Atomicity)` : 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나, 하나도 실행되지 않아야 한다. (all or nothing)
  - 원자성을 보장하기 위해 DBMS는 `회복` 기능을 제공한다.
- `일관성(Consistency)` : 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관된 상태를 유지해야 한다.
  - 원자성을 보장하기 위해 DBMS는 `병행 제어` 기능을 제공한다.
- `격리성(Isolation)` : 현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없다.
  - 원자성을 보장하기 위해 DBMS는 `병행 제어` 기능을 제공한다.
- `지속성(Durability)` : 트랜잭션이 성공적으로 완료된 후 데이터베이스에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 한다.
  - 원자성을 보장하기 위해 DBMS는 `회복` 기능을 제공한다.



### COMMIT / ROLLBACK

> 트랜잭션의 수행과 관련하여 주로 사용되는 두 가지 연산

- `COMMIT` 연산 : 트랜잭션이 성공적으로 수행되었음을 선언 (작업 완료)
  - commit 연산이 실행된 후에야 트랜잭션의 수행 결과가 데이터베이스에 반영된다.
- `ROLLBACK` 연산 : 트랜잭션을 수행하는 데 실패하였음을 선언 (작업 취소)
  - rollback 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션이 수행되기 전의 상태로 돌아간다.



- 트랜잭션의 상태

  ![image](https://github.com/dev-team-study/cs-study/assets/49775540/944a08c7-9ebd-41b8-9574-33baa464dc1a)

  - `활동 상태` : 트랜잭션이 수행되기 시작하여 현재 수행 중인 상태
  - `부분 완료 상태` : 트랜잭션의 마지막 연산이 실행된 직후의 상태 (연산은 끝났는데, 아직 데이터베이스에 반영이 안된 상태)
  - `완료 상태` : 트랜잭션이 성공적으로 완료되어 commit 된 상태
  - `실패 상태` : 장애가 발생하여 트랜잭션 수행이 중단된 상태
  - `철회 상태` : 실패 상태 이후 rollback 하여 트랜잭션 이전의 상태로 복구한 상태



### 장애와 회복

데이터베이스는 기본적으로 아래와 같이 응용 프로그램과 메인 메모리, 그리고 디스크 간의 연산이 일어난다.

![image](https://github.com/dev-team-study/cs-study/assets/49775540/49ac27d8-be70-4168-b917-f4df9a1325f5)



**회복(Recovery)**이란, 데이터베이스에 장애가 발생했을 때 장애가 발생하기 전의 모순이 없고 일관된 상태로 복구시키는 것을 말한다.

- `덤프(dump)` : 데이터베이스 전체를 하루에 한 번 혹은 한달에 한 번과 같이 정해진 주기에 따라 다른 저장 장치에 복사하는 방법
- `로그(log)` : 변경 연산이 실행될 때마다 변경 이전 값과 이후 값을 별도의 파일에 기록하는 방법
  - `redo log (재실행 로그)` : 전반적으로 손상된 경우에 사용하며, 가장 최근에 저장한 복사본을 가져와 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 복구한다.
  - `undo log (취소 로그)` : 변경 중이었거나, 변경된 내용만 신뢰성을 잃은 경우에 사용하며, 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 원래의 상태로 복구한다.



<br>

## 3.5. 격리수준

`격리수준(Isolation Level)`이란, 다수의 트랜잭션이 동시에 처리될 때, 한 트랜잭션이 다른 트랜잭션의 변경 데이터를 볼 수 있게 허용하는지의 여부를 결정하는 수준을 말한다.

<img width="930" alt="image" src="https://github.com/dev-team-study/cs-study/assets/49775540/cccbd066-35f3-4aac-a831-a395df513875">

- READ UNCOMMITED
  - 가장 낮은 격리 수준
  - 아직 커밋하지 않은 데이터 조차도 볼 수 있는 격리 수준이다.
  - 다른 트랜잭션의 작업이 commit 혹은 rollback 되지 않아도 즉시 보인다.
- READ COMMITED
  - 커밋된 데이터만 볼 수 있는 격리 수준이다.
- REPEATABLE READ
  - 트랜잭션 번호를 참고하여, 자신보다 먼저 실행된 트랜잭션의 데이터만을 조회한다.
  - 데이터를 읽어올 때 언두 로그에 저장된 기존 데이터를 가져와 보여주는 격리 수준이다.

- SERIALIZABLE
  - 가장 엄격한 격리 수준
  - 트랜잭션을 순차적으로 진행시키는 격리 수준이다.
  - 여러 트랜잭션이 동일한 데이터에 동시 접근이 불가능 하여, 어떠한 데이터 부정합 문제도 발생하지 않는다.
  - 순차적 실행으로 인해 성능상 단점이 있다.



<br>

## 3.6. Lock

### 동시성 문제

DBMS는 여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러 개의 트랜잭션이 동시에 수행되는 병행 수행을 지원한다.

병행 수행되는 트랜잭션들이 동시에 같은 데이터에 접근하여 변경 연산을 실행하려고 하면 예상치 못한 결과가 나타난다. (동시성 문제)

- `갱신 분실(Lost update)` : 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화 되는 것을 말한다.
- `모순성(Inconsistency)` : 하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행하여 모순이 발생하는 것을 말한다.
- `연쇄 복귀(Cascading Rollback)` : 트랜잭션이 완료되기 전 장애가 발생하여 rollback 연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가 변경 연산을 실행한 또다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것을 말한다.



### 병행 제어와 Lock

이러한 병행 수행 과정에서의 동시성 문제를 해결하기 위해 DBMS는 병행 제어 기법을 따로 마련했다.

병행 제어 기법 중 가장 많이 사용되는 방식은 Lock을 이용한 잠금 방식이다.

- `잠금(Locking) 기법`이란, 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어하는 것을 말한다.
- 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 다른 트랜잭션이 접근하지 못하도록 상호 배제(Mutual Exclusion)한다.
- 잠금 단위는 데이터베이스 전체에서부터 작게는 속성에 이르기까지 다양하다. 단위가 커질수록 병행성은 낮아지지만 제어가 쉽고, 단위가 작아질수록 제어가 어렵지만 병행성은 높아진다.



데이터를 변경시키는 write 연산에 대해서는 독점권을 가져야 하지만, 데이터를 단순히 읽는 read 연산에 대해서는 동시에 실행해도 문제가 되지 않는다.

따라서 아래와 같이 같은 데이터에 트랜잭션들이 read 연산을 동시에 실행할 수 있도록 Lock을 구분한다.

- `공유락(Shared Lock)` : 한 트랜잭션이 데이터에 대해 공유락을 가지면, 다른 트랜잭션은 해당 데이터를 read 할 수 있지만 write는 할 수 없다. 그리고 다른 트랜잭션도 동시에 해당 데이터에 대한 공유락을 가질 수 있다.
- `배타락(Exclusive Lock)` : 한 트랜잭션이 데이터에 대해 배타락을 가지면, 다른 트랜잭션은 해당 데이터를 read 할 수도, write 할 수도 없다. 그리도 다른 트랜잭션도 동시에 해당 데이터에 대한 공유락, 배타락을 모두 가질 수 없다.



### Lock의 한계

공유락과 배타락을 이용해도 lock과 unlock의 시점에 따라 두 트랜잭션은 모순된 결과를 생성할 수 있다. (기본 잠금 규약의 한계)

따라서 **2단계 잠금 규약(2 Phase Locking Protocol, 2PLP)**을 통해 lock과 unlock을 2단계로 나누어 실행해야 한다.

- `확장 단계` : 트랜잭션이 lock 연산만 실행 가능하고, unlock 연산은 실행할 수 없는 단계
- `축소 단계` : 트랜잭션이 unlock 연산만 실행 가능하고, lock 연산은 실행할 수 없는 단계

그러면 한 트랜잭션이 lock을 시작하면 연산이 이루어지는 모든 데이터에 대해 unlock이 아닌 lock 연산을 할 수 밖에 없으므로(확장 단계)

다른 트랜잭션은 먼저 실행된 트랜잭션이 데이터를 unlock 하는 경우(축소 단계 경우)에만 이미 write가 끝난 데이터를 가져와 lock을 걸고 연산할 수 있게된다.

그래서 직렬 가능성이 항상 보장된다.



2단계 잠금 규약을 적용하면 트랜잭션의 직렬 가능성을 보장할 수는 있으나, 교착 상태(DeadLock)이 발생할 수 있다.

교착 상태란, 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 실행되기를 서로 기다리면서 트랜잭션 수행을 중단하고 있는 상태를 말한다.

이때는 트랜잭션이 더이상의 연산을 실행하지 못하고 한없이 기다리게 된다.



<br>

## 3.7. 질문 모음

1. 이상 현상의 종류와 그 내용에 대해 간단히 설명해주세요.
2. 함수적 종속성이 어떤 개념인지 간단히 설명해주세요.
3. 이행적 함수 종속이란 어떤 것을 의미하나요? 이를 어떤 정규형을 만족시켜서 어떤 방식으로 해결할 수 있을까요?
4. 트랜잭션의 4가지 특성에 대해 설명해주세요.
5. 보이스/코드 정규형을 만족하지 못해 발생하는 이상현상에 대해 어떤 것들이 있을까요?
6. 공유락과 배타락의 차이점에 대해 설명해주세요.
7. 교착 상태가 왜 발생하는지 간단히 설명해주세요.
