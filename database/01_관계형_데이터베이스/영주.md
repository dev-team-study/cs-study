# 1. 관계형 데이터베이스

> 김영주

<br>

## 1.1. 데이터베이스의 정의와 특징

`데이터베이스(Database, DB)` : 특정 조직의 여러 사용자가 공유하여 사용할 수 있도록 통합해서 저장한 운영 데이터의 집합

- 실시간 접근성(Read-time accessibility) : 사용자의 데이터 요구에 실시간으로 응답할 수 있어야 한다.
- 지속적인 변화(Continuous evolution) : 데이터의 삽입, 삭제, 수정을 통해 현재의 정확한 데이터를 유지해야 한다.
- 동시 공유(Concurrent sharing) : 여러 사용자가 동시에 이용할 수 있어야 한다.
- 내용으로 참조(Content reference) : 저장된 주소나 위치가 아닌, 데이터의 내용(값)으로 참조할 수 있어야 한다.

<br>

## 1.2. 데이터베이스 관리 시스템과 파일 시스템

### 파일 시스템의 한계

파일 시스템은 응용 프로그램별로 필요한 데이터를 별도의 파일로 관리하기 때문에 아래와 같은 한계가 있다.

- 같은 내용의 데이터가 여러 파일에 중복 저장되므로 공간의 낭비가 심하고, 한 쪽이 수정되었을 때 데이터 일관성을 보장하지 못한다.
- 응용 프로그램이 데이터 파일에 종속적이므로, 파일 구조가 변경되면 응용 프로그램도 함께 변경되어야 한다.
- 데이터 파일에 대한 동시 공유, 보안, 회복 기능이 부족하다.

<br>

### 데이터베이스 관리 시스템(DBMS)

> Database Management System

파일 시스템이 가진 데이터 중복성, 종속성의 한계를 극복하고 동시 공유, 보안, 회복의 기능을 제공하는 소프트웨어이다.

- 응용 프로그램마다 여러 파일로 중복된 데이터가 존재하던 것과 달리, 여러 응용 프로그램이 하나의 DB에 존재하는 데이터를 공유한다.
- 응용 프로그램들은 DBMS라는 인터페이스를 통해 데이터를 조작, 관리하므로 데이터 독립성이 확보된다.

<br>

### DBMS의 장점과 단점

1. **장점**
   - 데이터 중복을 통제할 수 있다.
   - 데이터 독립성이 확보된다.
   - 데이터를 동시 공유할 수 있다.
   - 데이터 보안이 향상된다.
   - 데이터 무결성을 유지할 수 있다.
   - 데이터 접근 방식, 형식, 구조 등을 표준화 할 수 있다.
   - 장애 발생 시 회복이 가능하다.
   - 응용 프로그램 개발 비용이 줄어든다.

2. **단점**
   - DBMS는 따로 설치해야 하므로, 비용이 많이 든다.
   - 백업과 회복 방법이 복잡하다.
   - 중앙 집중 관리로 인한 취약점이 존재한다. (DBMS에 대한 의존도가 높다.)

<br>

## 1.3. 관계형 데이터베이스의 개념과 구조

### 관계형 데이터베이스(Relational Database, RDB)

- 행과 열로 이루어진 테이블 형태로 데이터를 관리한다.

- 각 테이블은 기본키와 외래키를 통해 서로 연관관계를 맺을 수 있으므로, 관계형 데이터베이스라고 한다.

<br>

### 스키마(Schema)

데이터베이스에 저장되는 데이터 구조와 제약조건을 정의한 것

![image](https://github.com/dev-team-study/cs-study/assets/49775540/97c345de-991e-44b3-bdce-b1febefb6e45)

- `외부 스키마(External schema)` : 외부의 개별 사용자 관점에서 데이터베이스를 정의한 것을 말한다.
- `개념 스키마(Conceptual schema)` : 조직 전체의 관점에서 모든 사용자에게 필요한 데이터를 통합하여 데이터베이스의 구조를 정의한 것을 말한다.
- `내부 스키마(Internal schema)` : 데이터베이스가 내부 저장 장치에 실제로 저장되는 방법을 정의한 것을 말한다.

<br>

### 릴레이션(Relation)

관계 데이터 모델에서의 하나의 개체에 관한 데이터 (보통 테이블이라고 하지만, 엄연히 테이블과는 다른 개념)

필요한 모든 릴레이션의 스키마가 모여 하나의 데이터베이스 스키마를 이룬다.

- `열(Column) = 속성(Attribute) = 필드(Field)`
  - `도메인(Domain)` : 속성 하나가 가질 수 있는 모든 값의 집합 (아이디, 이름, 나이와 같은 것들은 값이 너무 다양해서 도메인을 정확히 지정할 수 없으므로, 데이터 타입이 도메인이 된다.)
  - `차수(Degree)` : 하나의 릴레이션에서 속성의 전체 개수 (모든 릴레이션은 최소 1 이상의 차수를 유지해야 한다.)
- `행(Row) =  튜플(Tuple) = 레코드(Record)`
  - `카디널리티(Cardinality)` : 하나의 릴레이션에서 튜플의 전체 개수

- `널(Null)` : 값이 없음 (0과 공백과는 다르다.)

<br>

### 키(Key)

릴레이션에 포함된 튜플들을 유일하게 구별해주는 역할로, 키 값이 같은 튜플은 존재할 수 없다.

- `슈퍼키(Super key)` : 유일성의 특성을 만족하는 속성 1개, 혹은 여러 개의 집합을 의미한다. **(유일성)**
- `후보키(Candidate key)` : 슈퍼키 중에서 가장 적은 속성으로 이루어진 키 **(유일성 + 최소성)**
  - `기본키(Primary key)` : 여러 후보키 중에서 기본적으로 사용할 키
  - `대체키(Alternate key)` : 기본키로 선택되지 못한 후보키
- `외래키(Foreign key)` : 어떤 릴레이션에 소속된 속성이 다른 릴레이션의 기본키가 되는 키 (다른 릴레이션의 대체키를 참조하는 것도 가능하나, 일반적으로 기본키를 참조)

<br>

**무결성 제약조건** : 데이터의 무결성을 보장하고, 상태를 일관되게 유지하기 위한 제약조건

> 무결성 : 데이터가 정확하고 유효하게 유지된 상태

- `도메인 무결성 제약조건` : 데이터는 반드시 해당 속성의 도메인에 맞는 값만을 가져야한다.
- `키 무결성 제약조건` : 릴레이션에서 최소한 하나의 키가 존재하여 튜플을 서로 구별할 수 있어야한다.
- `개체 무결성 제약조건` : 기본키를 구성하는 모든 속성은 널(Null) 값을 가질 수 없다.
  - 기본키를 구성하는 속성이 널 값을 가지면 튜플의 유일성을 판단할 수 없게되어 기본키의 목적을 상실한다.
- `참조 무결성 제약조건` : 외래키는 참조할 수 없는 값을 가질 수 없다.
  - 외래키가 참조하는 릴레이션의 기본키와 상관없는 값을 가지게 되면, 두 릴레이션을 연관시킬 수 없게된다. 따라서 외래키는 반드시 참조할 수 있는 값만 가져야한다.
  - 하지만 외래키가 널 값을 참조한다고 해서 무조건 제약조건을 위반했다고 볼 수는 없다.

<br>

## 1.4. 데이터베이스 언어 SQL

> Structured Query Language, 관계형 데이터베이스를 위한 표준 질의어

1. **`데이터 정의어(Data Definition Language, DDL)` : 테이블을 생성/변경/제거하는 기능을 제공한다.**

   - `CREATE` : 테이블 생성
   - `ALTER` : 테이블 변경
   - `DROP` : 테이블 삭제
   - `RENAME` : 테이블 이름 변경
   - `TRUNCATE` : 테이블 초기화
   - **참조 무결성 제약조건 관련 외래키 옵션**
     - ON DELETE와 ON UPDATE로 나눌 수 있다.
     - `NO ACTION` : 부모 데이터 변경/삭제 시, 참조하는 자식 데이터가 있으면 변경/삭제 불가능 (MySQL InnoDB 기준이며, 이때는 `RESTRICT` 제약조건과 동일)
     - `CASCADE` : 부모 데이터 변경/삭제 시, 참조하는 자식 데이터도 함께 변경/삭제
     - `SET NULL` : 부모 데이터 변경/삭제 시, 참조하는 자식 데이터를 널 값으로 변경
     - `SET DEFAULT` : 부모 데이터 변경/삭제 시, 참조하는 자식 데이터를 미리 지정한 기본 값으로 변경

2. **`데이터 조작어(Data Manipulation Language, DML)` : 데이터를 삽입/수정/삭제/조회하는 기능을 제공한다.**

   - `SELECT` : 데이터 조회

     - 쿼리 수행 순서

       ```
       1. FROM, JOIN, ON - 조회할 테이블 지정
       2. WHERE - 조건에 맞는 데이터 필터링 (SELECT 보다 먼저 실행되므로 컬럼의 별칭을 조건으로 사용 불가능)
       3. GROUP BY - 기준으로 그룹핑
       4. HAVING - 각 그룹에 적용되는 필터링
       5. SELECT - 조회 데이터 선택
       6. DISTINCT - 중복 제거
       7. ORDER BY - 정렬 (SELECT 보다 나중에 실행되므로 컬럼의 별칭을 정렬 기준으로 사용 가능)
       8. LIMIT - 개수 제한
       ```

   - `INSERT` : 데이터 삽입

   - `UPDATE` : 데이터 변경

   - `DELETE` : 데이터 삭제

3. **`데이터 제어어(Data Control Language, DCL)` : 데이터에 대한 접근 및 사용 권한을 부여/취소하는 기능을 제공한다.**

   - `GRANT` : 권한을 부여
   - `REVOKE` : 권한을 해제

4. **`트랜잭션 제어어(Transaction Control Language, TCL)` : 트랜잭션을 관리하고 제어하는 기능을 제공한다.**

   - `COMMIT` : 데이터의 삽입/변경/삭제 사항에 대해 정상적으로 적용 후 트랜잭션을 종료
   - `ROLLBACK` : 마지막 COMMIT 이후의 모든 삽입/변경/삭제 사항을 취소하여 원상 복구한 후 트랜잭션을 종료
   - `SAVEPOINT` : 특정 지점까지 ROLLBACK 할 수 있는 중간 지점을 설정

<br>

## 1.5. 질문 모음

1. **데이터베이스의 특징에 대해 아는대로 설명해주세요.**

   ```
   사용자의 데이터 요구에 실시간으로 응답할 수 있어야 합니다.
   데이터의 삽입, 삭제, 수정을 통해 현재의 정확한 데이터를 유지해야 합니다.
   여러 사용자가 동시에 이용할 수 있어야 합니다.
   저장된 주소나 위치가 아닌, 데이터의 내용으로 참조할 수 있어야 합니다.
   ```

2. **데이터베이스 관리 시스템과 파일 시스템은 어떤 차이가 있나요?**

   ```
   DBMS가 등장하기 이전에는 파일 시스템을 통해 데이터를 관리했습니다.
   하지만 파일 시스템은 각 응용 프로그램마다 데이터를 따로 관리하기 때문에 중복되는 데이터가 존재했습니다.
   또한, 파일의 구조가 바뀔 때마다 각 응용 프로그램은 거기에 맞춰 변경되어야 했으므로 데이터에 종속적이었습니다.
   이러한 데이터의 중복성, 종속성의 문제점을 해결하기 위해 DBMS라는 별도의 인터페이스를 두어 응용 프로그램과 데이터 사이에 별도의 레이어를 두었습니다.
   데이터들을 하나의 데이터베이스에서 관리함으로써 중복성을 해결하고, 데이터 구조의 변경에 따른 변화는 DBMS가 알아서 해줌으로써 종속성 문제도 해결하였습니다.
   ```

3. **관계형 데이터베이스의 개념과 장단점에 대해 설명해주세요.**

   ```
   관계형 데이터베이스란, 행과 열로 이루어진 테이블의 형태로 데이터를 저장하고 다른 테이블과 키를 통해 연관관계를 맺을 수 있는 데이터베이스 형태를 말합니다.
   
   행, 열, 테이블이라는 구조화 된 형태를 가지고 있으므로 데이터의 중복을 최소화하고 일관성을 유지할 수 있습니다.
   기본키와 외래키를 통해 데이터의 무결성을 유지할 수 있으며, 쉽게 연관관계도 맺을 수 있어 중복되지 않은 데이터들로 다양한 표현이 가능합니다.
   
   반면, 복잡한 데이터 표현을 위해 그만큼 복잡한 쿼리문을 작성해야 한다는 번거로움도 존재합니다. 여러 테이블의 연관관계 때문에 속도가 느려지는 단점도 있습니다.
   구조화 된 형태로 인해 데이터 구조 변화에 유연하지 못하여, 프로그램 개발 전 모델링에 시간과 에너지가 많이 소모됩니다.
   ```

4. **DDL, DML, DCL, TCL에 대해 각각 설명해주세요.**

   ```
   DDL은 데이터 정의어로써, 데이터베이스에 테이블을 생성, 변경, 삭제하는 기능을 제공하는 SQL 문법입니다.
   CREATE를 통해 테이블을 생성하고, ALTER를 통해 테이블 정보를 변경하고, DROP을 통해 테이블을 삭제할 수 있습니다.
   
   DML은 데이터 조작어로써, 데이터베이스 테이블에 새로운 데이터를 삽입하거나 조회, 변경, 삭제하는 기능을 제공하는 SQL 문법입니다.
   SELECT를 통해 데이터를 조회하고, INSERT를 통해 삽입하고, UPDATE를 통해 변경하고, DELETE를 통해 삭제할 수 있습니다.
   
   DCL은 데이터 제어어로써, 데이터베이스 접근 및 사용 권한을 부여하고 취소하는 기능을 제공하는 SQL 문법입니다.
   GRANT를 통해 권한을 부여하고, REVOKE를 통해 권한을 해제할 수 있습니다.
   
   TCL은 트랜잭션 제어어로써, 데이터베이스 트랜잭션을 관리하는 기능을 제공하는 SQL 문법입니다.
   COMMIT을 통해 트랜잭션을 종료하면서 해당 트랜잭션에서의 데이터 삽입, 수정, 삭제에 대해 정상적으로 반영할 수 있습니다.
   ROLLBACK을 통해 마지막 COMMIT 이후의 삽입, 수정, 삭제에 대해 취소하여 원래 상태로 복구한 후 트랜잭션을 종료할 수 있습니다.
   SAVEPOINT를 통해 중간에 특정 지점으로 ROLLBACK 할 수 있는 체크포인트를 설정할 수 있습니다.
   ```

5. **SELECT 문의 쿼리 수행 순서에 대해 아는대로 설명해주세요.**

   ```
   가장 먼저 FROM과 JOIN 절을 수행하여 데이터를 조회하고자 하는 테이블을 가져옵니다.
   이후 WHERE 절을 수행하여 해당 테이블에서 조건에 맞는 튜플들만 골라냅니다. 이때는 아직 SELECT 전이므로 별칭을 사용한 컬럼을 조건으로 쓸 수 없습니다.
   만약 GROUP BY와 HAVING 절이 있다면 그 다음에 실행됩니다. GROUP BY를 이용해 기준 별로 튜플들을 그룹화합니다. 
   이후 HAVING 절이 각 그룹에 적용되어 조건에 따라 튜플을 필터링합니다.
   이후 SELECT 절이 실행되어 지정한 컬럼대로 데이터를 조회합니다.
   만약 DISTINCT가 있다면 이 다음에 중복을 제거합니다.
   이후 ORDER BY가 실행되어 주어진 기준에 맞게 정렬합니다. 이때는 SELECT 이후이므로 별칭을 사용한 컬럼을 정렬 조건으로 쓸 수 있습니다.
   마지막으로 LIMIT이 실행되어 결과로 나타난 튜플들 중에서 지정한 갯수만 조회합니다.
   ```

6. **WHERE와 HAVING은 어떤 차이가 있나요?**

   ```
   WHERE와 HAVING은 둘 다 조건을 판별한다는 점에서 비슷합니다.
   하지만 WHERE는 GROUP BY 이전에 실행되어, 데이터 전체에 조건을 필터링합니다.
   반면 HAVING은 GROUP BY 이후에 실행되어, 나눠진 그룹 별로 조건을 필터링합니다. 따라서 HAVING은 GROUP BY가 없으면 쓸 수 없습니다.
   또한 HAVING은 집계 함수와 함께 사용 가능하지만 WHERE는 함께 사용할 수 없습니다.
   ```

7. **DELETE와 TRUNCATE와 DROP은 어떤 차이가 있나요?**

   ```
   세 명령어 모두 삭제하는 명령어라는 공통점이 있습니다.
   
   DELETE는 테이블의 데이터를 삭제하는 명령어 입니다. 
   이때 조건에 따라 특정한 튜플만 삭제할 수 있고 롤백도 가능합니다. 단, 데이터만 지우는 것이지 테이블 용량을 줄이지는 않습니다.
   
   TRUNCATE는 테이블을 생성했을 당시로 데이터를 초기화 하는 명령어 입니다. 
   DELETE FROM table 과 비슷한 기능을 하지만, 테이블의 용량까지 줄인다는 차이가 있습니다. 또한 롤백도 불가능합니다.
   
   DROP은 데이터가 아니라 테이블 자체를 삭제하는 명령어입니다. 롤백도 불가능합니다.
   ```

8. **DDL을 사용할 때의 주의점에는 어떤 것이 있을까요?**

   ```
   DDL의 경우 실행하는 순간 데이터베이스에 영구적으로 반영이 됩니다. 따라서 롤백을 할 수 없으니 사용에 주의해야 합니다.
   ```

9. **외래 키의 참조 무결성 제약 조건에 대해 설명해주세요.**

   ```
   참조 무결성 제약 조건이란 외래키는 반드시 참조할 수 있는 값 혹은 NULL을 참조해야 한다는 제약 조건입니다.
   외래키가 만약 존재하지 않는 값에 대해 참조한다면, 존재하지 않는 값으로는 연관관계를 맺을 수 없으므로 외래키 자체가 의미 없어집니다.
   다만 NULL을 참조하는 것은 가능한데, 이는 존재하지 않는 값을 참조하는게 아니라 아직 참조할 값이 정해지지 않았다는 의미이기 때문입니다.
   ```