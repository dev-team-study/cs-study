# 2. MySQL 아키텍처, Join

> 김영주

<br>

## 2.1. MySQL 엔진 아키텍처

![image](https://github.com/dev-team-study/cs-study/assets/49775540/d1197056-164b-4f92-a335-0b80ca91b6ac)

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분된다.

1. **MySQL 엔진**

   > 요청된 SQL 문장을 분석하거나 최적화하는 등, MySQL의 두뇌에 해당하는 부분이다.

   - 커넥션 핸들러
   - SQL 인터페이스
   - 쿼리 파서
   - 옵티마이저
   - 캐시 & 버퍼

2. **스토리지 엔진**

   > 실제 데이터를 디스크에 저장하거나, 디스크로부터 읽어오는 역할을 한다.

   - InnoDB
   - MyISAM

3. **핸들러 API**

   > MySQL 엔진에서 스토리지 엔진에게 데이터의 쓰기나 읽기를 요청할 때 사용하는 API이다.

   - MySQL 엔진과 스토리지 엔진 둘 사이의 데이터를 주고받을 수 있도록 해준다.

<br>

## 2.2. 쿼리 실행 구조

![image](https://github.com/dev-team-study/cs-study/assets/49775540/137b0256-95a9-4ad5-b340-3fa69bfa0e11)

1. **쿼리 캐시(Query Cache)**

   - SQL의 실행 결과를 메모리에 캐시하고, 동일 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환한다.
   - 속도가 매우 빨랐으나, 테이블의 데이터가 변경되면 캐시에서 변경 전 데이터를 모두 삭제해야 했기 때문에 동시성과 관련하여 성능 저하가 많이 발생했다.
   - 이러한 성능 저하와 많은 버그로 인해 `MySQL 8.0 부터는 제거`되었다.

2. **쿼리 파서(Query Parser)**

   ![image](https://github.com/dev-team-study/cs-study/assets/49775540/c3504ec5-fe8c-44e3-803c-34f857b5b9b0)

   - 요청으로 들어온 SQL 쿼리를 토큰(MySQL이 인식하는 최소 단위)로 분리해 파서 트리로 만든다.

   - 기본 SQL 문법과 관련된 오류를 이 과정에서 발견한다.

3. **전처리기(Preprocessor)**

   - 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
   - SQL 키워드를 제외하고, WHERE 절과 같은 곳에 들어가는 컬럼이나 테이블이 실제로 존재하는지, 접근할 수 있는 권한은 있는지 파악한다.

4. **옵티마이저(Query Optimizer)**

   - 요청으로 들어온 SQL 쿼리를 저렴한 비용으로 가장 빠르게 처리할지를 결정한다.
   - 최적화 작업 예시
     - 불필요한 조건 제거 및 복잡한 연산의 단순화
     - 여러 테이블의 조인이 있으면 어떤 순서로 테이블을 읽을지 결정
     - 각 테이블에서 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
     - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
   - 옵티마이저 종류
     - `비용 기반 최적화(Cost-based Optimizer, CBO)`
       - **현재 대부분의 DBMS가 선택하고 있는 방식**이다.
       - 쿼리를 처리하기 위한 여러 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 실행 계획별 비용을 산출한다.
       - 산출된 실행 방법 별로 비용이 최소로 소요되는 처리방식을 선택하여 쿼리를 실행한다.
     - `규칙 기반 최적화(Rule-based Optimizer, RBO)`
       - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다.
       - 따라서 항상 같은 쿼리에 대해서는 같은 실행 방법을 만드는데, 데이터의 분포도가 다양하므로 규칙 기반에는 한계점이 존재한다.

5. **실행 엔진(Query Execution Engine)**
   - 옵티마이저에 의해 만들어진 실행 계획에 따라 스토리지 엔진에게 요청하는 역할을 한다.
   - 임시 테이블을 만들거나, 레코드를 읽어오거나, 임시 테이블에 저장하거나 등등의 작업들을 실행 엔진은 핸들러 API를 통해 스토리지 엔진에게 요청한다.
6. **스토리지 엔진(Storage Engine)**
   - 실행 엔진의 핸들러 API 요청에 따라, 데이터를 디스크로 저장하거나 디스크로부터 읽어오는 작업을 수행한다.
   - MyISAM의 경우 MyISAM 스토리지 엔진, InnoDB의 경우 InnoDB 스토리지 엔진을 가리킨다.

<br>

## 2.3. MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동한다.

![image](https://github.com/dev-team-study/cs-study/assets/49775540/3db146d4-0c41-40e9-9031-a4629e03be8e)

1. **포그라운드(Foreground) 스레드**
   - 클라이언트 스레드라고도 하며, MySQL 서버에 접속된 클라이언트의 수만큼 존재한다.
   - 각 클라이언트 사용자가 요청하는 쿼리문을 처리한다.
   - 데이터를 MySQL의 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 읽어와서 작업을 처리한다.
   - `MyISAM`의 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 하지만, `InnoDB`의 테이블은 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.
2. **백그라운드(Background) 스레드**
   - InnoDB에서는 다음과 같은 작업들이 백그라운드 스레드로 처리된다.
     - 인서트 버퍼를 병합
     - 로그를 디스크로 기록
     - InnoDB 버퍼 풀의 데이터를 디스크에 기록
     - 데이터를 버퍼로 읽어옴
     - 잠금이나 데드락을 모니터링
   - 따라서, InnoDB는 쓰기 작업을 버퍼링하여 일괄 처리하고(쓰기 지연), 읽기 작업은 즉시 처리할 수 있다. MyISAM은 포그라운드 스레드가 쓰기 작업까지 하기 때문에 버퍼링 기능을 사용할 수 없다.

<br>

## 2.4. InnoDB 스토리지 엔진

> MySQL의 스토리지 엔진 중에서 가장 많이 사용되는 InnoDB 스토리지 엔진

![image](https://github.com/dev-team-study/cs-study/assets/49775540/fd788c98-cb71-4cd6-bdd2-e4c8349891a5)

1. **프라이머리 키에 의한 클러스터링**

   - 모든 테이블은 기본적으로 pk를 기준으로 클러스터링 및 정렬 되어 삽입된다. (클러스터링 인덱스는 pk에 대해서만 적용)
   - pk 값이 비슷한 레코드끼리 묶어서 저장한다. 그리고 하나의 묶음에서는 pk 값을 기준으로 정렬한다.
   - 따라서 pk 값에 의해 레코드의 저장 위치가 결정되며 pk값이 변경되면 물리적인 저장 위치도 바뀐다.
   - 이러한 이유로 쓰기(write) 작업에서는 다른 스토리지 엔진에 비해 상대적으로 느리다. 하지만 읽기(read) 작업에서 매우 빠르다.
   - **만약 pk가 없다면 아래와 같은 우선순위대로 pk를 대체할 컬럼을 선택한다.**
     1. pk가 있다면 pk 선택
     2. NOT NULL 옵션의 UNIQUE INDEX 중에서 첫 번째 인덱스
     3. 자동으로 Unique한 값을 가지도록 증가되는 컬럼을 내부적으로 추가 후 클러스터링 키로 선택
        - 이 경우에는 해당 키는 사용자에게 노출되지 않으며, 쿼리문에서 사용할 수 없다.
   - 모든 세컨더리 인덱스는 레코드의 주소 대신, pk 값을 논리 주소로 사용한다.
     - MyISAM의 경우, 레코드의 주소를 ROWID로 사용하여 해당 값을 이용해서 데이터 레코드를 찾는다. 따라서 MyISAM은 pk나 세컨더리 인덱스나 차이가 없다.
     - 반면 InnoDB의 경우, 세컨더리 인덱스를 검색해서 레코드의 pk 값을 먼저 확인하고, pk 인덱스를 검색해서 최종 데이터 레코드를 가져온다. 사실상 추가적인 과정이 있는 거지만, 그렇게 성능 저하가 발생되지도 않는다.

2. **외래 키 지원**

   - 외래 키에 대한 지원은 InnoDB 스토리지 엔진에서만 지원한다. MyISAM에서는 지원하지 않는다.
   - 외래 키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성된다.

3. **MVCC(Multi Version Concurrency Control)**

   - 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 잠금을 사용하지 않는 일관된 읽기를 제공하는데 목적이 있다.

   - InnoDB에서는 `언두 로그(undo log)`를 이용해 해당 기능을 구현한다.

     ![image](https://github.com/dev-team-study/cs-study/assets/49775540/74ac7b9d-b8f6-4130-9f6d-2acc5c9cd51e)

   - UPDATE 문이 실행되면 InnoDB의 버퍼 풀은 새로운 값으로 변경되고, 기존 값은 언두 로그에 복사된다.

   - 아직 COMMIT, ROLLBACK이 되지 않은 상황에서 해당 레코드를 조회하면 버퍼 풀이 아닌 언두 로그의 기존 값을 조회한다.
     (이는 격리 수준이 READ_COMMITED 이상일 때만 해당한다.)

   - 즉, 이런 식으로 하나의 레코드에 대해 여러 버전이 유지되고, 필요에 따라 다른 버전을 사용하는 것이 `MVCC`이다.

   - `COMMIT`을 하면 버퍼 풀에 있는 변경 내역을 디스크에 반영하여 영구적으로 만든다. 이 때, 언두 로그의 데이터가 바로 삭제되지는 않고, 기존 데이터를 필요로 하는 트랜잭션이 없을 때 삭제된다.

   - `ROLLBACK`을 하면 언두 로그에 있는 기존 데이터를 버퍼 풀로 다시 복구하고, 언두 로그의 데이터를 삭제한다.

4. **자동 데드락 감지**
5. **자동화된 장애 복구**

<br>

## 2.5. Join

![image](https://github.com/dev-team-study/cs-study/assets/49775540/1157e156-92c3-47be-acc7-df22ba4e27a9)



`Join`이란 DB 내의 여러 테이블에서 가져온 레코드를 조합하여 하나의 테이블이나 결과 집합으로 표현하는 것을 말한다.

- **Inner Join**

  ```sql
  SELECT <열 목록>
  FROM <기준 테이블>
      INNER JOIN<참조할 테이블>
      ON <조인 조건>
  WHERE 검색조건;
  ```

  - 조인하는 테이블의 ON 절의 조건이 일치하는 결과만 출력한다.
  - 교집합에 해당한다.

- **Outer Join**

  ```sql
  SELECT <열 목록>
  FROM <첫 번째 테이블(LEFT)>
      <LEFT | RIGHT | FULL> [OUTER] JOIN <두 번째 테이블(RIGHT)>
      ON <조인 조건>
  WHERE 검색조건;
  ```

  - `Left Join` : 왼쪽 테이블을 기준으로 모든 레코드가 표시되고, 오른쪽 테이블에 없는 내용은 NULL로 표시된다.
  - `Right Join` : 오른쪽 테이블을 기준으로 모든 레코드가 표시되고, 왼쪽 테이블에 없는 내용은 NULL로 표시된다.
  - `Full Join` : 왼쪽, 오른쪽 테이블을 기준으로 모든 레코드가 표시된다. 서로 없는 내용은 NULL로 표시된다.
    - MySQL은 Full Join에 대한 문법이 따로 없기 때문에, UNION을 사용해서 Full Join을 구현해야한다.

<br>

## 질문 모음

1. **MySQL 아키텍처에서 핸들러 API의 역할에 대해 설명해주세요.**

2. **MySQL의 쿼리 실행 구조에 대해 설명해주세요.**

3. **MySQL 엔진의 옵티마이저가 어떤 역할을 하는지 설명해주세요.**

4. **InnoDB와 MyISAM 엔진의 차이점을 설명해주세요.**

   ```
   - InnoDB는 트랜잭션 처리와 대용량의 데이터를 다루는 부분에서 효율적이고, MyISAM은 트랜잭션이 필요없고 read-only가 많으면 효율적입니다.
   - InnoDB는 pk 클러스터링 인덱스, 외래키, 트랜잭션, 레코드 락, commit/rollback, MVCC 등을 제공합니다.
   - MyISAM은 트랜잭션을 지원하지 않고, 테이블 락을 제공합니다. 테이블에 row count 정보를 가지고 있으므로, select count와 같은 조회에서 빠른 속도를 지원합니다.
   ```

5. **MySQL에서 MVCC 모델이 무엇인지 간단히 설명하고, 장점과 단점에는 어떤 것이 있는지 말씀해주세요.**

   ```
   MVCC는 다중 버전 동시성 제어로써, MySQL의 InnoDB 스토리지 엔진에서 동시성을 관리할 때 사용하는 모델입니다.
   기존의 락만으로 동시성을 관리했을 때의 데이터 일관성 문제를 해결하기 위해 등장했습니다.
   InnoDB에서는 레코드의 변경 사항이 바로 디스크에 반영되지 않고 버퍼 풀에 먼저 반영되는데, 이때 변경 전의 데이터를 언두 로그라는
   별도의 공간에 저장합니다. 그리고 해당 레코드를 다른 트랜잭션이 접근하면 변경된 데이터가 아닌 언두 로그에 있는 기존의 데이터를 읽습니다.
   이런 식으로 락을 사용하지 않고 하나의 레코드에 여러 버전을 생성해서 서로 다른 트랜잭션에서의 데이터 일관성을 지키는 것이 MVCC입니다.
   
   MVCC의 장점으로는 서로 다른 트랜잭션에 각각의 스냅샷을 제공하여 동시성에 대해 손쉽게 관리할 수 있다는 점입니다.
   이때 락을 사용하지 않으므로 성능 상으로도 이점이 있습니다.
   
   반면 단점으로는 여러 버전을 유지해야 하므로 그만큼 오버헤드가 증가한다는 점입니다. 그리고 COMMIT 된 이후 어느 시점에서
   언두 로그에 있는 기존 데이터를 삭제할 것인지에 대한 메커니즘이 필요한데 이는 시스템의 복잡도를 높입니다.
   마지막으로 MVCC를 사용하더라도 READ UNCOMMITED 격리 수준에서는 변경사항이 COMMIT 되었든 안되었든, 변경된 이후의 데이터를
   읽기 때문에, 언두 로그가 아닌 항상 버퍼 풀에서 데이터를 읽어올 수 있습니다. 즉 격리 수준에 따라 오히려 비효율을 야기할 수도 있습니다.
   ```

6. **Inner Join과 Outer Join의 차이점을 설명해주세요.**

7. **Outer Join의 종류와 각각의 특징을 설명해주세요.**

8. **Join에서 ON과 WHERE의 차이점을 설명해주세요.**

   ```
   두 테이블을 조인할 때, 어떤 조건 A를 만족하는 레코드를 가져오고 싶다고 가정하겠습니다.
   이 조건 A를 ON절에 놓을 때와, WHERE 절에 놓을 때, 두 경우로 살펴볼 수 있습니다.
   
   먼저 조건 A를 ON 절에 놓게 되면, 두 테이블에서 조건 A에 맞는 레코드들만을 대상으로 데이터를 가져오게 됩니다.
   OUTER 조인에 대해서는 조건 A에 맞지 않는 레코드에 대해서 NULL 값이 들어 있는채로 나타날 수 있습니다.
   
   반면 조건 A를 WHERE 절에 놓게 되면, ON 절 이후에 실행되므로, 두 테이블에서 조건 A와 상관없이 일단 조인을 합니다.
   그 이후에 조인된 테이블을 대상으로 WHERE에 의해 조건 A에 맞는 레코드가 필터링 됩니다.
   따라서 조건 A에 맞지 않는 레코드가 아예 나타나지 않습니다.
   ```