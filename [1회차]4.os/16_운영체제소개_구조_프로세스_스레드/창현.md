# 1. 운영체제 소개
  ## 1.1 운영체제 필요성
  - 사용 규칙의 역할을 수행
    - 초기 컴퓨터는 정해진 계산만 수행했기 때문에 특별한 사용 규칙이 없었음
    - 점점 발전하며 여러 작업을 동시에 할 수 있는 컴퓨팅 환경이 조성되면서 사용 규칙이 필요해짐 -> 운영체제로 해결
  - 새로운 기능의 추가나 성능 향상을 위해
    - 운영체제가 없는 기계는 만들 당시에 구현한 기능 외에 다른 기능을 추가하거나 성능을 향상할 수 없기 때문에 설계한 대로만 사용 가능
    - 운영체제로 새로운 기능의 추가나 성능의 변경이 가능
  - 자원 보호
    - 직접 적인 접근을 막고 운영체제를 통해 관리
  - 편리한 인터페이스 제공

  ## 1.2 운영체제 정의
  - 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 일종의 소프트웨어
  ## 1.3 운영체제 역할
  - 자원 관리(효율성)
    - 여러 응용 프로그램이 자원을 요청하면 적절한 순서로 배분하고 회수하여 자원을 효율적으로 관리
  - 자원 보호(안정성)
    - CPU, 메모리 등에 대한 사용자와 응용 프로그램의 직접 접근을 막음
  - 하드웨어 인터페이스 제공(확장성)
    - 마우스, 키보드 등을 복잡한 과정 없이 사용할 수 있도로 하드웨어 인터페이스를 제공
  - 소프트웨어 인터페이스 제공(편리성)
    - 운영체제를 편리하게 사용하기 위해 제공되는 것으로, 대부분의 작업을 마우스로 수행하거나 스마트폰의 터치스크린 등을 통해 제공되는 기능을 말함
# 2 운영체제 구조
  ## 2.1 커널
  - 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 핵심적인 기능을 수행
  - 운영체제의 성능은 커널이 좌우하는데, 커널 내부에는 시스템 호출과 드라이버가 있음

  ## 2.2 이중모드
  - CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분
  - 사용자 모드: 운영체제 서비스를 제공받는 것이 아닌 응용 프로그램에서의 동작 처리를 이야기 함
  - 커널 모드: 운영체제 서비스를 제공받을 수 있는 것으로 커널 영역에 접근하여 자원에 접근하는 명령어를 사용할 수 있음
    - ex) 자바에서 Thread를 생성할 때 자바 코드로 동작하며 유저모드로 돌다가 native 코드를 만나면 커널 모드로 전환되어 Thread를 생성해준다.

  ## 2.3 시스템 호출
  - 커널이 자신을 보호하기 위해 만든 인터페이스
  - 자원에 대한 직접 접근을 차단하기 때문에 자원을 이용하기 위한 시스템 호출이라는 인터페이스를 필요로 함
  - ex) 응용 프로그램을 통해 파일을 저장하려고 한다면, 직접 하드디스크에 저장하는 것이 아닌 커널을 통해서 요청해야함
    1. 파일을 저장하려고 하는 코드가 실행 됨(유저 모드)
    2. 하드웨어의 자원에 접근이 필요하므로 운영체제에게 요청을 보내어 커널 모드로 전환
    3. 운영체제 내의 디스크에 파일을 저장하는 시스템 호출을 발생시켜 하드웨어의 자원에 접근
    4. 저장이 끝나면 다시 유저 모드로 변경

  ## 2.4 드라이버 
  - 시스템 호출과 달리 응용 프로그램이 아닌, 하드웨어의 인터페이스 역할을 함
  - 커널 내부의 드라이버는 간단한 입출력 정도의 입력만 제작하고 개발 하드웨어의 특성을 반영한 소프트웨어(디바이스 드라이버)는 추가적인 드라이버와 함께 실행되도록 함

  ## 2.5 커널의 구성
  ### 2.4.1 커널의 역할
  1. 프로세스 관리: 프로세스에 CPU를 배분하고 작업에 필요한 환경을 제공
  2. 메모리 관리: 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공
  3. 파일 시스템 관리: 데이터를 저장하고 접근할 수 있는 인터페이스를 제공
  4. 입출력 관리: 필요한 입력과 출력 서비스를 제공
  5. 프로세스 간 통신 관리: 공동 작업을 위한 각 프로세스 간 통신 환경을 지원
   
  ### 2.4.2 단일형 구조 커널
  - 초창기 운영체제 구조로, 기능들이 단일의 모듈로 구성되어 있음
  - MS-DOS, VMS, 초기 UNIX
 
  #### 장점
  - 모듈 간의 통신 비용이 줄어 효율적인 운영이 가능

  #### 단점
  - 버그나 오류를 처리하기 어려움
  - 기능 간 상호 의존성이 높아 작은 결함이 시스템 전체로 확산 가능
  - 다양한 환경의 시스템에 적용하기 위해서는 수정이 필요한데 단일형 구조의 경우 수정이 어려워 이식성이 낮음
  - 현대의 운영체제는 매우 크고 복잡해 단일형으로 구현하기 어려움
  ![image](https://velog.velcdn.com/images%2Fdddooo9%2Fpost%2Fe28d7177-1c09-408a-b36a-27508e2ed9b9%2Fimage.png)

  ### 2.4.3 계층형 구조 커널
  - 단일형 구조 커널의 발전된 형태로 비슷한 기능의 모듈을 하나의 계층으로 묶어 계층 간의 통신을 통해 운영체제를 구현
  - Window를 비롯한 현대의 운영체제는 대부분 이 구조로 구현
  - 계층형 구조 커널은 버그나 오류가 생길 경우 해당 계층만 수정하면 되기 때문에 디버깅이 쉬움
  ![image](https://velog.velcdn.com/images%2Fdddooo9%2Fpost%2F13671702-c108-47a9-8fc8-6fb7fa97e08e%2Fimage.png)

  ### 2.4.4 마이크로 구조 커널
  - 마이크로 구조 커널은 계층형 구조의 접근 방식과 반대로 개발된 커널로 가장 기본적인 기능만 제공
  - 많은 기능이 사용자 영역에 구현되어 있으며, 각 모듈간의 정보 교환은 프로세스 간 통신을 통해 이루어짐
  - OS X와 IOS의 커널로 사용된 마하가 있음
  ![image](https://velog.velcdn.com/images%2Fdddooo9%2Fpost%2Ffd9723e5-5a66-435b-80a4-b6e24d4605be%2Fimage.png)

  - 각 모듈이 독립적으로 작동하기 때문에 하나의 모듈에 문제가 있어도 전체 운영체제가 멈추지 않음
  - 커널이 가벼워 CPU 용량이 작은 시스템에도 적용이 가능

# 3. 프로세스
  ## 3.1 프로세스 개념
  - 프로세스는 일련의 작업 단위
  - 프로그램은 파일이 저장장치에 저장되어 있지만 메모리에는 올라가지 않은 정적인 상태이며, 이러한 프로그램을 실행시켜 운영 체제로부터 CPU를 할당받고 실행되고 있는 상태를 바로 프로세스라고 함
  - 프로세스는 실행 중인 프로그램이라고 말함

  ## 3.2 프로세스의 구조
  - 코드 영역: 컴파일된 소스 코드가 저장되는 영역
  - 데이터 영역: 전역변수/초기화된 데이터가 저장되는 영역
  - 스택 영역: 임시데이터(함수 호출, 로컬 변수 등)가 저장되는 영역
  - 힙 영역: 코드에서 동적으로 생성되는 데이터가 저장되는 영역

  ## 3.3 프로세스 상태
  ### 3.3.1 New(생성 상태)
  - 프로세스가 생성중인 상태
  - 프로세스가 되기 위해 필요한 여러 작업(PCB 생성)과 장기 스케줄러의 승인 등의 과정을 밟는 상태
  ### 3.3.2 Ready(준비 상태)
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
  - CPU가 하나인 경우 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있어 순서가 올 때까지 대기
  - CPU 자원을 어떤 프로세스에게 줄 지(dispatch)에 대한 알고리즘이 여럿 있음
  ### 3.3.3 Running(실행 상태)
  - CPU를 얻어 실제 작업을 수행하는 상태
  - 주어진 시간 안에 작업을 끝내지 못하면 프로세스는 다시 준비상태로 돌아감
  - 실행 상태의 프로세스가 CPU를 반납하는 경우는 Timeout, 시스템 호출 등과 같은 인터럽트가 발생하는 경우
  ### 3.3.4 Terminated(완료 상태)
  - 프로세스가 작업을 마치면 완료 상태로 변경됨
  - 해당 프로세스의 코드와 사용했던 데이터를 메모리에서 삭제하고 PCB를 폐기
  ### 3.3.5 Wait, Blocked(대기 상태)
  - 작업의 효율성을 위해 운영체제는 대기상태를 추가 함
  - CPU를 주어도 당장 작업을 수행할 수 없는 상태
  - 실행 상태의 프로세스가 입출력을 요구한 경우(입출력을 요구한 경우 실행 중인 상태의 프로세스를 대기시키고 요청 프로세스를 실행)

  ## 3.4 프로세스 제어 블록
  - CPU가 프로세스를 실행할 때 필요한 중요 정보들을 보관하는 자료구조
  - 모든 프로세스는 고유의 PCB를 가짐
  - 포인터: 준비 상태나 대기 상태의 프로세스 PCB는 큐에 담겨 관리 됨
  - 프로세스 상태: 프로세스의 상태 정보를 저장(생성, 준비, 실행, 대기, 완료)
  - 프로세스 구분자: PID 메모리에 올라와있는 프로세스를 구별하기 위한 ID값
  - 프로그램 카운터: 다음에 실행될 명령어의 위치를 가리키는 값
    - 예를 들어 프로세스 컨텍스트 스위칭을 한다고 했을 때 두 개의 프로세스를 쪼개서 사용하는데 어디까지 실행되었는지 모르면 처리가 안됨. 그때 어디부터 처리해야하는지 알려주는 것
  - 프로세스 우선순위: 프로세스 간 중요도, 실행순위
  - 각종 레지스터 정보: 이전 작업을 통해 결과물들이 어떻게 나왔었는지에 대한 정보
  - 메모리 관리 정보: 프로세스가 어디 메모리에 올라와있는지에 대한 정보

  ## 3.5 프로세스 문맥 교환(컨텍스트 스위치)
  - CPU를 차지하고 있던 프로세스가 나가고 준비상태에 있던 프로세스를 새롭게 받아들이는 작업을 의미
  - 프로세스가 할당된 시간을 전부 사용한 Timeout이나 I/O요청 System call같은 상황에서 일어남
  - 주의점
    - 프로세스 A에서 인터럽트 발생 혹은 시스템 콜이 일어나 유저모드에서 커널 모드로 넘어간 뒤 다시 프로세스 A로 복귀하면 이는 문맥교환이라 부르지 않음

  ### 3.5.1 문맥 교환 흐름
  1. p1 프로세스가 실행하다가 인터럽트가 발생하여 CPU 자원 할당으로부터 취소되어야 함
  2. 지금까지 작업했던 내용을 PCB에 저장
  3. 다음으로 실행시킬 p2 프로세스가 CPU 할당을 받아서 작업을 시작
  4. p2가 쫓겨날 때가 되면 p1 프로세스가 다시 차지해서 작업

# 4. 스레드
  ## 4.1 스레드 개념
  - 하나의 프로세스 내에서 동시에 진행되는 작업 갈래, 흐름의 단위를 의미
  - 예를 들어, 브라우저가 실행 되면 프로세스 하나가 생성되는데 이때 웹 서핑을하며 다운로드도하고 웹 게임도 할 수 있음 -> 하나의 브라우저라는 프로세스에서 여러개의 기능이 동작
  - 프로세스가 생성되면 무조건 하나의 스레드가 생김

  ## 4.2 멀티스레드의 구조
  ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FxovWl%2Fbtq7EfJF7KR%2FfJcWmT7sWRksKUCyngtq30%2Fimg.png)
  - 코드 영역, 데이터 영역, 힙 영역만 공유하고, 나머지 stack 영역만 따로 사용


  ## 4.3 멀티스레드의 장단점
  **장점**
  1. 스레드는 프로세스보다 가벼움
    - 프로세스보다 용량이 가벼움.
  2. 자원의 효율성
    - 멀티 스레드는 하나의 프로세스 내에서 여러 개의 스레드를 생성하기 때문에, heap 영역과 같은 공유 메모리에 대해 스레드 간에 자원 공유가 가능
  3. 컨텍스트 스위칭 비용 감소
    - 이미 힙 영역, 코드, 데이터 영역을 공유하고 있어 스택과 레지스터 일부만 변경하면 되기때문에 비용이 저렴
  4. 응답시간 단축
    - 스레드 간의 통신이나 자원 공유가 더욱 용이하여 컨텍스트 스위칭 비용 감소로 인한 응답시간 단축

  **단점**
  1. 안정성 문제
   - 멀티 프로세스 모델에서는 각 프로세스가 독립적으로 동작해서 하나의 프로세스에서 문제가 발생해도 다른 프로세스들은 영향을 받지 않기 때문에 죽지 않고 돌지만 멀티 스레드 모델에서는 하나의 스레드에서 문제가 발생하면 다른 스레드들도 영향을 받아 전체 프로그램이 종료

  2. 동기화로 인한 성능 저하
   - 멀티 스레드 모델은 여러 개의 스레드가 공유 자원에 동시에 접근할 수 있어서 동기화 문제가 발생할 수 있음
   - 만약 동기화를 위해서 순차적으로 접근하도록 통제할 경우 성능이 저하 됨.
     - 임계영역(공유 자원을 접근하는 코드 영역)에 대해 뮤텍스나 세마포어를 이용
       - 뮤텍스: 공유 자원에 대해 락을 거는 방법
       - 세마포어: 동시에 접근 가능한 스레드의 개수를 지정, 1이면 뮤텍스랑 동일한 역할

  3. 데드락
   - 다수의 프로세스나 스레드가 서로 자원을 점유하고, 다른 프로세스나 스레드가 점유한 자원을 기다리는 상황에서 발생하는 교착 상태를 의미

  4. 컨텍스트 스위칭 오버헤드
   - 어쨌든 컨텍스트 스위칭 자체는 비용 자체를 무시할 수는 없음.
   - 스레드가 많으면 많아질 수록 컨텍스트 스위칭이 많이 일어나기 때문에 무작정 좋다고만 볼 수 없음

  ## 4.4 멀티 프로세스 VS 멀티 스레드
  - 멀티 프로세스는 하나의 프로세스가 망가지더라도 다른 곳에 영향을 미치지 않지만 멀티 스레드는 스레드에 문제가 생기면 전체가 망가질 수 있음
  - 멀티 프로세스는 컨텍스트 스위칭시 메모리 영역 모두를 교체해야하지만 멀티 스레드는 스택과 레지스터 일부만 변경하면 되서 컨텍스트 비용이 적음

# 5. 프로세스 -> 스레드 ... 변화 과정
  1. 단일 프로세스: 하나의 프로그램만 실행
      - CPU 사용률이 좋지 않음
        - 한 프로세스가 실행되고 있을 때 CPU를 사용하는 작업을 하다가 IO 작업을 만나 IO 작업을 하느라 CPU는 놀고 있음
  2. 멀티 프로그래밍: 여러 개의 프로그램을 메모리에 올려두고 동시에 실행
      - CPU 사용률을 극대화 시키는데 목적
      - CPU 사용 시간이 길어지면 다른 프로세스는 계속 대기
        - p1 프로그램이 시간을 많이 잡아먹으면 p2는 p1이 끝날때까지 기다렸다가 이후에 실행 가능
      - 해결책: 프로세스는 한번 CPU를 사용할 때 아주 짧은 시간(퀀텀)만 CPU에서 실행되도록 하자!
  3. 멀티태스킹: 프로세스가 한 번 CPU를 사용할 때 아주 짧은 시간(퀀텀)만 CPU에서 실행되도록 하는 방법
      - 여러 프로그램을 실행시킬 때 짧게 나누어 두 개가 번갈아가면서 실행될 수 있도록 함(컨텍스트 스위칭)
      - 프로세스의 응답 시간을 최소화 시키는데 목적
      - 동시에 실행되는 것 처럼 느껴지게 함
      - 아쉬움: 하나의 프로세스가 동시에 여러 작업을 수행하지는 못함 
        - 여러 프로세스를 이용하면 되지 않을까?
          - 그럴 경우 프로세스끼리의 데이터 공유가 어렵고, 프로세스의 컨텍스트 스위칭 작업 자체가 무거움
          - 한 프로세스 안에서 여러 개의 기능을 실행하고 싶음 -> 스레드
  4. 스레드: 
      - 프로세스는 한 개 이상의 스레드를 가질 수 있음
      - CPU에서 실행되는 단위
      - 같은 프로세스의 스레드들끼리는 컨텍스트 스위칭은 가벼움
      - 자신들이 속한 프로세스의 메모리 영역을 공유

  5. 멀티스레드: 하나의 프로세스가 동시에 여러 작업을 실행하는데 목적
      - 확장된 멀티태스킹: 여러 프로세스와 여러 스레드가 아주 짧게 쪼개진 CPU time을 나눠 갖는 것
  
  6. 멀티프로세싱: 두개 이상의 프로세서나 코어를 사용하는 경우
