# 1. 메모리 관리
- 다중 프로그래밍 컴퓨터에서 운영 체제는 메모리의 일부에 상주하고 나머지는 여러 프로세스에서 사용 됨
- 서로 다른 프로세스 간에 메모리를 세분화하는 작업을 메모리 관리라고 함
- 운영체제에서 프로세스 실행 중에 주 메모리와 디스크 간의 작업을 관리하는 방법
- 주된 목표
  - 메모리를 효율적으로 사용하는 것
- 메모리 란
  - 컴퓨터에서 정보를 처리하기 위해서 일시적으로 정볼르 보관하는 기억장치를 이야기 함
  - 프로그램 실행시 필요한 주소, 정보들을 저장하고 가져다 사용할 수 있게 만드는 공간

  ## 1.1 메모리 관리 필요성
  - 다중 프로그래밍 환경에서 여러 개의 프로세스가 실행되면서 한정된 메모리를 효율적으로 사용해야했음

  🤔 왜 메모리를 운영체제가 관리하는가?
  - 각각의 프로세스는 독립된 메모리 공간을 갖고, 운영체제 혹은 달느 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있음
  - 운영체제만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않기 때문에 운영체제에서 관리

  ## 1.2 메모리 연속할당 기법
  - 프로세스를 메모리에 올릴 때 주소 공간을 메모리의 한 곳에 연속적으로 적재하는 방식
  - 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 함
  ### 1.2.1 고정 분할 방식
  - 물리적 메모리를 정해진 개수만큼의 영구적인 분할로 나누어두고 각 분할에 하나의 프로세스를 적재하는 방식
  - 분할의 크기는 모두 동일할 수도 있고 서로 다를 수도 있음
  - 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 또한 제한 됨
  - 외부조각과 내부조각 문제 발생
    - (외부 단편화)외부조각: 맞는 메모리공간 없음
    - (내부 단편화)내부조각: 남는 메모리공간 발생

  ### 1.2.2 가변 분할 방식
  - 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식
  - 가변 분할 방식은 프로세스에 딱 맞게 메모리 공간을 사용해서 내부 조각 문제는 발생하지 않음
  - 사용중인 프로세스가 종료되어 메모리에 새로운 프로세스를 올리려고 할 때 메모리 공간이 충분하지 않을 경우 외부 조각 문제가 발생
  - 방식 3가지
    - 최초적합: 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당
    - 최적적합: 프로세스의 크기 이상인 공간 중 가장 작은 홀에 할당
    - 최악적합: 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당
    - 홀: 할당할 수 있는 비어 있는 메모리 공간
 
  ## 1.3 불연속 할당
  - 메모리를 연속적으로 할당하지 않는 방식
  - 현대 운영체제에서 쓰임
  - 페이징, 세그먼테이션 기법이 있음

# 2. 가상 메모리 개요
  ## 2.1 가상 메모리 정의
  - 물리적 메모리 크기의 한계를 극복하기 위해 나온 기술
  - 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 두며 필요할 때마다 교체하면서 쓰는 방식

  ## 2.2 가상 메모리 필요성
  - 프로그램의 크기와 복잡도가 증가하면서 메모리 용량 자체가 부족해지는 문제를 해결하기 위함
    - 예를 들어 게임 프로그램의 크기가 50GB인데 메모리 16GB로 게임을 돌릴 수 있는 것
  - 대용량의 프로그램을 실행한다거나 다중 프로그래밍을 지원해야하는 경우 메모리 용량이 부족한 문제 때문에
  - 프로세스 간의 메모리 공유와 보호를 위해서

  ## 2.3 페이징 기법
  - 물리 메모리를 일정한 크기인 Frame으로 나누고, 논리 메모리를 Frame과 동일한 크기의 Page로 나눔
  - 이후 필요한 Page를 Frame에 적재하고 실행
  - 장점
    - 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않음
  - 단점
    - 내부 단편화 문제가 발생할 수 있음, 페이지 단위를 작게하면 해결할 수 있지만, 페이지 매핑 과정이 복잡해짐
  ## 2.4 세그먼테이션 기법
  - 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의미함
  - 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위이인 세그먼트로 분할해서 메모리에 적재하는 방식
  - 세그먼트는 의미가 같지 않은 논리적 내용을 기준으로 프로그램을 분할하여 크기가 같지 않음
  - 장점
    - 내부 단편화 문제가 해소 됨
    - 보호와 공유 기능을 수행할 수 있음
    - 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고 같은 코드 영역은 한 번에 저장 가능
  - 단점
    - 외부 단편화 문제가 생길 수 있음
# 3. 가상 메모리 관리
  ## 3.1 요구 페이징
  - 프로그램 실행시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라 당장 사용될 페이지만 올리는 방식

  **장점**
  - 필요한 페이지만 메모리에 적재하기 때문에 메모리 사용량이 감소
  - 프로세스 전체를 메모리에 올리는데 소요되는 입출력 오버헤드가 감소
  - 사용되지 않는 주소 영역에 대한 입출력이 길어 응답시간이 줄어듬
  - 시스템이 더 많은 프로세스를 수용할 수 있게 해줌
  - 물리적 메모리의 제약을 벗어날 수 있음

  ## 3.2 페이지 부재
  - 가상 메모리 기법은 일부 페이지만 메모리에 적재되어 있고 나머지는 디스크의 스왑 영역에 존재
  - 이러한 이유로 메모리에 페이지가 존재하는지 구별하기 위해 유효-무효 비트를 두어 각 페이지가 존재하는지 표시
  - 페이지가 메모리에 적재되지 않아 유효-무효 비트에 무효로 세팅되어 있는 경우를 페이지 부재가 일어났다고 함

  **페이지 부재 현상 처리 과정**
  1. CPU는 물리메모리를 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알림
  2. 운영체제는 CPU의 동작을 잠시 멈춤
  3. 운영체제는 페이지테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고 없으면 프로세스를 중단
  4. 페이지 폴트이면, 현재 물리 메모리에 비어있는 프레임이 있는지 찾음 -> 페이지 교체 알고리즘이 사용됨(페이지가 없다면)
  5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화
  6. 중단되었던 CPU를 다시 시작

  ## 3.3 페이지 교체 알고리즘
  - 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 페이지 부재를 줄이고 시스템의 성능을 향상시키는 것

  ### 3.3.1 FIFO(First In First Out)
  - Queue의 특성처럼 메모리에 가장 먼저 올라온 페이지를 먼저 내보내는 방식(스왑 아웃으로 디스크의 스왑영역에 저장시켜둠)
  - 페이지 부재가 많이 일어날 가능성이 있어 성능이 떨어짐
  ### 3.3.2 OPT(Optimal)
  - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘
  - 모든 페이지 교체 알고리즘 중 페이지 부재가 가장 적음
  - 미래에 대한 예측이 필요하여 구현이 어려워 사용되지 않음

  ### 3.3.3 LRU(Least Frequently Used)
  - 참조횟수가 가장 적은 페이지를 교체하는 알고리즘
  - 교체 대상이 여러 개라면 가장 오랫동안 사용하지 않은 페이지를 교체


# 4. 질문
- 메모리를 왜 운영체제가 관리하는지 얘기 해주세요.
- 메모리 관리가 무엇을 의미하고 왜 필요한지 이야기 해주세요
- 메모리 할당 기법중 메모리 연속할당 기법과 불연속 할당에 대해서 설명해주시고 메모리 연속할당 기법에 포함된 두가지 방식에 대해서 설명해주세요.
- 가상 메모리가 무엇인지 설명해주시고 필요한 이유에 대해서 설명해주세요.
- 메모리 불연속 할당 기법에 포함된 페이징 기법과 세그먼테이션 기법에 대해서 설명해주세요.
- 요구 페이징에 대해서 설명해주세요.
- 페이지 부재에 대해서 설명해주세요.
- 페이지 부재 현상의 처리 과정을 간단하게 설명해주세요.
- 페이지 교체 알고리즘에 대해서 아시는대로 설명해주세요.