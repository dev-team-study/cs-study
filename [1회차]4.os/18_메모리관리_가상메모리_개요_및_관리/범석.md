## 메모리 관리

> ### 메모리 관리 필요성
>
> - 효율적 자원 활용 : 메모리는 한정된 자원이므로, 이를 효율적으로 사용해 시스템 전체 성능을 극대화 할 필요가 있다.
> - 프로세스 격리 : 서로 다른 프로세스들이 메모리를 공유할 때, 상호 간섭을 방지하기 위해 격리가 필요하다.
> - 데이터 보호 : 시스템과 사용자 데이터의 보안과 무결성을 보장하기 위해 적절한 메모리 관리가 요구된다. 
> - 동적 할당 지원 : 실행 시간에 메모리 요구 사항이 변할 수 있는 응용 프로그램을 지원하기 위해 동적할당이 필요하다.
>
> ### 고정 분할 방식(Fixed Partitioning)
>
> - 고정 크기 분할 : 메모리가 고정된 크기의 분할로 나뉘어져, 각각의 분할이 하나의 프로세스를 수용한다. 
> - 간단한 관리 : 분할의 크기와 수가 고정되어 있어 비교적 관리가 간단하다.
> - 내부 단편화 문제 : 프로세스 크기가 분할 크기보다 작을 경우, 남은 공간이 낭비되는 내부 단편화가 발생한다.
> - 크기 제한 : 프로세스 크기가 가장 큰 분할보다 클 경우, 메모리에 할당될 수 없는 문제가 발생 
>
> ### 가변 분할 방식(Variable Partitioning)
>
> - 가변 크기 분할 : 메모리가 프로세스의 크기에 따라 동적으로 분할된다. 
> - 효율적 공간 사용 : 프로세스의 실제 크기에 근거해 메모리를 할당하기 때문에, 공간활용도가 높다.
> - 외부 단편화 문제 : 메모리의 불연속적인 사용으로 인해 발생하는 외부 단편화가 문제가 될 수 있다. 
> - 복잡한 관리 : 동적으로 변하는 메모리 할당으로 인해 관리가 더 복잡하다. 

## 가상 메모리 개요

> ### 가상 메모리 정의
>
> - 논리적 메모리 확장 : 가상 메모리는 실제 물리적 메모리 크기를 초과하는 메모리 공간을 프로세스에 제공하는 기술
> - 물리적 - 논리적 분리 : 물리적 메모리와 논리적 주소 공간을 분리해, 프로세스는 더 큰 메모리에 접근하는 것처럼 작동한다
> - 디스크 사용 : 물리적 메모리가 부족할 때, 디스크 공간을 활용해 데이터를 저장하고 검색한다.
>
> ### 가상 메모리 필요성
>
> - 메모리 공간 확장 : 물리적 메모리보다 큰 프로그램을 실행할 수 있게 해준다. 
> - 메모리 관리 간소화 : 프로그램 개발자는 메모리 관리의 복잡성을 신경 쓸 필요 없이, 충분한 메모리를 가지고 있는 것 처럼 개발 할 수 있다.
> - 멀티태스킹 지원 : 여러 프로그램이 동시에 실해오디는 환경에서 메모리 사용을 최적화하고 프로세스 간의 메모리 충돌을 방지한다. 
> - 보안 및 격리 강화 : 각 프로세스는 독립적인 주소 공간을 가지므로, 프로세스간의 무단 접근을 방지한다. 
>
> ### 페이징 기법
>
> - 고정 크기 분할 : 메모리를 고정된 크기의 '페이지'로 나누고, 이를 물리적 메모리의 '프레임'에  매핑한다.
> - 논리적 - 물리적 매핑 : 페이지 테이블을 사용해 논리적 메모리 주소를 물리적 주소로 변환한다.
> - 내부 단편화 : 페이지 크기보다 작은 메모리 요청에 대해 남는 공간이 발생할 수 있다.
> - 외부 단편화 최소화 : 연속적인 메모리 할당이 필요하지 않기 때문에 외부 단편화가 감소한다. 
>
> ### 세그먼테이션 기법
>
> - 가변 크기 분할 : 메모리를 다양한 크기의 '세그먼트'로 나누고, 각 세그먼트는 프로그램의 논리적 구조에 따라 다른 크기를 가진다.
> - 논리적 구조 반영 : 함수, 배열, 객체 등 프로그램의 논리적 단위에 따라 메모리를 할당한다.
> - 외부 단편화 문제 : 가변 크기 할당으로 인해 메모리에 사용하지 않는 공간이 발생할 수 있다.
> - 보호 및 공유 용이 : 서로 다른 세그먼트에 대해 보호 및 접근 권한을 설정하고 공유가 용이하다. 

## 가상 메모리 관리

> ### 요구 페이징 (Demand Paging)
>
> - 지연 로딩 : 프로세스가 실제로 필요로 하는 메모리 페이지만을 물리적 메모리에 로딩하는 기법
> - 효율적 메모리 사용 : 모든 페이지를 미리 로드하지 않기 때문에 메모리 사용 효율이 높아진다. 
> - 페이지 폴트 : 프로세스가 요청한 페이지가 메모리에 없을 경우, 페이지 폴드가 발생하고 해당 페이지는 디스크에서 로드된다.
> - 스왑 아웃 : 물리적 메모리가 부족할 때, 사용하지 않는 페이지를 디스크로 이동시킨다.
>
> ### 페이지 교체 알고리즘
>
> #### FIFO (First In First Out )
>
> - 가장 오래된 페이지 교체 : 메모리에 가장 먼저 들어온 페이지를 가장 먼저 교체한다.
> - 간단한 구현 : 페이지가 들어온 순서대로 큐에 유지되며, 큐의 앞쪽 페이지부터 교체한다. 
> - 비효율적인 경우 발생 : 자주 사용되는 페이지라도 오래되었다면 교체될 수 있어 비효율적일 수 있다.
>
> #### OPT (Optimal Page Replacement)
>
> - 가장 오랫동안 사용되지 않을 페이지 교체 : 미레에 가장 오랫동안 사용되지 않을 페이지를 교체한다.
> - 이상적인 교체 전략 : 이론적으로 최소의 페이지 폴트를 발생시키는 전략
> - 실제 구현의 어려움 : 프로세스의 미래 메모리 접근 예측이 얼벼기 때문에, 실제 시스템 내에서 구현하기 어렵다.
>
> #### LRU (Least Recently Used)
>
> - 가장 오래 전에 사용된 페이지 교체 : 가장 오래 전에 사용된 페이지를 교체하는 방식 
> - 접근 시간 기록 : 각 페이지가 마지막으로 접근된 시간을 기록해 관리한다.
> - 실용적 근사 : OPT의 이상적인 방법을 실용적으로 근사하는 방법 중 하나
> - 구현 복잡성 : LRU 리스트를 유지하고 갱신하는 과정이 다소 복잡할 수 있다.