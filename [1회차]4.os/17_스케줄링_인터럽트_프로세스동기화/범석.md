## CPU 스케줄링

> ### 장기 스케줄링(Job Scheduling)
>
> - **빈도**: 다른 스케줄러보다 빈도가 낮습니다.
> - **제어**: 다중 프로그래밍 정도를 제어합니다.
> - **기능**: 처리를 위해 시스템에 허용되는 프로그램을 결정합니다.
> - **기준**: 작업 크기, 우선순위, I/O 요구 사항 등
> - **목표**: 시스템 로드와 응답 시간 간의 균형을 유지합니다.
>
> ### 중간 스케줄링(Intermediate Scheduling)
>
> - **역할**: 장기 일정과 단기 일정 간의 중재자 역할을 합니다.
> - **기능**: 메인 메모리에서 프로세스를 일시적으로 제거하고 나중에 복원합니다.
> - **목표**: 다중 프로그래밍 정도를 관리하여 시스템 성능을 향상시킵니다.
> - **프로세스**: 메모리 안팎으로 프로세스를 스와핑하거나 페이징하는 경우가 많습니다.
> - **중요**: CPU 바인딩된 프로세스와 I/O 바인딩된 프로세스의 최적 조합을 유지하는 데 도움이 됩니다.
>
> ### 단기 스케줄링(CPU 스케줄링)
>
> - **빈도**: 매우 자주 발생하며 밀리초 수준으로 발생합니다.
> - **기준**: 프로세스 우선순위, 버스트 시간, 도착 시간 등
> - **기능**: 준비 대기열에서 다음에 실행할 프로세스를 선택합니다.
> - **기법**: 라운드 로빈, 우선 순위 예약, 선착순 등
> - **목표**: 대기 시간을 최소화하고, CPU 활용도를 최적화하고, 공정한 CPU 할당을 보장합니다.

## 스케줄링 알고리즘

> ### FCFS(First Come First Served)
>
> - 순서 : 도착 순서대로 프로세스가 예약된다
> - 단순성 : 구현이 가장 쉽고 오버헤드가 최소화 된다.
> - 단점 : 짧은 프로세스가 긴 프로세스 뒤에 갇히는 '호송 효과'가 발생할 수 있다
>
> ### SJF(Shortest Job First)
>
> - 기준 : 실행 시간이 가장 짧은 프로세스를 선택
> - 유형 : 선점형 / 비선점형
> - 효율성 : 일반적으로 좋은 평균 처리 시간을 제공
> - 문제점 : 프로세스 실행 시간에 대한 사전지식이 필요
>
> ### Round Robin
>
> - 시간 퀀텀 : 각 프로세스 실행에 고정된 시간 조각을 할당
> - 공정성 : 모든 프로세스가 CPU를 균등하게 공유
> - 성능 : 시간 할당량의 길이에 따라 크게 달라짐
> - 컨텍스트 전환 : 더 자주 발생하므로 오버헤드가 발생 할 수 있다. 
>
> ### SRT(Shortest Remaininig Time)
>
> - 접근 방식 : SJF의 선점형 버전
> - 결정 : 완료까지 남은 시간이 가장 짧은 프로세스를 선택
> - 응답성 : 시간에 민감한 프로세스에 적합
> - 복잡성 : 남은 실행 시간을 지속적으로 모니터링 해야함
>
> ### Priority scheduling
>
> - 기준 : 프로세스에 우선순위가 할당됨
> - 선택 : 우선순위가 가장 높은 프로세스가 다음으로 선택된다.
> - 변형 : 선점형 / 비선점형
> - 문제 : 우선순위가 낮은 프로세스가 고갈될 수 있다.
>
> ### Multilevel Queue
>
> - 구조 : 준비 대기열을 여러 개의 개별 대기열로 나눈다.
> - 기준 : 각 대기열에는 자체 예약 알고리즘이 존재한다. 
> - 우선순위 : 대기열에는 우선순위가 할당된다.
> - 유연성 : 프로세스 요구 사항이 다양한 시스템에 유용하다.
>
> ### Multilevel Feedback Queue
>
> - 동적 : 프로세스가 대기열간에 이동할 수 있다.
> - 기준 : 과거 CPU 버스트 및 동작을 기반으로 한다. 
> - 목표 : CPU 버스트 특성을 기준으로 프로세스를 범주로 구분한다. 
> - 장점 : 다양한 알고리즘의 이점을 결합하고 프로세스 동작에 맞게 조정된다. 

## 인터럽트

> ### 인터럽트 개념
>
> - 정의 : 인터럽트는 즉각적인 주의가 필요한 이벤트를 나타내는 외부 장치 또는 소프트웨어 내부에서 CPU로 전송되는 신호
> - 기능 : CPU에서 실행중인 현재 프로세스를 중단하고 임시로 미리 결정된 위치로 제어권을 전달한다.
> - 목적 : CPU가 이벤트가 발생할 때 이에 응답할 수 있도록 하고 폴링을 통해 주변 장치의 상태를 확인 할 필요가 없도록 해 프로세서의 효율성을 향상시킴
>
> ### 동기적 인터럽트, 비동기적 인터럽트
>
> - 동기 인터럽트 
>   - 트리거에 의해 발생 : 명령을 실행하는 동안 CPU의 제어 장치에 의해 생성된다.
>   - 일반적인 원인 : 산술 OverFlow, 0으로 나누기, 유효하지 않은 opcode, 보호된 메모리 액세스
>   - 특성 : 예측 가능하면 프로그램 흐름과 긴밀하게 결합된다.
> - 비동기 인터럽트
>   - 트리거에 의해 발생 : CPU에 의한 현재 명령 실행과 관련 없는 외부 이벤트
>   - 공통 소스 : 키보드, 마우스, 네트워크 카드와 같은 주변 장치
>   - 특성 : CPU 명령 주기와 관련해 예측할 수 없게 발생 
>
> ### 인터럽트 처리 과정
>
> 1. 인터럽트 발생 : CPU는 인터럽트 요청에 의해 신호를 받는다.
> 2. 인터럽트 승인 : CPU는 인터럽트를 승인하고 현재 명령을 완료한다.
> 3. 상태 저장 : CPU 상태는 일반적으로 레지스터와 프로그램 카운터를 저장해 저장된다
> 4. 서비스 루틴 : 인터럽트 벡터에 지정된 ISF로 제어가 전송된다.
> 5. 프로세스 인터럽트 : ISR은 인터럽트를 처리하기 위해 관련 작업을 실행한다.
> 6. 상태 복원 : CPU 상태가 인터럽트 이전 상태로 복원된다.
> 7. 실행 재개 : 중단된 작업에 대한 제어권을 반환 
>
> ### 인터럽트와 이중 모드
>
> - 대부분의 최신 운영체제는 보안과 안정성을 위해 이중모드 (커널 모드 및 사용자 모드)환경에서 작동한다.
> - 인터럽트 역할
>   - 인터럽트를 사용하면 시스템이 사용자 모드에서 커널 모드로 전환되어 중요한 OS루틴이 보호 모드에서 실행되도록 할 수 있다. 
> - 커널 모드 
>   - 운영체제는 하드웨어 리소스에 대한 전체 액세스 권한을 가지며 권한 있는 명령을 실행할 수 있다.
> - 사용자 모드
>   - 애플리케이션은 사용자 모드에서 실행되며, 여기서 직접적인 하드웨어 액세스 및 특정 유형의 명령 실행이 제한된다.
> - 전환
>   - 인터럽트가 발생하면 시스템이 커널 모드로 전환되어 인터럽트를 처리한 후 사용자 모드로 돌아간다. 

## 프로세스 동기화

> ### 공유자원, 경쟁상태, 임계구역
>
> - 공유 자원
>   - 정의 : 여러 프로세스나 스레드가 동시에 접근 할 수 있는 데이터나 자원
>   - 문제점 : 동시 접근 시 데이터 일관성 문제가 발생할 수 있음
>   - 중요성 : 데이터 무결성과 시스템 안정성을 보장하기 위해 적절한 관리가 필요함
> - 경쟁 상태
>   - 발생 상황 : 여러 프로세스가 동시에 공유 데이터에 접근하고 조작할 때 발생
>   - 문제점 : 실행 순서에 따라 최종 결과가 달라져 예측 불가능한 결과가 나타남
>   - 예방 방법 : 순차적 접근을 보장하기 위한 동기화 메커니즘 필요
> - 임계구역
>   - 정의 : 공유 자원에 접근하는 코드의 일부
>   - 규칙 : 한번에 하나의 프로세스 또는 스레드만 임계구역에 접근할 수 있어야 함
>   - 목적 : 경쟁상태를 피하고 데이터 일관성을 보장
>
> ### 피터슨 알고리즘
>
> - 유형 : 프로세스 동기화를 위한 소프트웨어 기반의 상호 배제 해결 방법
> - 메커니즘 : 두가지 변수 (플래그 배열, 턴 변수)를 사용함
> - 기능 : 두 프로세스가 충돌 없이 하나의 자원을 공유할 수 있게 함
> - 한계점 : 성능 문제와 두 프로세스에 한정되는 제한 때문에 현대 시스템에서 사용하지는 않음
>
> ### 뮤텍스
>
> - 기능 : 한번에 한아ㅢ 스레드만 임계구역에 접근할 수 있도록 하는 잠금 메커니즘을 제공함
> - 사용 : 스레드 동기화를 위해 프로그래밍 언어에서 일반적으로 사용됨
> - 특징 : 뮤텍스는 잠금을 한 스레드에 의해서만 잠금 해제가 가능함
>
> ### 세마포어
>
> - 정의 : 카운터를 사용해 공유 자원에 대한 접근을 제어하는 동기화 도구
> - 유형 : 이진 세마포어, 카운팅 세마포어
> - 사용 : 카운팅 세마포어는 제한된 크기와 자원 풀에 대한 접근을 관리할 수 있ㅇ므
> - 메커니즘 : 'Wait' 'Signal'작업
>
> ### 모니터
>
> - 개념 : 프로세스 동기화를 위한 고수준 추상화
> - 구조 : 뮤텍스와 조건 변수로 구성됨
> - 기능 : 공유 변수, 연산, 동기화 메커니즘을 캡슐화함
> - 장점 : 동기화 솔루션 설계를 단순화 하고 공유 자원에 대한 안전한 접근을 보장