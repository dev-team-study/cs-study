# xss
<hr>

### 정의
cross site scripting 공격자가 자바스크립트 악성 코드를 삽입하여 공격하는 방법
<br>
### 공격 방법
피해자의 웹 브라우저에서 실행되어서 데이터 도난, 세션 하이재킹, 사용자 계정을 탈취할 수 있다. 사용자는 미연에 방지하기 어렵다.
<br>
### 목적
사용자의 정보 도용 (쿠키와 같은 데이터를 탈취해서 로그인 정보를 획득한다.)

## Reflected XSS
<hr>

### 정의 
ss 공격을 위해 스크립트를 포함해 url혹은 양식을 사용자에게 노출시킨다. 그래서 url을 클릭하거나 양식을 제출할 때 악성 스크립트가 매개변수로 포함되어 공격한다.
<br>
### 특징
서버에서 스크립트를 저장하지 않기 때문에 서버에서 이루어지는 탐지를 피할 수 있다.
<br>
### 대응
chrome, safari는 대부분 보안 브라우저에서는 reflection xss를 탐지하고 차단한다, 신뢰할 수 없는 값에 개발 단계에서 철저히 검증해야한다. 

## Stored XSS
<hr>

### 정의
공격자가 악성 스크립트를 서버에 저장시키고 클라이언트의 요청과 응답 과정을 통해 공격한다.
<br>
### 특징
일반적으로 서버에서 탐지를 하게 되지만, 한번이라도 저장되게 되면 공격을 파악하기 힘들고 광범위한 피해를 줄 수 있다.
### 예시
게시글에 악성 스크립트를 저장시키고, 게시글을 방문하는 사용자들의 쿠키를 탈취하거나 다른 사이트로 리다이렉션되는 공격을 받는다.
### 대응 
마찬가지로 사용자 입력에 대한 검증이 필요하다.

## DOM based XSS
<hr>

### 정의
공격자가 악성 스크립트가 포함된 url을 사용자가 요청하게 되어 브라우저를 해석하는 단계에서 발생한다.
### 특징 
서버에서 탐지가 어렵고, 클라이언트 측 코드가 의도와 다르게 동작한다.
### 예시 
스크립트에서 # 와 같은 문자를 넣어 그 뒤로 오는 문자를 주석처리하고, 악성 스크립트를 실행시킨다.

# SQL Injection
<hr>

## 정의
임의의 sql문을 주입하고 실행해 db가 비정상적인 동작을 하도록 조작한다.
## 종류

### 논리적 SQL Injection
sql 구문의 논리적인 내용을 바탕으로 검증을 진행한다.
입력값에 대한 검증이 없으면, 악의적인 사용자가 where 절을 모두 참으로 만들거나, 그 뒤의 내용을 모두 주석처리하는 방식으로 사용자 정보를 조회한다.
### union SQL Injection
union을 이용하여 쿼리를 조작한다.
예를 들어 게시판의 테이블 컬럼수와 user 테이블의 컬럼수를 맞춰 union을 사용해 조회하면, 사용자 정보를 얻을 수 있다.
### boolean SQL Injection
참 거짓만 알 수 있는 상황에서 서버가 응답하는 메세지를 바탕으로 정보를 추출한다.
예를 들어 테이블 명을 아스키 코드로 변환해 하나씩 확인해보면서 테이블 명을 알아낼 수 있다.
### time SQL Injection
boolean과 마찬가지로 참 거짓만 알 수 있는 상황에서 db 정보를 유추한다.
예를 들어 sleep과 benchmark 함수 등으로 시간을 측정해 db 이름의 길이를 알아낸다.

## 대응 방안
<hr>

#### 입력값 검증


##### prepared statement 구문 사용
사용자 값이 db의 파라미터로 들억가기전에 db가 미리 컴파일 해 실행하지 않도록 대기한다. 
그후 입력값을 문자열로 인식하게 해 쿼리문이 의도돼로 동작하지 않도록 한다.

##### error message 노출 금지
error message를 공격자에게 노출하지 않도록 처리해 공격자가 db의 정보를 알아내는 것을 방지한다.
#### 웹 방화벽
소포트웨어, 하드웨어, 프록시 형의 정류가 있어 이를 바탕으로 공격을 방어한다.

## Mybatis의 SQL Injection
<hr>
Mybatis는 ${} 문법에서 SQL Injection의 위험이 있다. #{} 문법은 parameter binding으로 파라미터를 생성하고 sql에 binding하게 한다.
반면 ${}은 직접 쿼리에 내용이 들어가기 때문에 공격이 가능하다.

## JPA의 SQL Injection
<hr>
일반적으로 기본 문법을 사용하게 되면 parameter binding으로 동작하기 떄문에 injection 문제는 발생하지 않는다.
하지만 native query를 사용하고 이를 entity manager에 직접 전달하는 방식은 위험할 수 있다.
<br>
hibernate의 경우에는 prepared statement 구문을 사용하고 있어 native query를 사용해도 문제를 방지할 수 있다.

# 쿠키,세션, 토큰(jwt)
## 쿠키
<hr>

### 정의
사용자가 웹페이지에서 이용한 환경 설정 및  기타 정보를 사용자의 컴퓨터에 작은 파일로 저장한 것
이 정보를 활용해 서버와 브라우저 사이의 매개체 역할을 한다.
### 특징
1. 쿠키는 도메인별로 제한된다.  네이버에서 사용한 쿠키는 네이버에서만, 유튜브에서 사용한 쿠키는 유튜브에서만 사용된다.
2. 쿠키는 유효기간이 있다. 서버가 설정한 기간만큼만 유효하다.
3. 인증 정보 외에도 여러 정보를 저장할 수 있다. 예를 들어 웹사이트의 언어 설정 정보도 기억했다가. 다시 방문할때에도 쿠키를 보내 그 언어로 페이지 응답을 한다.
4. 보안에 취약하다. 쿠키의 값을 그대로 보내기 때문에 탈취될 위험이 있다.
5. 브라우저가 다르면, 브라우저간 쿠키의 값을 공유하는 것은 어렵다.

## 세션
<hr>

### 정의
세션은 쿠키를 기반으로 하면서도 쿠키와는 다르게 서버에 저장되는 정보이다. 쿠키와 달리 비밀번호, 카드번호와 같이 중요한 정보를 서버측에서 관리하도록 한다.
### 동작
일반적으로 stateless한 http 프로토콜에서 클라이언트의 상태를 기억하기 위해 사용된다.
1. 사용자가 중요한 정보에 대한 요청을 보낸다.
2. (사용자인지 검증되었다면) 고유한 id를 부여해 세션 저장소에 저장하고, 세션 id를 발급해 쿠키에 담아 보낸다.
3. 사용자는 서버에서 세션 id를 받아 쿠키에 저장하고, 인증이 필요할 때마다 세션 id를 쿠키에 담아 요청한다.
4. 서버는 쿠키를 수신하고 세션 저장소에서 필요한 정보를 응답한다.
### 특징
1. 세션id에 중요정보를 담지 않아 쿠키보다는 안전하지만, 세션id로 공격자가 클라이언트인 척 위장이 가능하다.
2. 요청이 많아지면 서버에 부하가 발생할 수 있다. 

## 세션 불일치 문제
단일 서버에서는 이런 문제가 발생하지 않지만, 다중 서버에서는 세션을 조회하더라도 세션을 찾지 못하는 경우가 발생한다.
<br>
### **그 이유는 세션은 서버의 메모리로 동작하고 있어서이다.**
A서버에 유저의 세션이 저장되어있다면, 로드밸런서가 B서버로 요청을 보내면 A서버에 저장된 세션을 찾을 수 없다.
### 해결 방법
1. sticky session
로드밸런서가 요청을 받아서 저장된 서버로 요청을 전달한다.A서버에 세션이 있으면 A서버로 전송.
- 한 서버쪽에 요청이 몰린다면 로드밸런서에 부하가 발생할 수 있다.
- 서버에 장애가 발생해 세션이 유실되면, 그 서버의 유저들만 다시 로그인해야한다. (가용성)
2. 세션 클러스터링
특정 서버에서 세션이 생성되면 다른 서버에도 세션을 전달해 복제하도록 한다.
1번의 서버의 부하와 가용성 문제를 해결할 수 있다.
- 세션을 전달하고 복제하는데 시간이 걸리기 때문에 성능이 저하된다.
- 메모리가 비효율적으로 사용된다.
- 네트워크 트래픽을 더 사용하게 된다.
3. 세션 스토리지 분리
세션을 별도의 서버에 저장한다. 서버가 아닌 세션 스토리지 서버를 별도로 사용해 2번의 단점을 해결할 수 있다. 
- 일반적인 db를 사용할 수도 있지만, 입출력이 잦기때문에 i/o 성능이 빠르고 key-value형태로 저장할 수 있는 in-memory db redis, memcached를 사용한다.
   (세션 정보는 영속성을 보장할 필요가 없다.)
- 세션 스토리지 서버에 장애가 발생하면 세션 정보가 유실된다. 여러 세션 스토리지를 두면 해결이 가능하다.

## 토큰 및 jwt
<hr>

### 정의
토큰은 사용자의 인증 정보를 담고 있는 문자열이다. 토큰은 서버에 저장하지 않고, 클라이언트에 저장한다.
토큰 자체에 데이터가 들어있어, 서버에서는 토큰을 전달받아 검증하고 요청에 응답하기만 하면 된다. (db를 조회할 필요가 없음ㅁ)
### 특징
1. 토큰 자체의 데이터가 길어 인증 요청이 많아지면 네트워크 부하가 심해질 수 있다.
2. 토큰이 클라이언트에 저장되기 때문에, 공격자가 토큰을 인증이 가능하다.(서버에서 유효시간을 설정하면 된다.)
3. 여전히 payload는 정보 조회가 가능하기 때문에 중요 정보를 담아서는 안된다.
### jwt
인증에 필요한 정보를 암호화한 json을 사용하는 토큰이다.
jwt 토큰을 http 헤더에 담아 서버가 클라이언트를 식별할 수 있도록 한다.
### 구조
1. header : 토큰의 타입과 암호화 알고리즘을 지정한다.
2. payload : 토큰에 담을 정보를 지정한다. (사용자 권한 정보)
3. signature : 토큰의 유효성 검증을 위한 문자열이다. header와 payload를 합친 후 비밀키로 암호화한다.
### 특징
1. 소셜로그인 등 다양한 시스템의 접근 권한 및 공유가 가능하다.
2. 별도의 저장소가 필요하지 않다.
3. 공격자가 토큰을 탈취하면 유효시간까지 공격이 가능하지만, refresh token을 사용해 상대적으로 유효시간을 적게 가져가 피해를 적게 가져갈 수 있다.)

# 질문
- xss의 정의와 종류별로 동작과정과 함꼐 설명해주세요
- sql injection의 공격 방법을 종류별로 설명해주세요
- mybatis와 jpa의 경우 sql injection을 어떻게 다루고 있는지 설명해주세요
- 쿠키와 세션 토큰의 특징과 차이를 장단점과 함께 설명해주세요
- 세션 불일치 문제에 대해 알고있나요? 어떻게 해결할 수 있을까요?
- jwt의 경우 payload의 정보는 그대로 드러나는 문제가 있는데, 이를 어떻게 해결할 수 있을까요?