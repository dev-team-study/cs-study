## 객체지향

### 4가지 특징

**캡슐화** 

연관된 데이터(변수)와 기능(메서드)을 하나로 묶고, 불필요한 요소를 외부에 노출하지 않도록 설계하는 방식을 말함.

자바에서는 접근 제어자의 도움을 받아 구현할 수 있다. 

캡슐화를 진행하게 된다면 다음과 같은 효과를 얻을 수 있음

- 느슨한 결합
- 재사용
- 정보은닉

**다형성**

하나의 객체나 메서드가 여러가지 다른 형태를 가질 수 있는 것을 말함.

다형성에는 Overriding Overloading이 존재한다. 

Overriding 

부모 클래스에서 정의한 메서드의 기능을 자식 클래스에서 재정의하여 사용하는 것을 말한다. 

Overloading

한 클래스 내에서 같은 메서드의 이름으로 여러가지 메서드를 만들 수 있는 것을 말한다. 

다만 Method Signature가 달라야 한다.

Method Signature => 메소드명, 매개변수 개수, 매개변수 타입

**추상화** 

클래스들의 공통적인 요소를 뽑아 상위 클래스를 만들어 내는 것. 

공통적인 속성과 기능을 정의함으로써 코드의 중복을 줄이고, 클래스간의 관계를 효과적으로 설정하고, 유지보수를 용이하게 하는 것.

자바에서는 인터페이스와 추상클래스를 통해 추상화를 구현할 수 있음.

**상속**

기존의 클래스에 기능을 추가하거나 재정의해 새로운 클래스를 만드는 것을 말함. 

기존에 정의되어 있는 클래스의 모든 필드와 메서드를 물려받을 수 있음

- 기존에 작성된 클래스를 재활용 할 수 있다.
- 유지보수의 용이성 => 공통적인 기능을 상위 클래스에 구현함으로써, 변경 사항이 있을 때 하나의 위치에서 수정하면된다.
- 확장성 향상 => 기존 클래스를 확장해 새 기능을 추가하거나 기존 기능을 변경할 수 있음
- 다형성 구현 => 상속을 통해 다형성을 구현할 수 있다.

### 5원칙 (SOLID)

**Single Responsibility Principle - 단일 책임 원칙**

**하나의 클래스(객체)는 하나의 책임만 가져야 한다.**

만약 클래스가 여러개의 책임을 지고 있다면, 클래스의 기능 변경 시 수정해야 할 코드가 많아진다. 

**Open Closed Principle - 개방 폐쇄 원칙**

**확장에는 열려있고, 변경에는 닫혀있어야 한다.**

기능 추가 요청이 오면 클래스 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스의 수정은 최소화 하도록 하는 설계 기법이다. 

**Liskov Substitution Principle - 리스코프 치환 원칙**

하위 타입은 언제나 상위 타입으로 교체할 수 있어야 한다. 

상위 타입으로 객체를 선언하고 하위 타입으로 인스턴스를 받을 경우, 업캐스팅된 상태에서 부모의 메서드를 사용해도 의도대로 동작이 되어야 함을 의미한다.

**Interface Segregation Principle  - 인터페이스 분리 원칙**

**특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.**

**Dependency Inversion Principle - 의존 역전 원칙**

**추상화에 의존해야지, 구체화에 의존하면 안된다.**

=> 클래스 간의 결합도를 낮출 수 있다.

### 객체지향 vs 절차지향 vs 함수형 프로그래밍

객체지향 (Object-Oriented Programming)

정의 : 데이터와 이를 처리하는 메서드를 객체라는 단위로 묶어 프로그래밍 하는 방식. 클래스라는 틀을 정의해 객체의 상태(속성)와 행동(메서드)을 구현한다. 

특징 : 캡슐화, 상속, 다형성, 추상화

절차지향 (Procedural Programming)

정의 : 프로그램을 일련의 절차나 연산의 순서로 구성하는 방식. 함수를 중심으로 코드를 작성하며, 프로그램의 흐름을 순차적으로 나타낸다. 

특징 : 간단하고 직관적인 코드 구조를 가지며, 하드웨어의 아키텍처와 밀접하게 동작한다. 

함수형 프로그래밍 (Functional Programming)

**순수 함수**를 사용하여 상태를 제어하기보다 빨리 처리하는 데 초점을 둔 방법.

*순수 함수 : 동일한 입력값을 넣었을 때 항상 동일한 리턴값을 반환하며 외부에 영향을 받지 않는 함수*



## JDK, JRE, JVM

### 컴파일 과정

1. 개발자가 자바 소스코드 (.java)를 작성

2. Java Compiler가 자바 소스파일을 컴파일 한다. 이때 나오는 파일은 자바 바이트 코드(.class)파일로 아직 컴퓨터가 읽을 수 없는 JVM이 읽을 수 잇는 코드로 변환된다. 

3. 컴파일된 바이트 코드를 JVM의 클래스로더에게 전달.

4. 클래스로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area에 올린다. 

   클래스 로더 세부 동작 

   1. 로드 : 클래스 파일을 가져와 JVM의 메모리에 로드
   2. 검증 : 자바 언어의 명세 및 JVM명세에 명시된 대로 구성되어 있는지 검사
   3. 준비 : 클래스가 필요로 하는 메모리를 할당.
   4. 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
   5. 초기화 : 클래스 변수들을 적절한 값으로 초기화 한다. (static field)

5. 실행 엔진은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와 실행. 

   실행 방식 

   1. 인터프리터 : 바이트 코드 명령어를 하나씩 읽어 해석하고 실행. => 하나하나의 실행은 바르나 전체적인 실행 속도가 느리다. 
   2. JIT 컴파일러 : 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일해 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식. 하나씩 인터프리팅 하는 것이 아닌 바이트 전체가 컴파일된 바이너리 코드를 실행하기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠르다.

### 컴파일 언어 vs 인터프리터 언어

**컴파일 언어**

컴파일러는 고급 언어로 작성된 소스코드를 저급언어로 번역하는 프로그램. 

*고급 언어 : 사람이 이해하기 쉽도록 작성된 언어*

컴파일 언어는 컴파일러를 통해 컴파일 타임에 전체 소스 코드를 한번에 기계어로 변환 후 실행파일을만든다. 컴파일 단계와 실행단계가 분리되어있으며, 컴파일은 단 한번만 수행되고, 실행은 실행 파일을 실행시킴으로써 수행할 수 있다. 실행 시 컴파일 과정을 거치지 않으므로 실행 속도가 빠르다는 장점을 지닌다.

**인터프리터 언어** 

프로그래밍 언어의 소스 코드를 바로 실행하는 언어.

인터프리터 언어는 컴파일 언어와 컴파일 하는 별도의 과정이 없다. 인터프리터 언어는 소스 코드를 한 줄씩 읽어들여 실행한다. 실행시마다 인터프리트 과정이 반복수행되므로 실행 속도가 느리다는 단점을 지닌다. 

### JVM 메모리 구조

Runtime Data Area는 크게 5가지로 구성된다. 

- Method Area
  - Constant Pool
  - 필드
  - 메소드 코드 등이 저장되는 영역
- Heap Area
  - 클래스 인스턴스들이 저장되는 런타임 데이터 영역으로 GC가 관리한다. 
  - new 연산으로 생성된 모든 클래스 인스턴스가 저장되는 영역
  - 멀티쓰레드 환경에서 Heap 영역은 모든 스레드가 공유 (동기화 필수)
- Stack Area
  - 각 스레드마다 별도의 스택을 가짐
  - 메서드 호출 시 스택 프레임이 증가하며 반환시 프레임은 자동 소멸됨
  - 지역변수, 피연산자, 스택 프레임 데이터 등 세가지 요소로 구성
    - 지역변수 
      - 지역변수들을 배열 형식으로 저장 관리
      - 바이트 코드 수준에서 각 지연변수에 대한 접근은 배열의 인덱스로 대체 
      - 배열의 최대 크기는 컴파일 타임에 결정
    - 피연산자와 프레임
      - 스택기반 머신 형태로 작동하도록 구성
      - 연산의 중간결과도 스택에 저장
      - 스택의 최대 크기는 컴파일 타임에 결정
      - 메서드에 대한 모든 심볼정보 및 예외처리 관련 catch 블록 정보 등은 프레임 데이터 영역 사용
- PC Register
  - 일반 CPU처럼 Program Counterfmㄹ 가지며 같은 역할을 수행함
  - 스레드 마다 별도 문맥을 가질 수 있도록 개별 PC Register를 가짐
- Native Method Stack
  - C / C++같은 Native 언어로 개발된 메서드를 지원하기 위한 스택
  - 스레드마다 별도로 제공 
  - JNI(Java Native Interface)

---

1. 객체지향 프로그래밍이 갖는 4가지의 특징은 무엇인가요?
2. 좋은 객체지향 설계를 위한 5가지의 원칙은 무엇인가요?
3. 객체지향, 절차지향, 함수형 프로그래밍의 차이에 대해서 간략하게 설명해주세요. 
4. 자바에서의 컴파일 과정에 대해서 설명해주세요.
5. 컴파일 언어와 인터프리터 언어는 어떤점이 다른가요?
6. JVM 메모리 구조에 대해서 설명해주세요