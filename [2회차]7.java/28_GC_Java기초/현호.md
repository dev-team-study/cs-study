# Garbage Collector 동작과정
## GC란?
- 가비지 컬렉션은 자바의 메모리 관리 방법으로 JVM의 Heap 영역에 동적으로 할당했던 객체 중 필요 없게 된 객체(garbage)를 모아 주기적으로 제거하는 프로세스를 말한다.
- C / C++ 언어에서는 이러한 가비지 컬렉션이 없어 프로그래머가 수동으로 메모리 할당과 해제를 해줘야한다.
- 반면 Java에서는 가비지 컬렉터가 메모리 관리를 대신해주기 때문에 개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에 대해 관리하지 않아도 되어 오롯이 개발에만 집중할 수 있다는 장점이 있다.

## STW(Stop-The-World)
- 가비지 컬렉션에도 단점이 존재한다. 메모리가 언제 해제되는지 정확하게 알 수 없어 메모리 성능을 세밀하게 관리하기 힘들며, 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있다. 이를 전문적인 용어로 Stop-The-World라 한다.
- STW (Stop The World) : GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미한다. GC가 작동하는 동안 GC 관련 Thread를 제외한 모든 Thread는 멈추게 되어 서비스 이용에 차질이 생길 수 있다. 따라서 이 시간을 최소화 시키는 것이 중요하다.  

## GC 대상
- 가비지 컬렉션은 특정 객체가 garbage인지 아닌지 판단하기 위해서 객체에 대한 참조가 존재하는지 체크한다.  
- 객체에 도달할 수 있는 참조가 존재한다면 객체가 아직 쓰이는 것으로 판단하여 GC의 대상으로 하지 않고, 객체에 대한 참조가 없다면 더 이상 쓰이지 않는 객체이므로 GC대상으로 구분하여 수거한다.  

## GC 동작과정
### 효율적은 GC를 위한 힙 메모리 구조
- Heap영역은 한 가지 전제를 기반으로 설계되었습니다. 바로 힙에 저장되는 대부분의 객체는 일회성이며, 메모리에 오랫동안 남아있는 경우는 드물다는 전제입니다.
- 이러한 특성을 이용해 Heap 영역을 Young 과 Old 2가지 영역으로 나누고 객체가 생성되면 우선 young 영역에 객체를 저장한 뒤에 young영역 내에서만 GC를 자주 실행해주는 방식으로 GC를 효율화하였습니다.
- young 영역은 old영역에 비해서 상대적으로 작은 공간이므로 GC의 시간이 짧습니다. 따라서 새로 생성된 객체는 모두 young영역에 넣는 전략이 효율적으로 작용합니다. 이후에 young영역의 GC로 부터 살아남은 좀 더 오래 남아있어야 하는 객체들을 old 영역에 저장하는 방식으로 GC가 최적화되어 있습니다.      

### Mark And Sweep
- GC가 실질적으로 동작하는 방식이다.
- 스택 영역처럼 힙에 존재하는 객체들의 참조가 시작되는 곳으로 부터 그래프 탐색처럼 참조 중인 객체를 순회한다.  
- 이렇게 탐색이 끝나면 힙에 존재하는 객체 중 탐색을 통해 도달할 수 있었던 객체와, 도달할 수 없었던 객체가 나뉜다. 탐색을 통해 도달할 수 없었던 객체의 경우 유효한 참조가 없다는 의미이므로 GC의 대상이라고 표시를 해둔다.
- 이렇게 GC 대상이 되는 객체에 대해 전체적으로 표시가 완료되면 Sweep과정을 시작해서 표시해둔 객체들을 힙에서 제거한다.  

## GC 알고리즘 종류 
### Parallel GC
- 자바 8의 디폴트 GC
- 힙 영역을 Young영역과, Old영역으로 나뉘어진 전통적인 구조로 보고 동작한다.
- Mark And Sweep방식으로 동작
- young영역의 minorGC를 멀티 쓰레드로 수행.

### G1 GC
- 자바 11의 디폴트 GC
- 힙 영역을 체스판과 같은 여러 영역으로 분류하여 보는 Region이라는 개념으로 동작한다.
- 힙이 여러 개의 작은 영역으로 나위어 있어 각 영역에 객체가 동적으로 할당되고, GC는 해당 영역 안에서만 이루어지는 방식으로 전통적인 구조보다 GC 속도가 더 최적화되었다.

### ZGC
- G1과 비슷하게 동작
- G1은 각 영역의 크기가 고정되어 있었지만 ZGC에서는 들어오는 객체의 크기에 따라 영역의 크기가 동적으로 생성된다. 

출처: https://inpa.tistory.com/entry/JAVA-☕-가비지-컬렉션GC-동작-원리-알고리즘-💯-총정리 [Inpa Dev 👨‍💻:티스토리]

# Java8의 큰 특징 + Java11과의 차이점
Java8의 특징
- 함수형 인터페이스와 람다 표현식 추가
- 스트림API 추가
- Null 관리를 위한 Optional 문법 추가 
- 인터페이스에 Defalut, Static 메서드 문법 추가
- LocalDateTime과 같은 새로운 날짜 API 제공

Java11의 특징
- G1 GC가 기본 GC로 설정
- var키워드 사용 가능
- 컬렉션, 스트림API 등에 메서드 추가
- Http Client가 API 호출의 표준 기능이되어 성능이 향상

# Java21
## Virtual Threads
- 기존 자바 스레드는 OS 스레드와 일대일 대응된다. 즉, 사용자 요청 등이 들어와서 자바 스레드가 사용되는 것은 곧 OS 스레드가 사용중임을 의미했다. OS의 쓰레드는 고비용이라 많이 생성할 수 없는데, 최대한으로 활용할 수 있는 쓰레드의 수가 제한적이라는 점이 결과적으로 하드웨어를 최적으로 활용하지 못하는 원인이 되었다.(IO작업시 쓰래드가 대기 상태가 되는 등의 현상이 직접적인 원인이 됨.)    
- 따라서 자바 런타임에서 OS 스레드와 일대일 대응되지 않는 가상의 스레드를 구현해 사용하는 것이다. 자바 런타임은 많은 수의 가상 스레드를 하나의 OS 스레드에 매핑하여 OS스레드를 효율적으로 활용하는 것이다.  
- 자바는 전체 실행 주기 동안 OS 스레드를 작아먹지 않는 java.lang.Thread 인스턴스를 도입하게 되었다. 즉, java.lang.Thread의 인스턴스로, OS 스레드와 연결되는 기존의 스레드인 플랫폼 스레드(Platform Thread)와 자바 런타임에만 존재하고 OS 스레드와는 연결되지 않는 신규 스레드인 가상 스레드(Virtual Thread)가 존재하게 되었다.
출처: https://mangkyu.tistory.com/309 [MangKyu's Diary:티스토리]

# 접근제어자
1. private : 다른 클래스가 접근할 수 없다.
2. default : 같은 패키지의 클래스들이 접근할 수 있다. (같은 패키지 내의 일반 클래스, 자식 클래스가 접근할 수 있음)
3. protected : **같은 패키지의 클래스들 + 다른 패키지의 자식 클래스가 접근할 수 있다.**
4. public : 모든 클래스가 접근할 수 있다.

# 클래스, 객체, 인스턴스 차이
1. 클래스 : 클래스란 객체를 생성하기 위한 일종의 설계도입니다.
2. 객체 : 클래스가 설계도라면 객체는 설계도를 통해 구현된 실체입니다.
3. 인스턴스 : 객체가 어떤 클래스의 객체인지 관계를 강조하여 파악할 때 쓰이는 표현입니다. 예를 들어, 이 객체는 어떤 클래스의 인스턴스다라는 식으로 표현합니다.

# Overloading vs Overriding
1. 오버로딩 : 같은 메서드명을 공유하지만 매개변수의 타입이나 갯 수가 다른 여러 메서드를 정의해서 사용하는 방법입니다.
2. 오버라이딩 : 부모 클래스나 구현하고 있는 인터페이스에 존재하는 메서드를 자식 클래스가 다시 한 번 재정의하여 사용하는 것을 의미합니다.

# Primitive type vs Reference type
1. Primitive type : 변수를 위해 할당 된 저장 공간에 실제 데이터가 저장되어 있는 자료형들을 의미합니다.
2. Reference type : 반면, Reference type은 변수를 위한 저장 공간에 다른 변수로 이동할 수 있는 참조값이 저장되어 있는 자료형입니다.

# Call by Reference vs Call by Value
1. Call by Value : 함수를 호출하면서 매개변수로 primitive type을 전달하는 경우를 Call by Value라고 합니다. Call by Value가 일어났을 경우 변수의 주소가 아니라 값 자체가 복사된 것이기 때문에 함수 내부에서 매개 변수에 어떠한 변경을 해도 변수의 값이 변하지 않는다는 특징이 있습니다.
2. Call by Reference : 함수를 호출하면서 매개변수로 Reference type을 전달하는 경우를 의미합니다. Reference type이 가지고 있던 주소 자체가 복사되기 때문에, 메서드 내부에서 주소를 통해 참조해서 값을 바꿀 수 있다는 특징이 있습니다.

# Wrapper Class
Wrapper Class : Primitive type을 객체로 표현하기 위해서 사용하는 클래스. Wrapper Class로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없다.

# interface vs abstract class
인터페이스와 추상 클래스 모두 그 자체로는 객체를 생성할 수 없고 다른 클래스가 상속을 통하여 구현해야 한다는 공통점이 있습니다. 차이점으로는 인터페이스의 경우 필드를 가질 수 없고, 별도로 defalut 키워드를 사용하지 않는 한 메서드가 구현을 가질 수 없습니다. 반면에 추상클래스는 필드를 가질 수 있고, 메서드가 구현을 가질 수 있다는 차이점이 있습니다.



<details>
<summary> 1. 가비지 컬렉터(GC)의 동작 과정을 설명해주세요.</summary>
<div>
가비지 컬렉션은 자바의 메모리 관리 방법으로, JVM의 Heap 영역에 동적으로 할당했던 객체 중 필요 없게 된 객체를 주기적으로 제거하는 프로세스입니다.    
이는 메모리 누수 문제를 방지하고 개발자가 메모리 관리에 신경 쓰지 않고 개발에 집중할 수 있게 해주는 장점이 있습니다. 
가비지 컬렉션은 객체에 대한 참조가 존재하는지 체크하여 참조가 없는 객체를 GC의 대상으로 합니다.
이 후에 실질적으로 GC가 동작하는 방식은 'Mark And Sweep' 방식입니다.스택 영역처럼 힙에 존재하는 객체들의 참조가 시작되는 곳으로부터 참조 중인 객체를 순회하고, 탐색을 통해 도달할 수 없었던 객체를 GC의 대상으로 표시하고 제거하는 방식으로 동작합니다.
</div>
</details>

<details>
<summary> 2. Java8과 Java11의 주요 차이점에 대해 설명해주세요.</summary>
<div>

Java8에서는 함수형 인터페이스와 람다 표현식, 스트림 API, Optional 문법 등이 추가되었으며, 인터페이스에 Default, Static 메서드 문법이 추가되었습니다. 또한 LocalDateTime 등의 새로운 날짜 API가 제공되었습니다.
반면, Java11에서는 G1 GC가 기본 GC로 설정되었으며, var 키워드 사용이 가능해졌습니다. 또한 컬렉션, 스트림 API 등에 메서드가 추가되었고, Http Client가 API 호출의 표준 기능이 되어 성능이 향상되었습니다.

</div>
</details>


<details>
<summary> 3. Virtual Threads에 대해 설명해주세요.</summary>
<div>
Virtual Threads는 자바 런타임에서 OS 스레드와 일대일 대응되지 않는 가상의 스레드를 구현해 사용하는 것으로, OS 스레드를 효율적으로 활용합니다.   
자바 런타임은 많은 수의 가상 스레드를 하나의 OS 스레드에 매핑하여, 스레드의 전체 실행 주기 동안 OS 스레드를 잡아먹지 않는 java.lang.Thread 인스턴스를 도입하게 되었습니다. 
</div>
</details>

<details>
<summary> 4. Overloading과 Overriding에 대해 설명해주세요.</summary>
<div>

오버로딩은 같은 메서드명을 공유하지만 매개변수의 타입이나 개수가 다른 여러 메서드를 정의해서 사용하는 것을 말합니다.  
반면 오버라이딩은 부모 클래스나 구현하고 있는 인터페이스에 존재하는 메서드를 자식 클래스가 다시 한 번 재정의하여 사용하는 것을 의미합니다.  
</div>
</details>

<details>
<summary> 5. interface와 abstract class에 대해 설명해주세요. </summary>
<div>
인터페이스와 추상 클래스 모두 객체를 생성할 수 없고 상속을 통해 구현해야 합니다.  
인터페이스는 필드를 가질 수 없고, 별도로 default 키워드를 사용하지 않는 한 메서드가 구현을 가질 수 없습니다.   
반면, 추상 클래스는 필드를 가질 수 있고, 메서드가 구현을 가질 수 있습니다. 이러한 차이점으로 인해 개발자의 요구에 따라 적절하게 사용할 수 있습니다.
</div>
</details>

