# Garbage Collector 동작과정
## GC란?
- 가비지 컬렉션은 자바의 메모리 관리 방법으로 JVM의 Heap 영역에 동적으로 할당했던 객체 중 필요 없게 된 객체(garbage)를 모아 주기적으로 제거하는 프로세스를 말한다.
- C / C++ 언어에서는 이러한 가비지 컬렉션이 없어 프로그래머가 수동으로 메모리 할당과 해제를 해줘야한다.
- 반면 Java에서는 가비지 컬렉터가 메모리 관리를 대신해주기 때문에 개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에 대해 관리하지 않아도 되어 오롯이 개발에만 집중할 수 있다는 장점이 있다.

## STW(Stop-The-World)
- 가비지 컬렉션에도 단점이 존재한다. 메모리가 언제 해제되는지 정확하게 알 수 없어 메모리 성능을 세밀하게 관리하기 힘들며, 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있다. 이를 전문적인 용어로 Stop-The-World라 한다.
- STW (Stop The World) : GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미한다. GC가 작동하는 동안 GC 관련 Thread를 제외한 모든 Thread는 멈추게 되어 서비스 이용에 차질이 생길 수 있다. 따라서 이 시간을 최소화 시키는 것이 중요하다.  

## GC 대상
- 가비지 컬렉션은 특정 객체가 garbage인지 아닌지 판단하기 위해서 객체에 대한 참조가 존재하는지 체크한다.  
- 객체에 도달할 수 있는 참조가 존재한다면 객체가 아직 쓰이는 것으로 판단하여 GC의 대상으로 하지 않고, 객체에 대한 참조가 없다면 더 이상 쓰이지 않는 객체이므로 GC대상으로 구분하여 수거한다.  

## GC 동작과정
### 효율적은 GC를 위한 힙 메모리 구조
- Heap영역은 한 가지 전제를 기반으로 설계되었습니다. 바로 힙에 저장되는 대부분의 객체는 일회성이며, 메모리에 오랫동안 남아있는 경우는 드물다는 전제입니다.
- 이러한 특성을 이용해 Heap 영역을 Young 과 Old 2가지 영역으로 나누고 객체가 생성되면 우선 young 영역에 객체를 저장한 뒤에 young영역 내에서만 GC를 자주 실행해주는 방식으로 GC를 효율화하였습니다.
- young 영역은 old영역에 비해서 상대적으로 작은 공간이므로 GC의 시간이 짧습니다. 따라서 새로 생성된 객체는 모두 young영역에 넣는 전략이 효율적으로 작용합니다. 이후에 young영역의 GC로 부터 살아남은 좀 더 오래 남아있어야 하는 객체들을 old 영역에 저장하는 방식으로 GC가 최적화되어 있습니다.      

### Mark And Sweep
- GC가 실질적으로 동작하는 방식이다.
- 스택 영역처럼 힙에 존재하는 객체들의 참조가 시작되는 곳으로 부터 그래프 탐색처럼 참조 중인 객체를 순회한다.  
- 이렇게 탐색이 끝나면 힙에 존재하는 객체 중 탐색을 통해 도달할 수 있었던 객체와, 도달할 수 없었던 객체가 나뉜다. 탐색을 통해 도달할 수 없었던 객체의 경우 유효한 참조가 없다는 의미이므로 GC의 대상이라고 표시를 해둔다.
- 이렇게 GC 대상이 되는 객체에 대해 전체적으로 표시가 완료되면 Sweep과정을 시작해서 표시해둔 객체들을 힙에서 제거한다.  

## GC 알고리즘 종류 
### Parallel GC
- 자바 8의 디폴트 GC
- 힙 영역을 Young영역과, Old영역으로 나뉘어진 전통적인 구조로 보고 동작한다.
- Mark And Sweep방식으로 동작
- young영역의 minorGC를 멀티 쓰레드로 수행.

### G1 GC
- 자바 11의 디폴트 GC
- 힙 영역을 체스판과 같은 여러 영역으로 분류하여 보는 Region이라는 개념으로 동작한다.
- 힙이 여러 개의 작은 영역으로 나위어 있어 각 영역에 객체가 동적으로 할당되고, GC는 해당 영역 안에서만 이루어지는 방식으로 전통적인 구조보다 GC 속도가 더 최적화되었다.

### ZGC
- G1과 비슷하게 동작
- G1은 각 영역의 크기가 고정되어 있었지만 ZGC에서는 들어오는 객체의 크기에 따라 영역의 크기가 동적으로 생성된다. 

출처: https://inpa.tistory.com/entry/JAVA-☕-가비지-컬렉션GC-동작-원리-알고리즘-💯-총정리 [Inpa Dev 👨‍💻:티스토리]

# Java8의 큰 특징 + Java11과의 차이점
Java8의 특징
- 함수형 인터페이스와 람다 표현식 추가
- 스트림API 추가
- Null 관리를 위한 Optional 문법 추가 
- 인터페이스에 Defalut, Static 메서드 문법 추가
- LocalDateTime과 같은 새로운 날짜 API 제공

Java11의 특징
- G1 GC가 기본 GC로 설정
- var키워드 사용 가능
- 컬렉션, 스트림API 등에 메서드 추가
- Http Client가 API 호출의 표준 기능이되어 성능이 향상

# 접근제어자
1. private : 다른 클래스가 접근할 수 없다.
2. default : 같은 패키지의 클래스들이 접근할 수 있다. (같은 패키지 내의 일반 클래스, 자식 클래스가 접근할 수 있음)
3. protected : **같은 패키지의 클래스들 + 다른 패키지의 자식 클래스가 접근할 수 있다.**
4. public : 모든 클래스가 접근할 수 있다.

# 클래스, 객체, 인스턴스 차이
1. 클래스 : 클래스란 객체를 생성하기 위한 일종의 설계도입니다.
2. 객체 : 클래스가 설계도라면 객체는 설계도를 통해 구현된 실체입니다.
3. 인스턴스 : 객체가 어떤 클래스의 객체인지 관계를 강조하여 파악할 때 쓰이는 표현입니다. 예를 들어, 이 객체는 어떤 클래스의 인스턴스다라는 식으로 표현합니다.

# Overloading vs Overriding
1. 오버로딩 : 같은 메서드명을 공유하지만 매개변수의 타입이나 갯 수가 다른 여러 메서드를 정의해서 사용하는 방법입니다.
2. 오버라이딩 : 부모 클래스나 구현하고 있는 인터페이스에 존재하는 메서드를 자식 클래스가 다시 한 번 재정의하여 사용하는 것을 의미합니다.

# Primitive type vs Reference type
1. Primitive type : 변수를 위해 할당 된 저장 공간에 실제 데이터가 저장되어 있는 자료형들을 의미합니다.
2. Reference type : 반면, Reference type은 변수를 위한 저장 공간에 다른 변수로 이동할 수 있는 참조값이 저장되어 있는 자료형입니다.

# Call by Reference vs Call by Value
1. Call by Value : 함수를 호출하면서 매개변수로 primitive type을 전달하는 경우를 Call by Value라고 합니다. Call by Value가 일어났을 경우 변수의 주소가 아니라 값 자체가 복사된 것이기 때문에 함수 내부에서 매개 변수에 어떠한 변경을 해도 변수의 값이 변하지 않는다는 특징이 있습니다.
2. Call by Reference : 함수를 호출하면서 매개변수로 Reference type을 전달하는 경우를 의미합니다. Reference type이 가지고 있던 주소 자체가 복사되기 때문에, 메서드 내부에서 주소를 통해 참조해서 값을 바꿀 수 있다는 특징이 있습니다.

# Wrapper Class
Wrapper Class : Primitive type을 객체로 표현하기 위해서 사용하는 클래스. Wrapper Class로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없다.

# interface vs abstract class
인터페이스와 추상 클래스 모두 그 자체로는 객체를 생성할 수 없고 다른 클래스가 상속을 통하여 구현해야 한다는 공통점이 있습니다. 차이점으로는 인터페이스의 경우 필드를 가질 수 없고, 별도로 defalut 키워드를 사용하지 않는 한 메서드가 구현을 가질 수 없습니다. 반면에 추상클래스는 필드를 가질 수 있고, 메서드가 구현을 가질 수 있다는 차이점이 있습니다.


