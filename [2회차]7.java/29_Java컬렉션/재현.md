## CheckedException vs uncheckedException
- error : 큰 문제를 야기할 수 있음
- compile, runtime중에 발생
- 미리 파악 가능, 미리 파악 불가능
- ioeexception vs runtimeexcep, npe, illegalargumentException

## 예외 처리 전략
1. 예외 복구(try-catch)
- exception이 발생하더라도 applicatiton이 정상적으로 동작하기 위해 사용하는 방법
2. 예외 회피
- 예외가 발생하면 throws를 활용해 호출된 부분으로 exception을 던져서 처리하는 방법
3. 예외 전환
- checkedException 문제를 돌려서 명확하게 어떤 문제가 발생하는지 uncheckedException으로 전환하는 방법
  (트랜잭션 롤백 효과를 얻을 수 있음)

### **예외 처리 비용**
**JVM에서 예외처리를 하는 순서**

1. 예외 발생 : JVM은 예외 객체를 생성하고 예외를 발생시킨 메서드의 호출 스택을추적한다.
2. 예외 객체 전파 : JVM은 예외를 발생시킨 메서드에서 예외 처리 코드(프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드 ,try-catch)를 찾고, 없는 경우 예외 객체를 호출 스택의 상위 메소드로 전파한다.
3. 예외 처리 :예외 객체가 상위로 전파되면 catch 블록을 찾고 없다면, 예외를 다시 상위 메서드로 전파한다.
4. 예외처리 실패 : 상위에서도 catch가 없으면 JVM은 예외를 처리하지 못한 것으로 판단한다. 그래서 해당 예외를 처리할 수 있는 DefaultExceptionHandler를 호출한다.
5. DefaultExceptionHandler 실행 : 예외객체에 대한 정보, 예외를 처리하거나 스냅샷 정보를 수집해 디버깅을 위한 정보로 제공한다.

## static
- 클래스 변수 -> 초기화 단계에서 할당
- static 메서드는 인스턴스 변수를 사용할 수 없다

## final
- 불변성 보장? -> 재할당을 막음
- 상속이 불가능

## generic
- 타입에 대한 정의 가능
- ? extends
- wrapper 타입만 가능

## Stream lambda
- 병렬 처리 방식으로 데이터를 쉽게 필터링, 변환, 집계할 수 있다. 개발자가 쉽게 읽을 수 있으며, 복잡한 작업을 쉽게 수행할 수 있다.
- java 8 이후 도입, 함수형 프로그래밍
- 1급 객체(변수나 데이터에 담을 수 잇어야한다. 함수의 파라미터로 전달 가능, 함수의리넡으로 사용가능)
- stream foreach : 강제 종료 불가, 모두 순회한다. => foreach내부에 로직이 추가되면 동시성이나 가독성이 덜어진다.
- lambda : 람다식 내에서 사용되는 지역변수는 상수로 간주된다. 람다 변수명은 다른 변수명과 중복될 수 없다. (개발자의 의도가 드러난다. 병렬 프로그래밍)

## Reflection
- 클래스의 구체적인 타입을 알지 못해도 그 클래스에 접근할 수 있도록 해주는 자바 API
- 특징 : 자바는 컴파일 타임에 타입을 결정하기 때문에 Object로 타입이 결정된 obj는 그에 대한 인스턴스 변수와 메소드만 사용 가능

## dynamic proxy
### 동작 과정
1. newProxyInstance메서드로 동적 프록시 객체를 만든다.
2. 인터페이스로 객체를 프록시로 감사고 행동을 Handler로 감싸게 된다.
3. 프록시 메서드 call을 호출하면 InvocationHandler의 invoke가 대신 실행한다.
4. invoke내부에서 실제 대상 타겟 객체의 call메서드가 실행된다.

### 특징
- 런타임 시점에 프록시 클래스를 만들어 준다.(미리 만들지 않는다.)
- jdk에서 지원하는 프록시를 생성한다.
- reflection api 를 사용한다.
- 인터페이스가 반드시 있어야 한다.
- invocationHandler을 구현한 invoke 메소드를 정의해야 한다.

## JavaCollection
- list(arrayList, LInkedList, vector),queue,deque set (map은 별도)

## hashcode() & equals() 

### equals
- == 동일성 비교(객체 주소 비교) : 변수선언부는 스택에, 상수는 runtime ConstantPool에 저장된다.
- equals 동등성 비교(내용을 비교)
- String, date, file, wapper 클래스는 주소값이 아닌 내용을 비교한다. (StringBuffer는 x)

### hashcode
- 찾고자하는 값이 저장된 위치를 알려준다.(map의 구현체)
- 64비트 환경에서 해시함수를 만드는 경우 중복이 발생한다.
- hashCode는 메모리의 주소값을 바탕으로 만들어진다.
- String클래스는 동일한 값을 반환하도록 이미 설정되어있음

### 해시 충돌
- hashTable은 크기가 한정적이어서 다른 객체이더라도 같은 해시값을 사용해 해시 충돌이 일어난다.
- put하는 경우 : equals로 비교를 해 같은 객체인지 판단한다. 같다면 덮어쓰고, 없으면 LinkedList에 추가한다.
- get하는 경우 : 해시값이 같은 객체가 있으면 그 객체를 return, 없으면 null 리턴

### ThreadSafe
- 스레드는 프로세스에 할당된 자원을 공유한다.
- 병렬 프로그래밍이 가능해 복잡한 어플리케이션 성능을 향상할 수 있다.
- 공유된 자원에 접근하는 스레드는 에측이 어렵다.

### Synncronized
- 스레드의 안정성을 보장하기 위해 사용한다.

### Volatile
- 가시성 : 하나의 스레드에서 변경된 결과를 다른 스레드에서도 볼 수 있어야 한다.

### AtomicInteger
-  다중 스레드 환경에서 안전하게 사용하도록 원자적으로 증가 감소를 할 수 있도록 한다.

### Immutable Object
- 스레드 안전성, 캐싱, 보안성, 객체 일관성, 컬렉션은 unmodiffable

#### String a = "" vs String a = new String("")
기본 문자열을 참조할 수 있는가 o x
후자는 새로운 문자열 객체를 생성하고 할당한다.


- static은 멀티스레드 환경에서 안전할까요?
- final은 완벽히 불변성을 보장할까요? 내부의 상태 변경을 보장하지는 않는다. (ex arrayList의 add)
- 불변성을 보장받는 방법? 객체의 경우 생성자를 통해 값을 주입받음
- stream의 forEach만 사용하는게 왜 좋지 않을까요?
- 람다 활용의 장단점
- hash충돌에 대해서 설명해주세요
- 자바의 모든 클래스는 Object 클래스를 상속받습니다. 그리고 Object클래스에는 equals() 와 hashCode() 라는 메소드가 선언되어 있습니다. 이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?
- "hashCode" 를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요? (일관성 없는 해시코드 반환, 해시충돌 자주 발생, equals를 재정의하지 않는 경우)
- hashmap은 내부적으로 어덯게 구현되어있나요? (내부는 링크드 리스트)
- hashmap의 시간복잡도, 잘못 오버라이딩 한 경우의 시간 복잡도 (O(1) -> key값을 탐색, O(n) linkedList의 조회 시간 복잡도) 
- stringbuilder와 stringbuffer의 차이 : builder는 동기화를 하지 않아 속도가 빠름, buffer는 비동기에 적합해 웹이나 소캣처럼 동작한다.
- 왜 syncrnized키워드가 걸리면 느린지 동작원리와 함께 설명해주세요 lock을 건다. syncronized 키워드가 걸린 모든 object에 대해서 락이 걸린다. 클래스, 인스턴스 단위로락이 걸리기 떄문에 일를 유의해서 사용해야 한다.
- 싱글 스레드로 접근하면 syncronized 적용 여부에 따라 성능이 같을까요 미미하지만 불필요한 오버헤드는 발생할 수도
- List와 비교했을 때 ArrayList만의 타입 특징? 연속적인 자료구조, 데이터 추가시 인덱스를 고려해야 함 indexOutOfBoundsException발생 가능
- arrayList와 배열의 차이점 (배열의 크기는 변경 불가능, 메모리 관리편함, inde를 통한 접근이 빠름) (arrayList 동적 할당, 배열보다 느림)
- 배열로 구현되어있으면 크기 제한 문제가 걸릴텐데. 무한히 데이터를 받을 수 있는지? 정적인 크기, ArrayList의 경우에는 시스템 자원의 한계로 문제가 생길수도
- volatile는 가시성을 보장해준다고 하는데, 가시성에 대해 설명해주세요<br>
 
가시성 : 하나의 스레드에서 변경된 변수의 값을 다른 스레드에서 즉시 알수 있어야 한다. 하나의 스레드는 작업 이후 캐시를 사용하고 그 캐스를 읽어 사용하기때문에 메인 메모리와 동기화되지 않은 캐시 값을 읽을 수 있다. <br>
volatile는 메인 메모리에 직접 접근해 변수 값이 변경되면 모든 스레드에게 변경된 값을 즉시 보장한다. 하지만 원자적 연산이나 스레드 상호 배제를 보장하지는 않는다. 동시성 문제를 완전히 해결해주지는 않음

- blocking io nonblocking io 에 대해 설명해주세요, system.out.println과 어떤 관계일까요?

blocking io : 입출력이 수행되는 동안 스레드는 대기상태에 있는다.  (System.out.println은 blocking io) <br>
non blockingn io : 입출력 작업을 수행하는 동안 호출자 스레드가 블록되지 않고 다른 작업을 수행하도록 한다.

- 스레드가 멈춰있으면 cpu는 어떻게 되나요? 스레드가 멈추면 Cpu는 다른 활성화된 스레드를 처리할 수 있습니다.
- cpu가 쉬는 것을 막으려면 어떻게 해야하나요? 멀티스레드를 활용해 병렬적으로 작업을 수행할 수 있도록 한다.
- 스레드를 늘리면 단점이 뭘까요? 스위칭 작업이 많이 일어나면 CPU 오버헤드가 발생한다. CPU코어가 정해져있는데 스레드가 많으면 자원을 가지기 위해 경쟁이 일어난다.
- 톰캣은 스레드를 어떻게 다루나요? 스레드 풀, 멀티 스레드, 요청-스레드 매핑 
- 객체의 불변성의 장점, 그리고 컬렉션에서는 불변성을 어떻게 다루는 지



