# 1. Java 기초
   ## 1.1 Checked Exception vs UnChecked Exception
   ### Checked Exception
   - RuntimeException을 상속하지 않는 클래스
   - 컴파일 시점에 컴파일러에서 확인하는 예외
   - 반드시 에러 처리를 위한 try/catch 또는 throw를 가지고 있ㅇ므
   
   ### Unchecked Exception
   - RuntimeException을 상속하는 클래스
   - 런타임 단계에서 확인 가능
   - 에러 처리를 강제하지 않음

   ## 1.2 static
   ### 1.2.1 static 변수, 정적 변수
   - 변수 앞에 static을 붙이는 것
   ### 1.2.2 static 메서드, 정적 메서드
   - 메서드 앞에 static을 붙이는 것
   ### 1.2.3 static과 JVM의 관계
   - JVM 메모리 영역의 Method Area
     - 필요한 패키지 클래스, 인터페이스, 상수, static 변수, final 변수, 클래스 멤버 변수 등 로드된 후 메모리에 항상 상주하고 있는 영역
     - 클래스 로더가 .class 파일을 탐색중 static 키워드를 보는 순간 객체가 생성되지 않아도 항상 메모리를 할당해야하는 멤버로 보고 Method Area에 메모리를 할당
     - static 키워드가 붙은 멤버들은 인스턴스에 소속된 변수가 아니라 클래스에 소속된 변수이기 때문에 클래스 변수 혹은 클래스 메서드라고도 부름
   ### 1.2.4 static 이슈
     - static은 글로벌 변수에 가까워서 인스턴스 변수보다 테스트 하기 어려움
     - 객체지향의 프로그램 원칙인 캡슐화에 위배
     - 자주 사용하지 않는 메서드가 누적된다면 GC에 수거되지 못하여 메모리 낭비 발생
     - 자주 사용하면서 만드는데 오래 걸리고 메모리를 많이 사용하는 객체
       - 특정 패턴과 매치시켜야할 때 Pattern 객체는 무거운 객체임
   ## 1.3 final
   - 변수, 메서드, 클래스에 사용되며 더이상 재할당 할 수 없다는 것을 의미함
     - 메서드는 오버라이드가 될 수 없고, 클래스는 상속할 수 없음
   - 프록시 객체를 만들 때 Dynamic Proxy는 괜찮지만 CGLIB을 사용하는 경우 상속받기 때문에 Final을 붙이면 안됨
   - 대표적으로, String 클래스에 final이 붙어있음 -> 상속받지 못하게 막음

   ## 1.4 generic
   - 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미
   ```java
   ArrayList<String> arrayList = new ArrayList<>(); 
   ```
   - <> 꺽쇠 괄호가 제네릭이며 타입명을 기재
   - 제네릭의 타입 전파를 구체화라고 함
   ### 타입 파라미터 기호 네이밍
   - T: 타입
   - E: 요소
   - K: 키 값
   - V: 리턴 값 
   - N: 숫자
   - S, U, V: 2번째, 3번째, 4번째에 선언된 타입

   ### 제네릭을 왜 사용하는지?
   - 컴파일 타임에 타입 검사를 통해 예외 방지
     - 모든 클래스 타입을 받기 위해 Object타입으로 설정한 경우, 다른 타입으로 형 변환할 때 런타임에 에러가 남
   - 불필요한 캐스팅을 없애 성능 향상
     - 옛날에는 모든 클래스 타입을 받기 위해 Object타입으로 설정한 후, 받을 때 해당하는 타입으로 다운 캐스팅해서 가져왔음
     - 제네릭은 타입을 지정하기 때문에 형 변환의 번거로움을 줄일 수 있음
   ### 제네릭 사용 주의사항 
   - 제네릭 타입의 객체는 생성이 불가
     - new 연산자 뒤에 제네릭 타입 파라미터 불가
   - static 멤버에 제네릭 타입이 올 수 없음
     - static 멤버는 클래스가 동일하게 공유하는 변수로서 제네릭 객체가 생성되기도 전에 이미 자료 타입이 정해져있어야 하기 때문

   ### 타입 한정 키워드 extends
   - extends를 이용하여 해당 클래스의 하위 타입들만 받도록 할 수 있음

   ## 1.5 stream, lambda
   ### 1.5.1 stream
   - 데이터 소스를 조작 및 가공, 변환하여 원하는 값으로 변환해주는 인터페이스를 의미
   
   #### 특징
   - 원본의 데이터를 변경하지 않음
     - 별도의 Stream 객체로 생성
   - 재사용이 불가능해서 일회용으로 사용 됨
   - 내부 반복으로 작업을 처리

   #### 과정
   스트림 생성 -> 중간 연산 -> 최종 연산

   #### 병렬 스트림
   - 멀티 코어 CPU환경에서 하나의 작업을 분할해서 각각의 코어가 병렬적으로 처리
     - 작업 처리 시간을 줄임
   - 포크조인 프레임워크를 이용
     - 데이터를 서브 데이터로 반복적으로 분리 후 멀티 코어에서 병렬로 처리 -> 포크 단계
     - 서브 결과를 결합해서 최종 결과를 만들어 냄 -> 조인 단계
   - 성능
     - 병렬 처리가 항상 빠르진 않음
     - 영향을 미치는 요인 3가지
       - 요소의 수와 요소당 처리 시간
         - 요소의 수가 적고 요소당 처리 시간이 짧으면 순차 처리가 오히려 빠름 -> 병렬 처리는 스레드 풀 생성, 스레드 생성이라는 추가적인 비용 발생
       - 스트림 소스의 종류
         - ArrayList는 인덱스로 접근하여 쉽게 요소를 분리가능하지만, 해쉬나 트리셋 같은 것은 분리가 어려움
       - 코어의 수
         - 싱글 코어 CPU일 경우에는 순차 처리가 빠름 -> 병렬 처리를 할 경우 스레드의 수만 증가하고 컨텍스트 스위칭이 일어나서 안좋음

   ### 1.5.2 lambda
   - 함수를 하나의 식으로 표현한 함수형 인터페이스로 함수를 람다식으로 표현하면 메소드의 이름이 없기 때문에 익명함수의 한 종류라고도 함
   - 함수형 인터페이스 종류
     - Supplier - 매개변수는 없고 반환 값만 있음
     - Consumer - 매개변수만 있고 반환 값이 없음
     - Function - 일반적인 함수로, 하나의 매개변수를 받아ㅓ 결과를 반환
     - Predicate - 조건식을 표현하는데 사용되며 매개변수는 하나, 반환 타입은 불린 형

   ## 1.6 Reflection & Dynamic Proxy
   ### Reflection
   - 구체적인 클래스 타입을 알지 못하더라도 그 클래스의 메서드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API를 의미
   - 컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법

   #### 언제 사용할까
   - 동적으로 클래스를 사용해야할 때
     - 스프링 어노테이션
     - Intellij 자동완성
   
   #### Dynamic Proxy
   - 리플렉션을 통해 동적으로 프록시 객체를 생성
   - 인터페이스를 기준으로 프록시 생성
   - InvocationHandler를 구현하여 invoke로 호출해야함

# 2. Java 컬렉션
   ## 2.1 hashcode() & equals()
   ### equals()
   - 어떤 두 참조 변수의 값이 같은지 다른지 동등 여부를 비교할 때 사용하는 것
   - 비교할 대상이 객체인 경우 객체의 주소를 이용하여 비교(String은 안에 있는 값)
   - 두 개의 객체를 가지고 있을 때 안에 있는 값까지 모두 같으면 사실 같은 객체로 볼 수 있음
     - 이 것을 판단해서 만약 같아야하는 객체라면 equals()를 오버라이딩해서 두 객체가 같도록 처리해야함

   ### hashcode() 
   - 객체의 주소 값을 이용해서 해싱 기법을 통해 해시 코드를 만든 후 반환
   - 서로 다른 두 객체는 같은 해시 코드를 가질 수 업음
   - 주소 값으로 만든 고유한 숫자 값을 의미
   - hashCode()는 JNI를 통해 native 메서드를 이용
   - equals()를 오버라이딩하면 hashcode()도 오버라이딩해서 같은 객체로 취급해야 함
     - 안에 있는 값까지 같아서 같은 객체를 취급하는데 hashcode가 다른 경우 문제가 생김
     - 예를 들어, 해시 맵, 테이블 등을 이용할 때 논리적으로 같은지 비교할 때 hashcode를 먼저 비교하고 equals를 비교 함
       - 만약 hashSet에 똑같은 객체를 집어넣더라도 다른 해시코드를 가지고 있기 때문에 문제가 생김
   - identityHashCode -> 오버라이딩 해버리면 객체의 주소 값을 찾을 수 없는데 이 메서드를 이용하면 가져올 수 있음

   ### 동등성과 동일성
   - 동일성
     - 두 객체의 메모리 주소가 같음을 의미하는 것
   - 동등성
     - 두 객체가 논리적으로 동일한 값을 나타내고 이는지를 검사

   ## 2.2 Thread Safe & Syncronized
   - ThreadSafe란 멀티 스레드 프로그래밍에서 여러 스레드로부터 동시에 접근이 이루어져도 문제가 없는 것을 의미
   - 이를 위한 방법으로 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드의 방해를 받지 않도록 임계 영역과 잠금의 개념을 도입
   - Syncronized
     - 메서드 전체를 임계영역으로, 코드 블럭을 임계 영역으로
     - 최대한 메서드 전체를 감싸지 않고, 코드 블럭을 통해 최소한의 영역을 설정할 것
     - lock이 걸리는 스레드가 많아지고 병목 현상을 유발
   ### 2.2.1 Volatile
   - 원자성을 보장할 수 없지만, 가시성을 보장
   - 원자성
     - 소스코드가 한번에 실행된다는 것을 보장, 명령이 수행되는 동안 다른곳에서 접근 불가
   - 가시성
     - 한 쓰레드에서 공유 자원을 변경한 결과가 다른 쓰레드에서 확인할 수 있는것을 의미
   - 변수의 값을 읽어올 때 캐시가 아닌 메모리에서 읽어오게 됨
     - 같은 공유자원에 대한 같은 값을 가지게 되어 가시성을 보장
     - 하지만 동시 접근 문제 해결 불가
   - 하나의 쓰레드만 Read & Write하고 나머지 스레드가 Read하는 경우 사용
   ### 2.2.2 AtomicInteger
   - 원자성을 보장하는 변수
   - Atomic 변수의 경우 CAS(Compare And Swap) 알고리즘을 통해 동작
     - 현재 쓰레드가 존재하는 CPU의 캐시메모리 값과 메인 메모리에 저장된 값을 비교하여 일치하는 경우 새로운 값으로 교체, 일치하지 않을 경우 기존 교체가 실패되고 재시도
   - ConcurrentHashMap의 경우 값을 쓸 때 CAS와 synchronized 키워드를 사용
   ## 2.3 String
   ### 2.3.1 String vs StringBuffer vs StringBuilder 
   #### String
   - 불변 객체
   - 값은 생성 후 변경할 수 없음 -> 변경하려하면 새로운 객체가 생성되고 원래 객체는 변경되지 않음
     - 많은 메모리 사용으로 가비지 컬렉션이 빈번하게 발생 가능
  
   #### StringBuffer
   - 가변 클래스
   - 내부적으로 문자열을 추가하거나 변경할 때마다 새로운 객체를 생성하지 않음
   - 문자열의 추가, 수정, 삭제 작업이 자주 발생하는 경우 StringBuffer를 사용하는 것이 좋음
   - Thread-Safe해서, 멀티스레드 환경에서 안전하게 사용 가능

   #### StringBuilder
   - 가변 클래스
   - StringBuffer와 같은 기능을 제공하나, 단일 스레드 환경에서만 사용 권장
   - 멀티스레드에서는 사용 주의가 필요하며 Buffer보다 성능이 좋음
   ### 2.3.2 Immutable Object 
   - 한 번 생성된 이후 상태를 변경할 수 없는 객체를 의미
   - 생성 시점 이후로 변하지 않음
   - 장점
     - 스레드 안전
     - 데이터 일관성
     - 캐시 가능성
   - 단점
     - 객체의 상태가 변경될 때마다 새로운 객체 생성으로 인해 오버헤드가 발생할 수 있음(가비지 컬렉션)

   ### 2.3.3 `String a = ""` vs `String a = new String("")`
  - 리터럴을 사용하여 문자열을 생성할 때는 자바의 문자열 상수풀에 저장됨.
    - 문자열 상수풀은 JVM의 힙 메모리 영역에 존재하여, 문자열 리터럴의 재사용을 가능하게 함
  - new를 이용할 때는 항상 새로운 객체를 생성하여 메모리에 할당
    - 내용이 같아도 서로 다른 객체가 됨

# 1. Checked Exception과 Unchecked Exception의 차이에 대해서 설명해주세요.
# 2. static을 주로 언제 사용하시는지?
# 3. static은 JVM 메모리의 어떤 영역에서 사용되는지?
# 4. 병렬 처리는 항상 빠른가요? 병렬 처리에 영향을 미치는 요인을 말씀해주세요.
# 5. 리플렉션을 사용해본 경험이 있으신지? 있으시면 설명해주시고, 없으시면 언제 사용할 것 같은지 얘기해주세요.
# 6. Equals()와 Hashcode()에 대해서 설명해주세요.
# 7. 동등성과 동일성에 대해서 설명해주세요.
# 8. AtomicInteger가 무엇인지 설명해주세요. CAS는 무엇인가요?