## JPA

> ### 고아객체
>
> 일반적으로 고아객체란 부모 엔티티와의 관계가 끊어진 자식 엔티티를 말한다.
>
> 고아 객체 제거 기능은 부모 엔티티와 연관된 자식엔티티가 더이상 그 관계에서 참조되지 않을 때 자동으로 자식 엔티티를 삭제하는 기능. OneToMany, OneToOne 관계에서 사용 가능하다. 
>
> 주의 사항
>
> - 성능 고려
>   - 많은 수의 자식 엔티티가 있는 경우 성능 저하를 초래할 수 있다. (각 자식 엔티티에 대해 삭제 쿼리가 실행되므로)
> - 적용 범위
>   - 고아 객체 제거 기능은 오직 부모엔티티와의 관계가 귾어진 경우에만 적용된다.
>   - 자식 엔티티를 다른 부모 엔티티에 할당하면 고아가 아니게 되므로 삭제되지 않는다.
> - 명시적 삭제와의 차이
>   - 고아 객체는 자동으로 수행되는 반면 명시적 삭제는 개발자가 직접 삭제메소드를 호출해 수행해야 한다.
>   - 이러한 동작의 자동성을 인식하고 주의해서 사용해야 한다.
>
> ### 단뱡향/양방향 매핑
>
> 엔티티 간의 관계를 정의하는 방법.
>
> 단방향 매핑 (Undirectional Mapping)
>
> - 한 엔티티가 다른 엔티티를 참조할 수 있지만, 반대 방향으로는 참조가 어렵다.
> - 한쪽 방향에서만 관계를 관리할 수있다.
> - 구현이 간단하고 명확하지만, 반대 방향으로의 참조가 필요한 경우에는 적합하지 않을 수 있다.
>
> 양방향 매핑 (Bidirectional Mapping)
>
> - 양방향 매핑에서는 두 엔티티가 서로를 참조할 수 있다. 
> - 한쪽 엔티티에서 변경이 발생하면 관련 엔티티도 해당 변경을 인식할 수 있다.
> - 단방향 매핑에 비해서 복잡하고 관리해야 하는 영역이 많지만, 양쪽 엔티티간의 관계를 유연하게 관리할 수 있는 장점이 존재.
>
> ### N + 1 문제
>
> ORM을 사용할 때 발생하는 일반적인 성능 문제 중 하나.
>
> 엔티티와 그에 연관된 엔티티를 로드 시, 예상보다 많은 수의 SQL이 실행되어 성능 저하를 초래하는 상황을 말한다.
>
> 예를 들어, User : Post = 1 : N 이라고 할때, 
>
> User엔티티를 조회 시 연관된 Post를 조회하기 위해 N개의 쿼리가 추가적으로 발생하는 현상
>
> [해결 방안]
>
> 1. Fetch Join 사용
>    - fetch join 사용시 연관된 엔티티를 한번의 쿼리로 함께 로드할 수 있다.
> 2. Batch Fetching 설정
>    - 특정 수의 연관 엔티티를 한번의 쿼리로 불러오도록 설정할 수 있다.
> 3. Entity Graph 사용
>    - 특정 엔티티를 로드할 때 어떤 연관 엔티티를 함께 로드할 지 명시적으로 지정할 수 있다.
> 4. JPQL Fetch 조인 or Criteria API 사용
>    - 연관된 쿼리를 한번에 로드할 수 있다.

## 테스트 

> ### DDD, TDD
>
> Domain Driven Design
>
> DDD는 복잡한 요구 사항을 해결하기 위해 소프트웨어의 설계에 중점을 두는 방식.
>
> 비즈니스 도메인이 복잡하고, 이해관계자 간의 의사소통이 중요한 대규모 프로젝트에서 유용하다.
>
> - 핵심 개념 
>   - DDD 에서는 비즈니스 도메인과 그 안의 복잡성을 정확하게 이해하고 모델링하는 것이 핵심
>   - 이를 위해 유비쿼터스 언어를 사용해 개발자와 비즈니스 전문가 간의 의사소통 장벽을 최소화
> - 구현
>   - Entity, Value Object, Service, Repository, Aggregate와 같은 패턴을 사용해 비즈니스 로직을 구조화 함
> - 목표
>   - 복잡한 비즈니스 요구사항을 명확하고 유지보수 가능한 코드로 전환해, 소프트웨어가 비즈니스의 본질적인 문제를 해결할 수 있도록 하는 것이 목표
>
> Test Driven Development
>
> TDD는 소프트웨어 개발의 품질을 보장하기 위해 테스트 중심으로 한 개발 방식.
>
> 테스트를 먼저 작성하고, 이 테스트가 통과할 때 까지 코드를 개선하는 순환적인 과정을 포함
>
> - 핵심 개념
>   - 실패하는 테스트 케이스 작성 -> 테스트를 통과할 최소한의 코드 작성 -> 코드 리팩토링의 단계를 반복
>   - 위 과정을 통해 요구 사항에 대한 깊은 이해와 더불어, 고품질의 코드를 달성할 수 있다.
> - 구현
>   - TDD는 자동화된 단위 테스트를 사용해 소프트웨어의 각 부분이 예상대로 작동하는지 확인한다.
> - 목표
>   - 버그를 조기에 발견하고, 코드의 품질을 지속적으로 개선하며, 나중에 코드를 변경하거나 확장할 때 발생할 수 있는 리스크를 최소화 하는 것.
>
> ### Junit4 vs Junit5
>
> Junit은 자바 프로그래밍 언어를 위한 단위 테스트 프레임워크 중 하나이다.
>
> Junit5는 Junit4에 비해 많은 새로운 기능과 개선 사항을 도입했다.
>
> Juni4
>
> - 출시 : 2006년경
> - 주요특징
>   - @Test 어노테이션을 이용한 테스트 메소드 지정 
>   - @Before, @After, @BeforeClass, @AfterClass 어노테이션을 사용한 테스트의 전처리 및 후처리 작업 지정
>   - @Ignore 어노테이션을 사용한 테스트 무시
>   - assert 메소드를 통한 테스트 검증
>   - 예외 테스트를 위해 @Test(expected= Exception.class) 사용
>
> Junit5
>
> - 출시 : 2017년경
> - 주요특징
>   - Junit5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
>     - JUnit Platform : 테스트를 실행하는 런처 제공, 다양한 테스트 엔진을 지원 
>     - JUnit Jupiter : JUnit5의 새로운 테스트 작성 API 제공
>     - JUnit Vintage : JUnit3과 JUnit4를 실행하기 위한 지원 제공 
>   - @ExtendWith를 통한 더 유연한 확장 모델 제공 
>   - 람다를 사용한 동적 테스트생성 지원 
>   - @DisplayName 어노테이션으로 테스트 이름을 직관적으로 표현 
>   - @Tag를 사용한 테스트 필터링 
>   - @Nested를 사용한 중첩된 테스트 클래스 지원 
>   - @ParameterizedTest를 사용한 파라미터화 된 테스트 지원 
>   - assertThrows를 이용한 예외 테스트개선 
>   - 다양한 assert 메소드 제공
>
> ### 단위, 통합, 인수 테스트
>
> 단위 테스트 
>
> - 목적 
>   - 가장 낮은 수준인 소프트웨어의 개별 구성 요소나 함수의 동작을 검증한다.
> - 범위 
>   - 함수, 메소드, 클래스, 모듈 등을 대상으로 한다.
> - 특징
>   - 개발자에 의해 주로 작성되며, 개발 과정 초기에 구현됨
>   - 빠른 피드백을 제공하며, 지속적인 통합과 함께 자주 실행됨
>   - 의존성을 격리해 각 구성요소가 예상대로 독립적으로작동하는지 확인
>   - 리팩토링 및 유지 관리를 쉽게 하기 위해 코드의 구조를 개선하는데 도움을 줌
>   - 의존성이 있는 경우, Mock 객체를 사용해 실제 객체 대신 테스트 환경에서 사용할 수 있다.
>
> 통합 테스트
>
> - 목적 
>   - 다양한 모듈이나 서비스가 서로 올바르게 작동하는지 확인하는 것.
> - 범위
>   - 여러 모듈이나 서비스가 통합된 상태를 대상으로 함
> - 특징
>   - 데이터 흐름, 네트워크 통신, 데이터베이스, 파일 시스템 등 시스템의 다양한 부분 간의 인터페이스와 상호작용을 검증
>   - 단위 테스트가 놓칠 수 있는 결함 (모듈 간 인터페이스 오류, 데이터 흐름 문제 .. )을 발견하는ㄴ데 중요함
>   - 종종 테스트 환경을 실제 환경과 유사하게 구성
>   - Spring 에서는 @SpringBootTest를 사용해 ApplicationContext를 로드하고, 빈을 주입해 통합 테스트를 수행할 수 있다.
>   - 단위 테스트에 비해 실행 시간이 다소 길 수 있다.
>
> 인수 테스트 
>
> - 목적
>   - 소프트웨어가 사용자의 요구사항과 기대를 충족하는지 확인 하는 것 
> - 범위
>   - 완성된 시스템 전체 또는 주요 기능을 대상으로 함 
> - 특징 
>   - 실제 사용자나 고객에 의해 또늘 그들을 대신해 수행됨
>   - 사용자 스토리, 비즈니스 프로세스, 시스템 요구 사항 등 실제 운영 환경에서의 시나리오를 기반으로 함
>   - 사용자 친화적인 언어 (BDD 스타일)로 작성될 수 있으며, 사용자 인터페이스, 성능, 보안 등을 포함한 시스템 전체적인 동작을 검증
>   - 성공적인 인수 테스트는 소프트웨어가 출시될 준비가 되었음을 의미함.
>   - 보통 Cucumber나 SpecFlow와 같은 도구를 사용해 인수 테스트를 진행한다. 
>
> ### stub, mock
>
> stub, mock 모두소프트웨어 개발에서 테스트를 용이하게 하기 위해 실제 객체의 행동을 모방하는 test double.
>
> Stub
>
> - 목적
>   - Stub은 테스트 중인 객체에 대한 입력을 제공한다. 일반적으로 테스트 중인 객체가 의존하는 다른 외부 시스템이나 모듈을 대체하기 위해 사용됨
> - 특징
>   - 단순한 구현을 가지며, 테스트 중인 코드가 정상적으로 실행될 수 있도록 특정 상황을 simulation
>   - 주로 하드코딩된 응답이나 미리 정의된 동작을 반환 
>   - 테스트 중인 코드의 실행 흐름을 제어하기 위한 수단으로 사용됨
>   - 호출되는 방식이나 횟수 등에 대해서는 관시밍 없으며, 오로지 테스트를 위한 필요한 응답을 제공하는 데 집중
>
> Mock
>
> - 목적
>   - 테스트 중인 객체와 상호작용하는 객체의 동작을 모방한다.
>   - Stub보다 복잡하며, 테스트 중인 객체와 상호작용하는 방식을 검증하는 데 사용된다.
> - 특징
>   - Mock 객체는 테스트 중인 객체와의 상호작용을 기록하고, 이를 검증하는 데 사용된다.
>   - 테스트의 마지막에 주로 검증 단계를 포함해 특정 상호작용이 발생했는 지 확인한다.
>   - 상호작용의 세부적인 사항까지 제어하고 검증하는데 중점을 둔다.
>
> ### SpringBoot 계층별 테스트 방법
>
> - Repository, Service Layer
>   - @SpringBootTest, 즉 통합테스트를 사용해서 테스트 검증
> - Controller Layer
>   - @WebMVCTest, Service Layer Mocking
>
> ### 테스트 커버리지 (JACOCO)
>
> Java Code Coverage Library로 Java 코드의 코드 커버리지를 측정하기 위한 라이브러리.
>
> 코드커버리지는 테스트 케이스가 얼마나 많은 코드를 실행했는지를 나타내는 지표로, 테스트의 품질과 완전성을 평가하는데 중요한 도구. JaCoCo는 테스트 실행중에 코드 실행 정보를 수집하고, 이를 다양한 형태의 리포트로 제공해 개발자가 소프트웨어의 테스트 커버리지를 쉽게 분석할 수 있도록 도와준다.
>
> 특징
>
> 1. 코드 커버리지 측정
>    - 라인 커버리지, 분기 커버리지, 메소드 커버리지 등 다양한 커버리지 지표를 제공한다.
>    - 어느 부분이 테스트 되었고, 어느 부분이 테스트되지 않았는지를 명확하게 파악할 수 있다.
> 2. 통합성
>    - Maven / Gradle 과 같은 빌드 도구와 잘 통합되며, CI/CD 파이프라인에도 손쉽게 통합될 수 있다.
> 3. 리포트 생성
>    - 커버리지 데이터를 기반으로 XML, HTML, CSV 형식의 리포트를 생성할 수 있다.
> 4. IDE 통합
>    - Eclipse, IntelliJ IDEA와 같은 Java IDE와 통합될 수 있다.
> 5. OnTheFly Instrumentation
>    - 코드를 컴파일 시점에 변경하지 않고, JVM에 로드될 때 코드에 소량의 정보를 추가하는 OnTheFly Instrumentation 방식을 사용.
>    - 실행 중인 애플리케이션에 영향을 주지 않으면서도 정확한 커버리지 정보를 수집할 수 있다.