# 고아객체
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티
- 부모가 제거되면 -> 자식도 제거될 수 있음
- 조건 : 참조하는 곳이 하나인 경우에만 사용, 특정 엔티티가 소유하고 있는 경우 사용
- cascade.all + orphanremoval = true (jpa를 통해 생명주기를 관리할 수 있다.)
- 부모 엔티티를 통해 자식 엔티티의 생명주기를 관리할 수 있다.

# 단방향 양방향 매핑
## 단방향
- 객체의 참조로 연관관계를 맺는다.(강결합)
- 연관관계의 주인이 중요 : 1대 다의 경우 n+1문제를 비롯한 다양한 이슈가 발생할 수 있음 
- 어떤 방향으로 정보 탐색이 필요한 지 알야아 한다. (멤버가 팀을 알건지, 팀이 멤버를 알건지)
- 컬렉션을 사용할 경우 초기화 해주는 것이 관레 (npe방지)

## 양방향
- 단방향이 서로 다르게 있음, 테이블은 외래키 하나로도 조인이 가능(기본 양방향임)
- 연관관계 편의 메서드를 사용해 둘의 정보 업데이트를 동일시하기도 함

# n+1 문제
eager시
1. JPQL에서 만든 SQL을 통해 데이터를 조회
2. 이후 JPA에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회
3. 2번 과정으로 N + 1 문제 발생

FetchType.LAZY의 경우 순서는 다음과 같다
1. JPQL에서 만든 SQL을 통해 데이터를 조회
2. JPA에서 Fetch 전략을 가지지만, 지연 로딩이기 때문에 추가 조회는 하지 않음
3. 하지만, 하위 엔티티를 가지고 작업하게 되면 추가 조회가 발생하기 때문에 결국 N + 1 문제 발생

### 원인
- JPQL은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리를 한다.
- jpql은 해당 엔티티를 조회하는 쿼리만 실행한다. 연관관계 데이터를 무시함 (해당 엔티티를 기준으로 쿼리를 조회하기 때문)
- 연관된 데이터가 필요하면 fetchtype을오 지정한 시점에 조회를 별도로 호출함

### 해결
1. fetch join
- 데이터의 양이 많으면 성능 저하 발생
- fetch joini은 jpa에 종속적이라 이식성이 덜어질 수 잇음

2. @EntityGraph
- 1에서 다 필드에 entitygraph을 적용
- 동적인 쿼리는 어려움, 추가 작업이필요
3. batchSize
- 사이즈만큼 일괄 로딩을 수행한다.
- 연관 엔티티가 많으면 n+1이 발생한다. 적절한 사이즈 설정이 필요

# DDD, TDD
### 도메인 주도 개발
- 도메인에 대한 깊은 이해를 바탕으로 도메인 모델 중심의 소프트웨어를 개발하고 설게하는 접그ㅡㄴ법
- 데이터 중심의 접근을 지양하기 위해 도입
- 도메인 : 요구사항, 소프트웨어로 해결하고자 하는 개념 영역
- 엔티티 : 테이블 모델
- aggregate : 엔티티와 vo의 모음, 일관성과 트랜잭션, 분산의 단위

### 테스트 주도 개발
**장점**
- 객체지향적 코드 생산
- 재설계 시간 단축
- 디버깅 시간 단축
- 테스트 문서 대체 가능
- 추가 구현 용이함
**단점**
- 실제 코드보다 중요성이 커질 수 있음
- 예측할 수 없는 문제에 대한 대비가 부족할 수 잇음
- 원칙에 갇힌 행동만 행하게될 수도 있음 

## 단위테스트
- 테스트 가능한 가장 작은 단위를 실행하여 예상대로 동작하는지 확인하는 테스트
- 클래스나 메소드 단위로 테스트를 진행함
- 화이트박스(소프트웨어 내부 코드 지식을 반드시 알고 있어야한다.)

## 통합 테스트
- 개발자가 변경할 수 없는 부분까지 묶어서 검증할 때 사용한다.
- 단위테스트보다 더 많은 코드를 테스트해 신뢰성이 떨어지고, 어디서 문제가 발생했는지 유지보수가 어렵다.

## 인수 테스트
- 사용자 스토리에 맞춰 수행하는 테스트이다.
- 프로젝트를 참여하는 사람들이 시나리오를 만들고 개발자가 코드를 작성한다.
- 누가 어떤 목적으로 무엇을 하는 경우에서 판단을 한다.
- 명세한 요구사항대로 잘 동작하는지 검증이 필요(사용자 관점 테스트)
- RestAssured, MockMvc를 활용해 인수테스트를 진행한다.

## Junit4 vs Junit5
- 표현이 더 직관적
- Reflection에 의존하지 않아도 됨
- 테스트코드 통합 지원 플랫폼이 제공되어 그 플랫폼 위에서 작업할 수 있게 됨
- private메소드를 테스트할 수 있다.(Reflection 사용)
- junit 5 : junit platform + junit jupiter + junit vintage

# stub,mock
### 테스트 더블
테스트를 진행하기 어려운 경우 일르 대신해 테스트를 진행하도록 만들어주는 객체

### dummy
- 인스턴스화 객체가 필요하지만 기능은 필요하지 않은 경우
- dummy 객체의 메서드가 호출되었을 댸 정상 동작은 보장하지 않음

### fake
- 복잡한 로직이나 객체 내부에서 필요한 다른 객체의 동작을 단순화해 구현함
- ex : 가짜 db역하을 하는 repository를 만들어 테스트 객체에 주입

### stub
- dummy 객체가 실제로 동작하는 것처럼 보이게 만들어 놓은 객체
- 인터페이스나 기본 클래스가 최소한으로 구현됨 
- 테스트에서 호출된 요청에 따라 미리 준비한 결과를 제공함(동일한 결과를 제공)

### spy
- stub 역할을 가지며 호출된 내용에 약간의 정보를 기록한다.
- 실제 객체로 동작하고 필요한 경우 stub을 활용해 동작을 지정하기도 한다.

### mock
- 호출에 대한 기대를 명세하고 내용에 따라 동작하돌독 프로그래밍 한다.
- 어떤 결과를 반환할지 결정할 수 잇음

# springboot 계층별테스트 방법
- controller테스트 : 원하는 요청 전달과 원하는 응답이 잘 오는지를 확인하는 테스트
- service테스트 : 핵심적인 비즈니스 로직의 값전달에 대한 확인
- 도메인 테스트 : 검증과같이 검사해야하는 값들에 대한 검증을 거치고 확인하는 단계의 테스트
- 통합테스트 : 기능이 전반적으로 정상 작동하는지 확인하기 위한 방법

# 테스트 커버리지 (JACOCO)
- 시스템 및 소프트웨어에 대해 충분히 테스트가 되었는지를 나타내는 정
- 함수 커버리지, 구문 커비리지, 결정 커버리지, 조건 커버리지
- 높은 커버리지 : 더 과감한 코드 리팩토링이 가능하다. 배포도 마찬가지
- 불필요한 코드를 생략할 수 있게 됨
- 프로덕션 코드를 높일 수 있음

