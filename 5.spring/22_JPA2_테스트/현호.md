# JPA
## 고아객체
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능입니다. 예를 들어 부모 엔티티가 가지고 있는 자식 엔티티 리스트에서 자식 엔티티가 삭제되었을 경우에 자동으로 엔티티 객체에 대한 deleate쿼리가 나갑니다. 또한 부모 객체가 삭제되었을 경우에도 부모 객체에 연관되어 있던 모든 자식 객체들에 대해서 delete쿼리가 나갑니다.
- @OneToMany 쪽에 orphanRemoval = ture 옵션을 주어 고아객체 옵션을 지정합니다.
## 단뱡향/양방향 매핑
### 테이블 vs 객체
- 데이터베이스에서 테이블은 외래키를 통해 다른 테이블과 연관 관계를 맺을 수 있어서 양방향 연관 관계를 가지고 있다고 볼 수 있습니다. 예를 들어 사용자 테이블과 주문 테이블이 있을 때, 주문 테이블의 사용자 ID 외래키를 통해 사용자 테이블과 연관 관계를 맺을 수 있습니다. 이 경우 사용자는 자신이 어떤 주문을 가지고 있는지 알 수 있고, 반대로 주문도 어떤 사용자에게 속하는지 알 수 있습니다.
- 반면에 객체 지향 프로그래밍에서 객체의 연관 관계는 참조를 통해 맺어지며 JPA연관관계도 마찬가지입니다. 만약 사용자 객체만 주문 객체에 대한 참조를 가지고 있다면, 사용자는 주문에 대한 정보를 알 수 있지만, 반대로 주문 객체는 사용자에 대한 정보를 알 수 없습니다. 주문 객체가 사용자 객체를 알기 위해서는 별도의 참조를 설정해야 합니다.
### 단방향/양방향
- 위 예시 처럼 두 엔티티 중 한 쪽만 참조하는 것을 단방향 관계라고 하며, 두 엔티티 중 양쪽 모두 서로를 참조하는 것을 양방향 관계라고 합니다.
## N + 1 문제
- 연관관계에 있는 하위 엔티티가 Lazy Loading(FetchType.LAZY)으로 설정되어있을 경우, 부모 엔티티를 조회하는 쿼리 한 번에 하위 엔티티를 모두 가져오지 않고, 하위 엔티티가 필요할 때마다 쿼리가 따로 나가게 되어, 여러 번의 쿼리가 나가게 되는 문제입니다.
### 해결법
- **해결법 1**. JPQL <join fetch> : 일반적으로 JPARepository에서 JPQL 페치 조인으로 한 번에 모든 엔티티를 가져오도록 처리.   
- **해결법 2**. EntityGraph : JPQL 문에 페치 조인문을 넣는 대신 @EntityGraph에 즉시 로딩으로 가져올 필드명을 명시. 

  (JPQL은 inner join, Entity Graph는 outer join이라는 차이점이 있음)

# 테스트
## DDD, TDD
### DDD
소프트웨어 개발 방법론 중 하나로, 도메인 중심의 설계를 강조합니다. 데이터 중심의 개발 방식에서 벗어나서 비즈니스 도메인을 잘 정의한뒤, 도메인 모델 중심으로 소프트웨어를 구축합니다. 보통 비즈니스 문제를 해결하기위한 도메인 객체들을 정의하고 이를 엔티티와 분리하여 객체지향적인 개발을 최대화하는 것을 목표로합니다.  

### TDD
기능 개발에 앞서 테스트 코드 작성을 우선으로하고, 기능 개발 후에는 작성된 테스트를 바탕으로 리팩토링을 하는 개발 프로세스입니다. 작성된 테스트 코드 덕분에 리팩토링 사이클이 짧아질 수 있다는 장점이 있으며, 테스트 먼저 작성하는 과정에서 기능 요구사항에 대한 이해도가 향상될 수 있다는 장점이 있습니다. 그러나 빠르게 기능 개발이 되어야하는 상황에서는 다소 생산성이 떨어질 수 있다는 단점이 있습니다.   
## Junit4 vs Junit5
차이 1. Junit4는 한 가지의 큰 모듈로 제공되었지만, Junit5는 세 가지 다른 모듈로 나뉘었음. 경우에 따라 필요한 모듈만을 사용할 수 있고, 프레임워크의 확장성과 유연성이 개선되었다.  
차이 2. @BeforeEach, @AfterEach, @BeforeAll, @AfterAll 등의 추가 어노테이션이 생겼음.  
차이 3. JUnit4는 Hamcrest 라이브러리를 사용하여 어설션을 제공하지만, JUnit5는 자체 어설션 라이브러리를 제공.

## 단위, 통합, 인수 테스트
### 단위 테스트
- 단위 테스트는 어플리케이션에서 테스트 가능한 가장 작은 단위를 실행하여 예상대로 동작하는지 확인하는 테스트.  
- 예를 들어 클래스나 메서드, 기능과 같이 가장 작은 단위에 대한 테스트. 단위 테스트는 빠르게 실행되고, 특정 기능이 올바르게 동작하는지를 검증하는 데에 중점을 둔다.      
### 통합 테스트
- 통합 테스트는 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트.

### 인수(Acceptance) 테스트
- 사용자 스토리(시나리오)에 맞춰 수행하는 테스트이다.
- 소프트웨어를 인수하기 전에 명세한 요구사항대로 잘 작동하는지 검증이  필요한데, 이 때 사용자 관점에서 API 요청하는 흐름 등을 시나리오로 짜고, 이 모든 요청이 잘 동작하는지 테스트해보는 것을 인수 테스트라 한다.  
## stub, mock
- stub과 mock은 테스트 중에 다른 객체를 대신하여 사용되는 가짜 객체
- stub은 테스트 중에 필요한 값을 반환하기 위해 사용됨. 예를 들어, 외부 서비스에 의존하는 코드를 테스트할 때, 테스트용 stub을 사용하여 외부 서비스의 응답을 가짜로 생성할 수 있음.
- mock은 테스트 중에 객체 간의 상호작용을 검증하기 위해 사용됨. 예를 들어, mock 객체를 사용하면 특정 메소드가 다른 객체에서 호출되는지 여부를 확인할 수 있음. mock 객체로 호출 여부, 호출 횟수, 전달된 인자 등을 검증할 수 있음.  
## SpringBoot 계층별 테스트 방법
### Controller : MockMVC를 활용하여 API요청 테스트 수행. 문서화를 위한 테스트를 작성하는 경우도 있음. 
### Service : 비즈니스 메서드가 적절히 호출되는지 검증(Mock객체 만들어서 호출만 검증하는 경우)
### Repository : DB 접근이 잘 수행되는지 검증.
### Domain : 순수 단위 테스트


## 테스트 커버리지 (JACOCO)
테스트가 어플리케이션의 코드 중 어느 정도를 커버하고 있는지를 측정하는 지표.
JACOCO는 커버리지 특정을 위하여 자주 사용되는 도구.
