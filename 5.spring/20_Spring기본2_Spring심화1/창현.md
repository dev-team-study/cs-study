# 1. Spring 기본
  ## 1.1. IoC (제어의 역전)
  - 개발자가 제어해야할 요소들을 SpringFramework가 대신 제어해주는 것을 의미
  - DL: 저장소에 저장되어 있는 Bean에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 LookUp하는 것을 의미
  - DI: 각 클래스 간의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것

  ### 1.1.1 IoC Container란
  - 객체를 생성하고 관리하고 책임지고 의존성을 관리해주는 컨테이너를 의미

  ### 1.1.2 Ioc Container의 특징
  - Spring Framework의 핵심 요소로, 객체를 생성하고 의존성을 구성하고 결합하며 생명 주기를 관리
  - DI를 사용해 애플리케이션에서 구성하는 컴포넌트들을 관리
  - xml파일과 java 코드, 어노테이션, java POJO 클래스를 통해 객체에 대한 정보를 가져오는데, 이러한 객체를 Bean이라고 부름
  - 객체들의 생명주기가 개발자가 아닌 프레임워크의 제어를 통해 진행되기 때문에 제어의 역전이라고 부름

  ### 1.1.3 IoC Container의 종류
  - BeanFactory
    - 단순히 컨테이너에서 객체를 생성하고 DI를 처리하는 기능만 제공
    - Bean을 등록, 생성, 조회, 반환 
    - 팩토리 디자인 패턴을 구현한 것으로 빈을 생성하고 분배하는 책임을 가짐
  - ApplicationContext (= IoC Container라고 볼 수 있음)
    - Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같다.
    - 스프링의 각종 부가 기능을 추가로 제공
      - 국제화가 지원되는 텍스트 메세지를 관리
      - 이미지 같은 파일 자원을 로드할 수 있는 포괄적인 방법을 제공
      - 리스너로 등록된 빈에게 이벤트 발생을 알려줌

  ## 1.2 DI
  - IOC를 구현하는데 사용되는 패턴
  - 객체를 다른 객체와 연결하거나 객체를 다른 객체에 주입하는 것
  - 예
    - 어떤 인스턴스에서 new로 생성하여 다른 인스턴스를 사용하는 것은 DI가 아님
    - 프레임워크가 미리 인스턴스를 생성해두고 필요에 따라 프레임워크가 의존 주입을 하는 것은 DI가 맞음
  - 의존 관계란
    - 의존 대상 B가 변하면, 그것이 A에 영향을 미침
    - 에를 들어, 햄버거 요리사는 햄버거 레시피에 의존하고 있는데 햄버거 레시피가 변화하게 되면 햄버거 요리사는 변화된 레시피에 따라서 햄버거 만드는 방법을 수정해야 함
  - 의존 관계를 인터페이스로 추상화하기
    - 햄버거 요리사는 햄버거 레시피가 아닌 버거 레시피에 의존하면 치즈버거든 햄버거든 치킨 버거든 다양한 의존 관계를 맺을 수 있으며 구현 클래스와의 관계가 느슨해짐

  ### 1.2.1 Setter Injection(수정자 주입)
  - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존 관계를 주입하는 방법
  - 선택과 변경 가능성이 있는 의존 관계에 사용 
  ```java 
  @Component
  public class MemberService {
    private final MemberRepository memberRepository;

    @Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
  }
  ```

  ### 1.2.2 Constructor Injection(생성자 주입)
- 생성자 호출 시점에 1번만 호출되는 것을 보장
- 불변과 필수 의존 관계에 사용
- 생성자가 1개만 존재하는 경우 @Autowired를 생략해도 자동 주입 됨

  ```java
  @Component
  public class MemberService {
    private final MemberRepository memberRepository;

    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
  }
  ```

  ### 1.2.3 Field Injection (필드 주입)
- 필드에 @Autowired르 붙여서 바로 주입
- 코드가 간결해짐
- 외부에서 변경이 불가능하여 테스트하기 어려움
- 테스트 코드에서 보통 사용
- 사용하지 않는 이유
  - 필드 주입을 하게 되면 DI 컨테이너 안에서만 동작하게 됨, 순수 자바 코드로 테스트하기 어려움


  ## 1.3 Bean, Component
  ### 1.3.1 @Bean
  - 보통 Configuration할 때 사용하며 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶을 때 사용
  - 예를 들어 ObjectMapper를 @Component를 선언할 수 없으니 new로 생성하여 해당 메서드를 Bean으로 등록
  - 어노테이션은 메서드에 선언 가능

  ### 1.3.2 @Component 
  - 반대로 직접 컨트롤이 가능한 Class들의 경우 @Component를 붙임
  - Spring에서 관리되는 객체임을 표시하기 위해 사용하는 가장 기본적인 어노테이션
  - 어노테이션은 타입에 선언 가능
  
  ### 1.3.3 @Service 
  - 비지니스 로직이나 레파지토리를 호출하는 클래스에 사용 됨
  
  ### 1.3.4 @Controller
  - Web MVC 코드에 사용되는 어노테이션
  - `@RequestMapping` 어노테이션을 해당 어노테이션 밑에서만 사용 가능
  
  ### 1.3.5 @Repository
  - 데이터와 관련된, 데이터베이스에 접근하는 로직에 사용되는 어노테이션
  - Hibernate와 같은 영송석 프레임워크를 사용할 경우, 선언된 클래스에서 발생하는 영속성 예외를  스프링의 예외로 자동전환 해줌

  ## 1.4 Container
  - 객체를 담는 공간이라고 볼 수 있음
  - 객체의 생명주기를 관리하고 생성된 객체에게 추가적인 기능을 제공

  ## 1.5 VO vs DTO vs DAO
  ### 1.5.1 DAO
   - DB의 데이터에 접근하기 위한 객체를 의미
   - DB에 접근하기 위한 로직을 분리하기 위해 사용하며, 직접 DB에 접근하여 data를 삽입, 삭제, 조회 등 조작할 수 있는 기능을 수행
  ### 1.5.2 DTO
  - 계층 간 데이터 교환을 위한 Java Bean을 의미
  - 로직을 가지지 않는 데이터 객체이며, 데이터를 설정하거나 꺼내쓰는 메소드만 가진 클래스를 의미

  ### 1.5.3 VO
  - Value Object의 약자로, 읽기만 가능한 불변의 값 오브젝트
  - 단순히 값을 표현하기 위해 불변 클래스를 만들어 사용, Getter만 존재
  - 한개 또는 그 이상의 속성들을 묶어서 특정 값을 나타내는 객체를 의미
    - ex x,y로 이루어진 2차원 좌표를 표현할 때
  - VO는 보통 equals와 hashCode를 재정의하여 속성 값이 같은 객체는 같은 객체임을 보장하도록 함
  
  #### 1.5.3.1 VO의 이점
  - 엔티티의 원시 값들을 VO로 포장하면 Entity가 지나치게 거대해지는 것을 막을 수 있음

# 2. Spring 심화
  ## 2.1 AOP
  - 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화
  - 공통관심사를 모듈화하여 코드의 중복을 줄이는 것
  
  ### 2.1.1 AOP 주요 개념
  - Aspect: 흩어진 관심사를 모듈화한 것, 주로 부가기능을 모듈화함
  - Target: Aspect를 적용하는 곳
  - Advice: 실질적으로 어떤 일을 해야할 지에 대한 것
  - JointPoint: Advice가 적용될 위치
  - PointCut: JointPoint의 상세한 스펙을 정의한 것

  ### 2.1.2 스프링 AOP의 특징
  - 런타임 시점
  - 프록시 패턴 기반의 AOP 구현체
    - 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기 위해서
  - 스프링 빈에만 AOP를 적용 가능
  
  ## 2.2 프록시 패턴
  - 초기화 지연, 접근 제어, 로깅, 캐싱 등, 기존 대상 원본 객체를 수정 없이 추가 동작 기능들을 가미하고 싶을 때 사용하는 코드 패턴
  - 개방 폐쇄 원칙의 효과를 얻을 수 있어 코드 수정 없이 유연하게 확장 가능
  - 하지만 프록시 패턴은 원본 클래스 수 만큼 프록시 클래스를 일일이 하나씩 만들어야하는 단점이 있음

  ## 2.3 JDK Dynamic Proxy
  - 프록시 패턴의 단점을 보완하여 컴파일 시점이 아닌 런타임 시점에 프록시 클래스를 만들어주는 방식
  - 개발자가 직접 일일이 프록시 객체를 생성하는 것이 아닌, 프록시 패키지에서 제공하는 API를 이용하여 동적으로 프록시 인스턴스를 만들어 등록하는 방법 Reflection API 기법을 응용한 연장선의 개념
  - InvocationHandler를 구현하여 method.invoke로 로직을 수행 그 전과 그 후에 부가적인 기능들을 수행할 수 있음
  - 제약 사항
    - 타입을 클래스가 아닌 무조건 인터페이스를 파라미터로 넣어야 한다는 점

  ## 2.3 CGLIB
  - 바이트코드를 조작하여 동적 프록시 기술을 응용하는 라이브러리를 이용해 편하게 동적 프록시를 생성 가능
  - 인터페이스가 아닌 클래스를 대상으로 함
  - Dynamic Proxy보다 성능이 좋아 Spring 프레임워크에서 기본으로 내장되어있음
  - interface가 하나라도 구현하고 있으면 Dynamic Proxy를 이용하고 아니면 CGLIB를 사용함 
  - 사용법
    - Enhancer객체로 프록시 객체를 만들고, MethodInterceptor 인터페이스로 프록시 핸들러를 등록
  - 주의 사항
    - 기본적으로 클래스 상속을 통해 프록시 구현이 됨, 타겟 클래스가 상속이 불가능할 때는 프록시 등록이 불가능
    - 메서드에 final 키워드가 붙으면 그 메서드를 오버라이딩할 수 없어 결과적으로 프록시 메서드 로직이 작동 안됨
    - 상속에 있어서 제한이 있으면 안됨
      - 추상 클래스
      - 생성자를 private화하여 제한할 경우
      - 클래스와 메서드에 final