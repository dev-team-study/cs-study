## Spring 기본

> ### IoC (Inversion Of Control)
>
> 객체의 생성과 의존성 관리를 프로그램 코드가 아닌 외부 시스템에 위임하는 것을 말한다. 
>
> Spring의 경우 IoC는 주로 컨테이너를 통해 구현된다. 
>
> IoC의 주된 목적은 코드 간 결합도를 낮추고, 유연성 및 재사용성을 높이는 것이다.
>
> [핵심 개념]
>
> - 제어의 역전 
>   - 제어의 권한이 프레임워크나 컨테이너로 넘어간다.
> - 의존성 관리
>   - 객체는 필요한 의존성을 직접 생성하거나 찾지 않는다. 대신, 이러한 의존성은 외부에서 제공된다.
> - 결합도 감소 
>   - 객체는 서로 느슨하게 연결되어 있어, 변경이나 확장이 용이하다.
>
> 의존성 주입 예시 
>
> ```java
> public class MemberService{
>   private final MemberRepository memberRepository;
>   
>   public MemberService(MemberRepository memberRepository){
>     this.memberRepository = memberRepository;
>   }
> }
> ```
>
> 해당 코드에서 MemberRepository의 인터페이스를 구현한 클래스를 Container에 등록된 빈 들 중에 찾아 의존성 주입을 해준다. 
>
> ### DI (Dependency Injection)
>
> 객체가 직접적으로 의존성(다른 객체)을 생성하지 않고, 이러한 의존성을 외부로부터 주입받는 방식을 말한다. 
>
> 객체간의 결합도를 낮추고, 유연성과 재사용성을 높이며, 테스트를 요이하게 만드는 등의 장점을 제공한다. 
>
> [핵심 개념]
>
> - 객체의 의존성 분리 : 객체는 자신이 필요로 하는 의존성을 직접 생성하지 않고, 외부로부터 주입받는다.
> - 결합도 감소 : 객체는 의존성에 대한 구체적인 세부사항을 몰라도 되기 때문에 코드 간 결합도가 낮아진다.
> - 테스트 용이성 증가 : 의존성을 외부에서 주입받기 때문에 mock 객체 등을 사용해 단위 테스트를 용이하게 할 수 있다. 
> - 유연한 코드 구조 : 의존성이 외부에서 주입되므로, 구성 변경이나 대체 구현 사용이 쉽다.
>
> [주입 방식]
>
> 1. 생성자 주입
> 2. 세터 주입
> 3. 필드 주입
>
> ### Bean, Component
>
> 두가지 모두 Spring의 ApplicationContext에 클래스를 등록하는데 사용된지만 사용 방식과 목적에 있어 차이점이 존재한다. 
>
> #### Bean
>
> - Method Level Annotation : 메소드 레베렝서 사용되며, 해당 메소드가 반환하는 객체를 Spring 컨테이너에 빈으로 등록
> - 수동 빈 생성과 등록 : 개발자가 직접 제어가 필요한 빈의 생성과 속성 설정을 할 수 있다. @Configuration 어노테이션이 붙은 클래스 내의 메서드에 @Bean을 사용 
> - 사용 사례 : 외부라이브러리 객체나 사용자 정의 설정이 필요한 복잡한 빈에 주로 사용됨
>
> #### Component
>
> - Class Level Annotation : 클래스 레벨에서 사용되며, 해당 클래스를 Spring 컨테이너에 빈으로 등록
> - 자동 검색과 등록 : Spring은 Component Scan을 통해 @Component 어노테이션이 붙은 클래스를 자동으로 찾아 빈으로 등록한다. 
> - 일반적인 사용 사례 : 사용자가 직접 정의한 클래스 (Service, Repository, Controller..)
>
> ### @Component @Service @Controller
>
> Spring 컨테이너에 의해 관리되는 빈을 정의할 때 사용되는 어노테이션들이다.
>
> #### @Component
>
> - 일반적인 구성 요소 : 가장 일반적인 스테레오타입 어노테이션으로 Spring이 관리하는 컴포넌트를 나타냄
> - 범용적 사용 : 특정 계층(서비스, 컨트롤러 .. )에 속하지 않는 일반적인 빈에 사용됨
> - 범용적인 의존성 주입 : 다른 빈에 의존하는 모든 종류의 클래스에 적용할 수 있다.
>
> #### @Service
>
> - 서비스 계층 표시 : 비즈니스 로직을 처리하는 서비스 계층의 컴포넌트를 나타냄
> - 비즈니스 로직의 추상화 : 도메인 관련 비즈니스 로직을 캡슐화
> - 의미적 명확성 : 비즈니스 로직이 포함된 클래스에 사용해, 애플리케이션의 아키텍처에서 해당 클래스의 역할을 명확히 할 수 있다.
>
> #### @Controller
>
> - 웹 계층 표시 : MVC 패턴의 컨트롤러를 나타낸다.
> - 웹 요청 처리 : HTTP 요청을 처리하고 응답을 반환하는 컨트롤러 클래스에 사용됨
> - 웹 계층과의 상호작용 : 사용자의 요청에 대한 입력 처리, Model 업데이트, 뷰이름 반환을 담당한다.
>
> ### Container
>
> 스프링 프레임워크에서 어플리케이션의 구성 요소를 인스턴스화, 구성, 관리하는 역할을 한다. 특히 IOC 패턴을 구현하는데 중요한 역할을 하며, 이를 통해 객체의 생명주기와 의존성 관리를 담당한다. 
>
> [주요 역할]
>
> - 객체 생성과 관리 
>   - 컨테이너는 어플리케이션에서 사용되는 객체(Bean)들을 생성하고 관리한다.
> - 의존성 주입
>   - 컨테이너는 의존성 주입을 통해 객체간의 의존성을 자동으로 해결한다. 
>   - 객체는 필요한 의존성을 직접 생성하거나 찾지 않고, 컨테이너로부터 제공받는다.
> - 설정과 구성 
>   - XML, 어노테이션, 자바 기반 설정등을 통해 애플리케이션의 구성을 정의하고 컨테이너는 이 정보를 바탕으로 객체를 구성한다.
> - 생명 주기 관리 
>   - 컨테이너는 빈의 생명 주기를 관리하며, 필요에 따라 초기화 및 소멸 과정을 수행한다.
> - 자원 관리
>   - 컨테이너는 데이터베이스 연결과 같은 자원을 관리하고, 필요할 때 애플리케이션에 제공한다.
> - AOP 지원 
>   - 컨테이너는 AOP를 지원해 횡단관심사를 애플리케이션의 주요 로직에서 분리할 수 있도록 돕는다.
>
> ***Application Context 및 BeanFactory가 스프링에서 제공하는 주요 컨테이너이다.***
>
> ### VO vs DTO vs DAO
>
> - VO (Value Object)
>   - 데이터 불변성 : VO는 불변성을 가진 객체로, 생성 후 그 상태가 변경되지 않음
>   - 값 비교 : VO는 주로 값의 비교를 위해 사용되며, 객체의 동등성은 VO가 포함하는 데이터 값에 의해 결정된다
>   - 읽기 전용 데이터 : 주로 읽기 전용 데이터를 위해 사용되며, 데이터의 변경이 필요하지 않은 경우에 적합
> - DTO (Data Transfer Object)
>   - 데이터 전송 목적 : DTO는 계층 간 데이터 전송을 위해 사용되는 객체
>   - 변경 가능성 : DTO는 변경 가능하며, 데이터를 전달하는 동안 여러 계층간 데이터를 쉽게 전달할 수 있도록 한다. 
>   - 구조 단순화 : 다양한 데이터 소스로부터 데이터를 수집하고, 이를 단일 구조로 전달하는 데 주로 사용된다.
> - DAO (Data Access Object)
>   - 데이터 접근 추상화 : 데이터베이스 또는 다른 데이터 소스에 대한 접근을 추상화하고 캡슐화하는 객체
>   - 데이터베이스 연산 : 데이터 CRUD와 같은 데이터 베이스 연산을 수행
>   - 계층 분리 : DAO는 비즈니스 로직과 데이터베이스 접근 코드를 분리함으로써 코드의 유지보수성과 재사용성을 향상시킨다.



## Spring 심화

> ### AOP
>
> #### 	JDK Dynamic Proxy
>
> > JDK 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어준다.
> >
> > 그렇기 때문에 인터페이스가 필수이다. 
> >
> > 동적 프록시에 적용할 로직의 경우 InvocationHandler 인터페이스를 구현해 작성하면 된다.
> >
> > ```java
> > public interface InvocationHandler {
> >      public Object invoke(Object proxy, Method method, Object[] args)
> >         throws Throwable;
> > }
> > ```
> >
> > - proxy : 프록시 자신 
> > - method : 호출한 메서드
> > - args : 메서드를 호출 할 때 전달한 인수 
> >
> > [한계]
> >
> > - JDK 동적 프록시의 경우 인터페이스가 필수로 필요하다. 
>
> #### 	CGLIB(Code Generator Library)
>
> > CGLIB는 바이트코드를 조작해 동적으로 클래스를 생성하는 기술을 제공하는 라이브러리.
> >
> > CGLIB를 사용하면 인터페이스가 없어도 구체 클래스만 가지고 동적 프록시를 만들어 낼 수 있음.
> >
> > CGLIB의 경우 원래 외부라이브러리이나 스프링 프레임워크에서 스프링 내부 소스코드에 추가.
> >
> > CGLIB는 MethodInterceptor를 사용해 만들 수 있다. 
> >
> > ```java
> > public interface MethodInterceptor extends Callback {
> >       Object intercept(Object obj, Method method, Object[] args, MethodProxy
> >   proxy) throws Throwable;
> >   }
> > ```
> >
> > - obj : CGLIB가 적용된 객체
> > - method : 호출된 메서드
> > - args : 메서드 호출 시 전달 된 인수 
> > - proxy : 메서드 호출에 사용
> >
> > [제약]
> >
> > 클래스 기반 프록시는 상속을 사용하기 때문에 몇가지 제약이 존재한다. 
> >
> > - 부모 클래스의 생성자를 체크해야 함
> >   - CGLIB는 자식 클래스를 동적으로 생성하기 때문에 기본 생성자가 필요함
> >   - 클래스에 final이 붙으면 상속이 불가능하다. (CGLIB에서는 예외 발생)
> >   - 메서드에 final이 붙으면 해당 메서드를 오버라이딩 할 수 있다. (CGLIB에서는 프록시 로직이 동작 X)
> >
> > ### Proxy Factory
> >
> > JDK Dynamic Proxy, CGLIB를 보다 편리하게 사용할 수 있도록 스프링에서 추상화된 기술 제공한다. 
> >
> > ### Advice 
> >
> > Proxy Factory의 경우 JDK Dynamic Proxy, CGLIB를 제공하는데, 부가 기능 로직을 Advice에 구현하면 ProxyFactory 내부적으로 Advice를 호출하는 InvocationHandler, MethodInterceptor를 내부적으로 사용한다. 