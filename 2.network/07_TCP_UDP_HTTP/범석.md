## 07. TCP, UDP, HTTP

## 통신

### TCP

> TCP는 연결형, 신뢰성 전송 프로토콜이다.
>
> 연결지향적 서비스를 제공하기 위해 데이터를 전송하기 전 3 way handshaking을 해 두 호스트의 계층 사이에 논리적 연결을 설립한다. 
>
> TCP는 신뢰성 있는 서비스를 제공하기 위해 흐름제어, 혼잡 제어, 오류제어를 실행한다. 
>
> TCP는 신뢰성을 보장하기 위해 UDP 보다 헤더가 크고, 속도가 비교적 느리다는 단점을 지닌다.



#### 흐름제어, 혼잡제어, 오류제어

> 흐름제어 
>
> > 송신측과 수신측 사이의 데이터 처리 속도 차이를 제어하기 위한 기법으로 데이터 처리 속도를 조절해 수신자의 버퍼 오버플로우를 방지한다.
> >
> > Stop and Wait
> >
> > - 매번 전송한 패킷에 대한 확인 응답을 받아야 다음 패킷을 전송할 수 있다. (다소 비효율적)
> >
> > Sliding Window 
> >
> > - 윈도우 : 송신, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기
> > - 송신측에서 윈도우 크기만큼 데이터를 수신측으로 전송
> > - 수신측에서 데이터를 받으면 ACK 를 송신측에 보냄 (1,2,3)
> > - 송신측은 ACK를 받으면 윈도우를 슬라이드 시켜 다음 데이터를 전송.
> > - 네트워크 상황에 따라서 윈도우 크기를 동적으로 조절할 수 있다.
>
> 혼잡 제어
>
> > - 송신측의 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법이다.
> > - 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것이 혼잡 제어이다.
> >
> > AIMD(Additive Increase Multicative Decrease)
> >
> > - 처음에 패킷 하나를 보내는 것으로 시작해 전송한 패킷이 문제없이 도착한다면 Window Size를 1씩 증가
> > - 만약 패킷 전송을 실패하거나 TIME_OUT이 발생하면 Window Size를 절반으로 줄인다. 
> >
> > => 처음에 전송 속도를 올리는데 시간이 너무 길다는 단점이 존재한다. 
> >
> > Slow Start
> >
> > - 처음에 패킷 하나를 보내는 것으로 시작해, 패킷이 문제 없이 동작해 ACK 패킷마다 WindowSize를 1씩 늘린다.
> > - 혼잡 현상이 발생하면 WindowSize를 1로 줄인다.
> > - 혼잡 현상이 발생한 Window Size의 절반까지는 기존과 같이 Window Size를 증가시킨다.
> > - Window Size의 절반 이후부터는 1씩 증가시킨다.
>
> 오류 제어
>
> > 오류 검출과 재전송을 포함한다. 
> >
> > ARQ(Automatic Repeat Request)기법을 사용해 프레임이 손상되거나 손실되었을 경우, 재전송을 통해 오류를 복구한다. ARQ기법은 흐름제어와 연관되어 있다. 
> >
> > Stop And Wait ARQ
> >
> > - 송신 측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무에 따라 ACK 혹은 NAK를 보낸다.
> > - 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0, 1 번호를 번갈아 가며 부여 
> > - 수신측에서 데이터를 받지 못한 경우 NAK를 보내고, NAK를 받은 송신측은 데이터를 재전송한다. 
> > - 만약 데이터 혹은 ACK가 분실될 경우 일정 간격의 시간을 두고 타임아웃이 되면 송신측은 데이터를 재전송.
> >
> > Go-Back-n ARG
> >
> > - 전송된 프레임이 손상되거나 분실된경우, ACK 패킷의 손실로 인한 TIME_OUT이 발생한 경우, 확인된 마지막 프레임 이후로 모든 프레임 재전송
> > - 슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송측은 전송된 프레임의 복사본을 가지고 있어야 하며 ACK, NAK 모두 각각 구별해야한다. 
> > - ACK : 다음 프레임 전송 
> > - NAK : 손상된 프레임 자체 번호를 반환 
> >
> > SR(Selective-Reject) ARQ 
> >
> > - GBn ARQ의 확인된 마지막 프레임 이후의 모든 프레임을 재전송하는 단점을 보완하는 기법. 
> > - SR ARQ는 손상되거나 손실된 프레임만 재전송 
> > - 별도의 재정렬을 수행해야하며 별도의 버퍼를 필요로 한다.
> > - 수신 측에 버퍼를 두어 받은 데이터의 정렬이 필요하다. 

#### 3-way-handshake, 4-way-handshake

> 3-way-handshake
>
> > TCP/IP 프로토콜로 통신하기 전, 정확한 정보 전송을 위해 상대방 컴퓨터와 세션을 수립하는 과정입니다. 
> >
> > - 클라이언트가 서버에게 접속을 요청하는 SYN 패킷을 보낸다.
> > - 서버는 요청을 수락하는 ACK를 포함해 SYN + ACK 패킷을 클라이언트에게 보냅니다. 
> > - 클라이언트가 이를 수신 후 ACK 패킷을 서버에게 발송하면 연결이 이루어지고, 데이터를 주고 받을 수 있다. 
>
> 4-way-handshake
>
> > data transfer가 다 끝나고 TCP 연결을 종료하는 Connection Termination 과정이다. 
> >
> > - 클라이언트 프로세스에서 active close를 하면, client tcp에서 FIN 세그먼트를 보낸다. 
> > - 서버에서 FIN 세그먼트를 받은 것에 대한 ACK를 client에게 전송 
> > - Server process로 부터 passive close를 받으면 server tcp에서 FIN 세그먼트를 client TCP에게 전송 
> > - Server tcp가 ACK를 받으면 연결이 종료된다.

## UDP

> UDP는 비 연결형, 비 신뢰성 전송 프로토콜이다. 
>
> UDP는 논리적 연결을 설립하지 않고, datagram을 전송하는 비 연결형 프로토콜이다. 
>
> UDP는 흐름제어, 오류제어, 혼잡제어를 제공하지 않는 간단한 프로토콜이다. 
>
> 작은 메세지를 보내거나, 신뢰성을 크게 고려하지 않아도 되는 상황에서 사용한다. 

## HTTP

> HTTP 란 Hyper Text Transfer Protocol의 약자로 서버-클라이언트 모델을 따르면서 request/response 구조로 웹 상에서 정보를 주고 받을 수 있는 프로토콜이다. TCP/IP 기반으로 작동하며, HTTP의 가장 큰 특징은 Stateless, Connectionless이다.

### HTTP status code

> Status code란 클라이언트로 부터 받은 request에 대한 서버의 resposne에 대한 간략한 설명이라고 볼 수 있다. 
>
> - 1xx : 요청을 받고 계속 처리 중 
> - 2xx : 클라이언트가 요청한 동작을 성공적으로 수신해 이해했고, 성공적으로 처리함
>   - 200 : 요청 성공 
>   - 201 : 리소스 생성됨
>   - 204 : response body가 없음
> - 3xx : 요청을 완료하기 위해 추가 작업 조치가 필요
> - 4xx : 클라이언트의 요청에 문제가 있음
>   - 400 : 올바르지 않은 형식의 데이터 입력
>   - 401 : 인증되지 않은 유저가 인증이 필요한 리소스에 접근
>   - 403 : 리소스에 대한 접근 권한이 없음
>   - 404 : 리소스가 존재하지 않음 (url)
> - 5xx : 서버가 유효한 요청에 대해 수행을 실패함 
>   - 500 : 서버 내부적으로 문제 발생 

### HTTP method

> - GET : 리소스 조회 
> - POST : 요청 데이터 처리 
> - PUT : 리소스 대체, 해당 리소스가 없는 경우 생성 
> - PATCH : 리소스 일부분 변경 
> - DELETE : 리소스 삭제

### HTTP 1.1, 2.0, 3.0

> HTTP 1.1
>
> keep-alive 
>
> > 여러 HTTP 요청 및 응답을 하나의 TCP 연결을 통해 처리할 수 있게 해주는 메커니즘.
> >
> > HTTP 1.0의 경우에는 요청과 응답에 대해 별도의 TCP 연결을 열고 닫아야 했다. 
> >
> > HTTP 1.1에서는 keep-alive 연결이 기본적으로 활성화되어 있어, "Connection:close" 헤더를 사용하지 않는 한 동일한 TCP 연결을 여러 요청과 응답에 재사용할 수 있다. 
>
> pipelining
>
> > 여러개의 HTTP 요청을 하나의 TCP 연결을 통해 순서대로 보내되, 각각의 응답을 기다리지 않고, 바로 다음 요청을 보낼 수 있는 기술. 
> >
> > 기본적인 HTTP 요청-응답 모델에서는 클라이언트가 하나의 요청을 보내고 그에 대한 응답을 받은 후에야 다음 요청을 보낼 수 있다. 
>
> HOL(head of line) blocking
>
> > 여러 개의 데이터 패킷이 순서대로 처리되어야 할 때 첫번째 패킷이 지연되거나 처리되지 않아 그 뒤에 있는 패킷들도 대기 상태에 놓이게 되는 현상.
>
> HTTP 2.0
>
> 헤더 압축 
>
> > HTTP 1.x 에서는 헤더 정보를 압축하지 않고, 텍스트 형식으로 전송한다. 이에 반해 HTTP 2.0에서는 HPACK 알고리즘을 사용해 헤더 정보를 압축한다. 이로 인해 헤더의 크기가 줄어들고 전체적인 성능이 향상된다. 
>
> HOL 블로킹, 리소스 우선순위 
>
> > HTTP 2에서는 각 스트림에 우선순위를 지정할 수 있고, 하나의 스트림이 블로킹 되더라도 다른 스트림에는 영향을 미치지 않습니다. 
>
> 서버 푸시 
>
> > HTTP 1.1 에서는 클라이언트의 명시적인 요청이 있을 때만 리소스를 전송할 수 있는 반면 HTTP 2에서 서버는 클라이언트의 요청에 미리 대응해 필요한 리소스를 "푸시" 할 수 있다. 이로 인해 라운드 트립 시간을 줄일 수 있다.
>
> ***라운드 트립 : 데이터 패킷이 송신자로부터 수신자에게 가고 다시 송신자로 돌아오는데 걸리는 시간***
>
> 프로토콜 방식 
>
> > HTTP 1.1은 텍스트 기반의 프로토콜인 반면 HTTP2는 바이너리 기반의 프로토콜이다. 이로 인해 파싱이 빠르고 오류 가능성이 줄어든다. 
>
> HTTP 3.0
>
> QUIC (Quick UDP Internet Connections) 프로토콜 사용 
>
> > - TCP 대비 더 나은 동시성 
> >   - 복수의 스트림을 지원하는데, 스트림들이 독립적으로 동작하기 때문에, 하나의 스트림에서 패킷 손실이 다른 스트림에 영향을 주지 않음
> > - 더 빠른 연결 설정 
> >   - 더 적은 라운드 트립을 필요로 하므로, HTTP 2보다 더 빠르게 연결을 설정할 수 있다. 
> > - O-RTT 재연결 
> >   - QUIC는 이전 연결의 정보를 활용해 0-RTT 재연결을 가능하게 해 더 빠른 연결 시간을 제공한다.

---

## Questions

1. TCP / UDP 에 대해서 간단하게 설명해주세요.
2. TCP에서 신뢰성 있는 연결을 위해 어떤 제어들을 사용하는지 알려주시고, 간단하게 설명 부탁드립니다. 
3. Http Status Code에 대해서 아는대로 설명해주세요
4. Http Method에 대해서 아는대로 설명해주세요
