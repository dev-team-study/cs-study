```
통신
- HTTPS, SSL/TSL
- DNS
- 기타 : socket, STOMP, SMTP (프로젝트에서 사용한 경우)

Web
- Web Server vs WAS
```

# HTTPS

HTTP에서 보안(secure)이 강화된 프로토콜. 누구나 볼 수 있었던 메시지를 통신하는 당사자들만 볼 수 있도록 암호화 해 HTTP의 보안 문제를 해결했다.

# SSL/TSL

HTTPS프로토콜의 보안은 SSL에서 이루어 진다. SSL은 클라이언트와 서버가 서로 데이터를 암호화해 통신할 수 있도록 돕는 보안 계층이다. OSI계층 구조로 보자면 HTTP 계층 아래에 SSL이라는 보안 계층이 추가되었다고 볼 수 있다.

## SSL과 TSL의 차이점

SSL2.0 버전에 몇 가지 취약점이 발견되어 이를 해결하기 위해 구조를 재설계해 SSL 3.0이 배포되었다. 그 후 기존 버전과 구분하기 위해 3.0다음부터 등장한 SSL의 이름을 TSL로 바꾸었다. 하지만 사람들이 SSL이라는 이름에 익숙하다 보니, 대다수의 보안 프로토콜이 TSL로 교체되어 더 이상 SSL을 사용하고 있지 않은 지금까지도 계속 SSL이라고 불리고 있다.

## 암호화 방식

암호화를 하기 위해서 키가 필요하다. 키를 통해 암호화와 복호화가 이루어 진다. 그 중 SSL은 대칭키 기법, 공개키 기법이라는 두 암호화 기법을 함께 사용하고 있다.

- 대칭키 기법은 하나의 키로 암호화와 복호화를 둘 다 할 수 있는 기법이다. 공개키 방식에 비해 속도가 빠르다는 장점이 있지만, 키를 안전하게 서로 교환하기 어렵다는 단점이 있다. 클라이언트와 서버가 같은 키를 갖고 있어야하므로 서로 키를 통신해야 하는데, 중간에 누가 키를 가로챌 위험이 있기 때문이다.
- 공개키 기법은 서로 다른 키 두 개로 암호화, 복호화를 하는 기법이다. 이 때 사용하는 키 두 개를 각각 공개키, 개인키라고 부른다. 공개키는 누구나 가질 수 있는 키지만 개인키는 소유자 한 명만 가질 수 있는 키로 이 두 키는 늘 한 쌍으로 동작한다. 이 때문에 공개키 암호화 기법을 위해서는 반드시 공개키와 개인키가 함께 필요하다.

## 인증서

클라이언트의 요청을 받은 서버는 인증서를 응답한다. 인증서란 서버가 공식적으로 인증된 기관인 CA에서 발급받은 문서로, 서버가 신뢰할 수 있는지 보장하는 역할을 한다. 인증서를 받은 클라이언트는 이 인증서가 제대로 된 문서인지 검증하기 위해, CA가 발급한 인증서 목록 중에서 서버가 전달한 인증서가 있는지 확인한다. 그리고 인증서가 목록에 있다면 한 번 더 철저히 확인하기 위해 CA에서 공유하는 공개키를 가지고 인증서를 인증서를 복호화한다. 만약 복호화에 성공한다면 이 인증서는 서버가 자신의 비밀키로 암호화를 했다는 것이 검증되니 서버를 완전히 신뢰할 수 있게 된다.

# DNS

- 도메인 네임 시스템 (Domain Name System, DNS) 은 호스트의 도메인 네임 (www.example.com)을 네트워크주소(192.168.1.0)로 변환하거나, 그 반대의 역할을 수행하는 시스템
- DNS 시스템은 이름과 숫자 간의 매핑을 관리하여 마치 전화번호부와 같은 기능을 한다.
- DNS 서버는 이름에 대한 요청을 IP 주소로 변환하여 최종 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 어떤 서버에 연결할 것인지를 제어한다. 이 요청을 쿼리라고 한다.

## DNS 동작 원리

전세계에 도메인 수가 너무 많기에 DNS 서버 종류를 계층화해서 단계적으로 처리한다. 이 DNS 서버들을 요청을 통해 재귀적으로 탐색하며 목표로 하는 도메인 네임의 IP주소를 가지고 있는 DNS 서버를 찾아간다.

예) Local DNS → RootDNS → TLD DNS → AUthoritativ DNS Server 순 탐색.

# Socket

웹 환경이 발전해 감에 따라 ‘클라이언트의 요청이 있고 그 다음 서버로부터 응답을 받는 상황’ 의 틀에서 벗어나야할 필요성이 생김(채팅). 웹 소켓은 이러한 요구를 해결하기 위해 나온 기술로 브라우저와 서버 사이의 동적인 양방향 연결 채널을 구성하도록 함(서버에서 먼저 데이터 송신 가능).

- HTTP와 웹 소켓의 결정적인 차이는 프로토콜에 있음. 웹 소켓 역시 접속 확립에는 HTTP 프로토콜을 사용하지만, 그 후의 통신은 WebSocket 독자의 프로토콜로 이루어짐.
- 웹 소켓은 header가 상당히 작어 오버헤드가 적은 특징이 있음.
- 통신시에 지정되는 URL이 http://www.sample.com/ 과 같은 형식이 아니라 ws://www.sample.com/과 같은 형식이 됨.

# Web Server vs WAS

## Web Server

- 웹 서버는 클라이언트가 요청한 정적인 콘텐츠를 HTTP 프로토콜을 통하여 제공해주는 서버이다. 위에서 언급한 정적 페이지를 보내준다. 정적인 콘텐츠 제공이 가장 큰 역할이다.
- 다른 역할로는 동적인 요청이 들어왔을 때, 해당 요청을 웹 서버에서 처리할 수 없기 때문에 컨테이너로 요청을 전달하는 역할을 한다.
- 예) Nginx, Appach HTTP Server 등

## WAS

서버로 오는 동적인 요청을 처리하는 서버를 말한다. 웹 페이지는 정적 컨텐츠와 동적 컨텐츠가 모두 존재한다. 사용자 요청에 맞게 적절한 동적 컨텐츠를 만들어 제공해야하는 경우 Web Server만으로는 동적 컨텐츠를 제공하는 것이 불가능하다. 따라서 WAS를 통해 요청에 맞는 테이터를 DB에서 가져와서 비즈니스 로직에 맞게 끄때 그때 결과를 만들어서 제공함으로써 자원을 효율적으로 사용할 수 있다.

# 질문

1. HTTP, SSL/TSL에 대해 설명해주세요.

HTTPS는 보안 계층(SSL/TLS)을 사용하여 통신하는 프로토콜입니다. SSL은 HTTPS의 보안을 담당하는 하위 계층 중 하나이며, TLS는 SSL의 후속 버전입니다. HTTPS는 HTTP와 다른 특정 프로토콜을 나타내는 것이 아니라, HTTP 프로토콜을 안전하게 전송하기 위해 SSL 또는 TLS를 사용한 것을 의미합니다.

2. DNS의 역할과 동작 원리를 설명해주세요.

DNS는 호스트의 도메인 네임을 네트워크 주소로 변환하거나, 그 반대의 역할을 수행하는 시스템입니다. 사용자가 도메인 이름을 웹 브라우저에 입력하면, DNS는 해당 도메인의 IP 주소를 찾아 사용자를 원하는 서버에 연결하는 역할을 합니다.

DNS의 동작 원리는 계층화된 구조를 가지고 있습니다. 사용자의 컴퓨터가 도메인을 입력하면 먼저 로컬 DNS 서버에 쿼리를 보냅니다. 로컬 DNS 서버는 캐시에서 해당 도메인의 IP 주소를 찾으면 바로 반환하고, 없으면 루트 DNS 서버로부터 시작하여 순차적으로 찾아가며 IP 주소를 찾아내어 응답합니다.

3. 웹 소켓과 HTTP의 주요 차이점은 무엇인가요?

웹 소켓과 HTTP의 가장 큰 차이는 통신 방식입니다. HTTP는 클라이언트가 요청하고 서버가 응답하는 단방향 통신을 기반으로 하고 있습니다. 반면에 웹 소켓은 양방향 통신을 지원하며, 클라이언트나 서버가 언제든 데이터를 보낼 수 있습니다.

또한, 웹 소켓은 HTTP와는 다르게 오버헤드가 적고 효율적인 통신을 제공합니다.  웹 소켓은 단일한 연결로 계속 데이터를 주고받을 수 있어서 여러 번의 연결 설정과 해제를 필요로 하는 HTTP와 비교해 빠른 속도를 보장합니다.

4. Web Server와 WAS의 차이는 무엇인가요?

Web Server는 정적인 콘텐츠를 처리하고, 동적인 요청이 들어왔을 때 해당 요청을 WAS로 전달하는 역할을 합니다. 주로 정적인 웹 페이지, 이미지, CSS 파일 등을 제공하는 데 사용됩니다.

WAS는 동적인 콘텐츠를 처리하는 서버로, 데이터베이스와 연동하여 필요한 데이터를 가져와 비즈니스 로직에 따라 동적인 결과를 생성하여 클라이언트에게 제공합니다. WAS는 Web Server와 데이터베이스 사이에서 중간 역할을 수행하여 동적인 웹 애플리케이션을 구현하는 데 사용됩니다.

5. SSL의 동작 과정을 최대한 자세하게 설명해주세요.

먼저 클라이언트가 서버에게 요청을 하면, 서버는 응답으로 인증서를 보내줍니다. 인증서를 받은 클라이언트는 CA를 통해 인증서를 검증합니다. 검증이 끝나면 임시 키를 만들어서 공개키로 암호화해 서버에게 전달합니다. 여기서 전달한 임시키는 대칭키이기 때문에 제 3자에게 노출되면 안 되므로 공개키로 암호화 해서 서버에게 전달합니다. 키를 받은 서버는 자신이 갖고 있던 비밀키로 암호를 해독해 임시 키를 전달받게 됩니다. 비로소 클라이언트와 서버가 서로 대칭 키를 획득하게 되는 것 입니다. 이 대칭키는 일련의 과정을 거쳐 세션 키로 바뀌로고, 세션 키를 이용해 본격적으로 통신을 할 수 있게 됩니다. 그 이후 통신이 끝나서 세션이 종료되면 그통신에서 사용한 세션 키를 함께 삭제합니다.