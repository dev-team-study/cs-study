# 1. CPU 스케줄링
- CPU Core가 하라면 한 번에 하나의 프로세스만 실행 가능
- 언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업
- CPU 이용률은 높게, 주어진 시간에 많은 일을 하게, 응답시간을 짧게 하는데 목표가 있음
## 1.1 장기 스케줄링(= 작업 스케줄러)
- 어떤 프로세스를 준비 큐에 삽입할지 결정(메모리와 디스크 사이의 스케줄링을 담당) 
- 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데, 이때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지(준비 큐에) 결정
- 프로세스 상태
  - new -> ready

## 1.2 중기 스케줄링
- 너무 많은 프로세스에게 메모리를 할당해서 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러
  1. 메모리에 많은 수의 프로세스가 적재하면 프로세스 당 보유하고 있는 메모리량이 극도로 적어짐
  2. CPU 수행에 당장 필요한 프로세스의 주소 공간조차 메모리에 올려놓기 어려워짐
  3. 디스크 I/O가 수시로 발생
  4. 시스템의 성능이 심각하게 저하
  5. 메모리에 올라와있는 프로세스 중 일부의 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑영역에 저장
- 스왑 아웃
  - 중기 스케줄러의 등장으로 프로세스의 상태에는 중지 상태가 추가되었으며, 중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃 됨
  
## 1.3 단기 스케줄링
- CPU와 메모리 사이의 스케줄링을 담당
- 준비 큐에 존재하는 프로세스 중 어떤 프로세스를 실행 시킬건지 결정
- 프로세스에 CPU를 할당
- 프로세스의 상태
- ready -> running -> waiting -> ready 

# 2. 스케줄링 알고리즘
  ## 2.1 스케줄링 결정 시기
  1. **[비전점형 스케줄링]** `실행` 상태에서 `대기` 상태로 전환 될 때
  2. **[선점형 스케줄링]**  `실행` 상태에서 `준비` 상태로 전환 될 때
  3. **[선점형 스케줄링]**  `대기` 상태에서 `준비` 상태로 전환 될 때
  4. **[비선점형 스케줄링]** `종료` 될 때 

  ## 2.2 스케줄링 종류
  - 비선점형 스케줄링
    - 어떤 프로세스가 CPU를 점유하고 있다면 이를 뺏을 수 없는 방식
    - 강제로 프로세스를 중지하지 않음
    - 문맥 교환으로 인한 부하가 상대적으로 적지만 프로세스의 배치에 따라 효율성 차이가 많이 남
  ### 2.1 FCFS(First Come, First Served)
  - 가장 먼저 요청한 프로세스에 CPU를 할당해주는 방식
  - 호위 효과 발생 가능 
    - 몇 개의 시간이 오래걸리는 프로세스로 인해 전체 OS가 느려지는 현상을 의미
  ### 2.2 SJF(Shortest Job First)
  - 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 알고리즘
  - 하지만 프로세스의 CPU 실행 시간을 예측하기가 어려운 문제가 있음
  - 긴 시간을 필요로 하는 프로세스가 우선순위가 계속 밀려 실행되지 못하고 무기한으로 대기하게 되는 기아현상 발생 가능
  ### 2.5 Priority scheduling
  - 각각의 프로세스에 우선순위 넘버가 있는 알고리즘
  - SJF에서 낮은 우선 순위인 CPU 실행 시간이 오래걸리는 작업이 절대 실행되지 않는 기아현상이 발생될 수 있는데 이때 처리되지 못한 오래된 프로세스의 우선순위를 높여주는 식

  - 선점형 스케줄링
    - 현대 운영체제가 사용하고 있는 방식으로 어떤 프로세스가 CPU를 할당받아 실행중이더라도 운영체제가 이를 강제로 뺏을 수 있는 방식
    - 알고리즘에 따라 강제로 중단시키고 다른 프로세스에 CPU를 할당하는 방식
    - 처리 시간이 매우 긴 프로세스의 CPu 사용 독점을 막을 수 있어 효율적으로 사용이 가능하지만 잦은 컨텍스트 스위칭으로 인해 오버헤드가 커질 수 있음

  ### 2.3 Round Robin
  - 현대 컴퓨터가 사용하고 있는 우선순위 스케줄링
  - 각각의 프로세스에 동일한 할당 시간을 부여해서 해당 시간동안만 CPU를 이용하게 함
  - 할당 시간 내에 처리하지 못하면 강제 중단 후 다음 작업으로 넘어감

  ### 2.4 SRF (SRTF라고 부르기도함 (Shortest Remaining Time First))
  - 현재 실행되고 있는 프로세스의 남은 시간보다 더 빨리 끝날 수 있는 짧은 프로세스가 들어오면 현재 실행는 프로세스를 중단하고 짧은 프로세스를 실행하도록 바꾸게 됨
  - 평균 대기 시간을 줄일 수 있지만 다음 프로세스의 CPU 처리 시간을 예측하는 것이 어려움

  ### 2.6 Multilevel Queue
  - 우선순위에 따른 준비 큐가 여러 개의 큐들로 나뉘고 각각의 큐는 각자의 스케줄링 알고리즘을 가지고 있음
  - 우선순위가 높은 큐부터 처리되기 때문에 낮은 큐의 프로세스가 처리 되지 않은 기아 현상 발생 가능
  - 각 큐 사이의 프로세스들이 이동하지 못해 유연성이 떨어짐

  ### 2.7 Multilevel Feedback Queue
  - 프로세스가 큐 들 사이를 이동하는 것을 허용
  - 기아 현상과 노화 현상을 방지

# 3. 인터럽트
  ## 3.1 인터럽트 개념
  - CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요할 경우에 CPU에게 알려 처리할 수 있는 것
  - 우선적으로 처리해야할 일이 발생하였을 때 그것을 처리하고 원래 동작으로 돌아옴
  
  ## 3.2 동기적 인터럽트, 비동기적 인터럽트

  ### 3.2.1 하드웨어 인터럽트(비동기적)
  - 일반적으로 인터럽트를 부르는 말
  - CPU 외부로부터의 인터럽트 요구 신호에 의해 발생되는 인터럽트
  - 다른 하드웨어 장치가 실행중인 명령어와는 무관하게 생성하는 인터럽트를 비동기적 인터럽트라고 함
  - 종류
    - 입출력 인터럽트: 입출력 작업의 종료나 입출력 오류에 의해 CPU의 기능이 요청됨
    - 정전, 전원 인터럽트: 전원 공급의 이상
    - 기계 착오 인터럽트: CPU의 기능적인 오류
    - 외부 신호 인터럽트: I/O장치가 아닌 오퍼레이터나 타이머에 의해 의도젹으로 프로그램이 중단 된 경우
  - 예시
    - 마우스의 동작 과정
  ### 3.2.2 소프트웨어 인터럽트(동기적)
  - CPU 내부에서 자신이 실행한 명령어나 CPU의 명령 실행에 관련된 모듈이 변화하는 경우 발생
  - Trap 또는 Exception이라고도 함
  - 프로그램의 오류에 의해 생기는 인터럽트
  - 프로세스가 실행 중인 명령어로 인해 발생하는 인터럽트를 동기적 인터럽트라고도 부름
  - 종류
    - O으로 나누는 경우
    - OverFlow, UnderFlow
    - 페이지 부재
    - 부당한 기억장소의 참조 등
  - 예시
    - 엑셀 파일을 클릭했을 때 엑셀에서는 하드

  ## 3.3 인터럽트 처리 과정
  1. 프로세스 실행 중
  2. 인터럽트 요청
  3. 프로세스 중단
  4. 현재의 프로그램 상태 보존 -> PCB, PC등
  - 인터럽트 원인 판별
    - 인터럽트를 요청한 장치를 식별
  1. 인터럽트 처리
  2. ISR (Interrupt Service Routine) 실행
    - 실질적인 인터럽트 처리 작업 수행
    - 서비스 루틴 중 우선순위가 높은 인터럽트가 발생하면 해당 인터럽트를 처리
  3. 프로그램 상태 복구
    - 인터럽트 발생 시 저장해둔 PC를 다시 복구하여 이전 실행 위치로 돌아감
  4. 중단된 프로세스 실행

  - 일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선 순위가 높음
  
  ## 3.4 인터럽트 우선순위
  1. 전원 이상
  2. 기계 착오
  3. 외부 신호
  4. 입출력(I/O)
  5. 명령어 잘못
  6. 프로그램 검사
  7. SuperVisor Call

  ## 3.4 인터럽트와 이중 모드
  ### 3.4.1 이중 동작 모드
  - 운영체제를 보호하기 위한 기법
  - 사용자에게 시스템 자원에 대한 제한을 걸지 않을 경우 사용자가 중요한 하드웨어 자원을 망가뜨릴 위험이 생김 -> 방지하기 위한 것이 이중 동작 모드
  
    #### 커널모드(0)
    - 운영체제를 위한 동작을 담당
    - 시스템의 모든 메모리에 접근할 수 있고 모든 CPU 명령을 실행할 수 있음
  
    #### 유저모드(1)
    - 사용자를 위한 동작을 담당
    - 사용자 어플리케이션 코드가 실행
    - 시스템 데이터에 제한된 접근만 허용되며 하드웨어를 직접 접근할 수 없음
    - 어플리케이션에서 시스템 서비스 호출을 하면 유저모드에서 커널모드로 전환 됨

  ### 3.4.2 인터럽트 이중모드 과정
   1. 실행중인 프로그램(유저모드)
   2. 인터럽트 발생 후 CPU로 인터럽트 신호 요청(유저모드)
   3. CPU에서 모드 플래그를 0으로 변경(커널모드)
   4. 해당 하드웨어 인터럽트 서비스 루틴으로 이동(커널모드)
   5. 인터럽트 처리(커널모드)
   6. 인터럽트 처리 후 CPU의 모드 플래그를 1로 변경(유저모드)
   7. 원래의 애플리케이션 위치로 복귀(유저모드)
  
# 4. 프로세스 동기화
  ## 4.1 경쟁상태, 공유자원, 임계구역
  ### 4.1.1 경쟁상태(경쟁 조건(RaceCondition))
  - 2개 이상의 프로세스가 공유 자원을 병렬적으로 읽거나 쓸 때
  - 경쟁 조건이 발생하면 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있음
  ### 4.1.2 공유자원
  - 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 의미함
  ### 4.1.3 임계구역
  - 공유 자원 접근 순서에 따라서 실행결과가 달라지는 프로그램의 영역
  - 임계구역에서는 프로세스들이 동시에 작업되면 안됨

  ### 4.1.4 임계구역에 대한 해결 조건
  1. 상호 배제: 한 프로세스가 임계구역에 들어가면 다른 프로세스는 들어갈 수 없음
  2. 한정 대기: 어떤 프로세스도 무한 대기를 하면 안됨
  3. 진행의 융통성: 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨

  ## 4.2 피터슨 알고리즘
  - 게리 피터슨이 제안한 알고리즘
  - 하드웨어의 도움 없이 임계 구역에 대한 문제를 해결할 수 있는 방법
  - flag와 turn 변수를 이용하여 Lock을 획득
    - flag: 공유 자원을 사용한다라고 표현하기 위한 변수
    - turn: 누구 차례인지 명시하는 변수
  - 임계구역 해결에 대한 3개 조건을 모두 부합
  
  ```java
    while (true) {
	    flag[i] = true;
        turn = j ;		// 또 다른 프로세스 를 j라고 가정.
	
        while(flag[j] && turn == j);
        /* critical section */
    
        flag[i] = false;
        /* remainder section */
    }
  ```
  - 스핀락: 락을 가질 수 있을 때까지 반복해서 시도
    - 기다리는 동안 CPU를 갉아먹음

  ## 4.3 뮤텍스
- 임계 구역을 가진 스레드들의 실행 시간을 서로 겹치지 않게 단독으로 실행하게 하는 기술
- Lock과 Unlock을 사용
- 락을 획득하고 다른 프로세스는 대기 큐에 들어가서 락을 해제할 때 대기 큐에 있는 프로세스를 순차적으로 락을 획득하게 함
- 스핀락이 뮤텍스보다 좋을 때
  - 멀티코어 환경이고 임계 영역에서의 작업이 빨리 끝난다면 스핀락이 뮤텍스보다 이점이 있음
  ## 4.4 세마포어
- 하나 이상의 프로세스/스레드가 임계 영역에 접근 가능하도록 하는 장치
- 진입 가능한 프로세스/스레드 수를 지정할 수 있음
1. 세마포어의 값을 진입 가능한 수를 지정하고 접근할 때마다 세마포어의 값을 -1씩 처리
2. 0이 되면 락 획득을 위한 큐로 진입하여 대기
3. 락을 가지고 있는 프로세스가 끝나면 세마포어의 값을 다시 +1 시킴
4. 현재의 세마포어 수만큼 진입 가능

  ## 4.5 모니터
- 모니터는 공유자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로써 자원을 보호하고 프로세스 간에 동기화

1. 직접 P()나 V()를 사용하지 않고 모니터에 작업을 요청
2. 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 해당 프로세스에 알려줌

- 시스템 콜과 비슷