# 1. Java 기초
  ## 1.1 접근제어자
  - 변수나 메서드의 사용 권한을 설정할 수 있음
  - private < default < protected < public
  
  ### 1.1.1 private
  - private이 붙은 변수나 메서드는 동일한 클래스 안에서만 접근이 가능

  ### 1.1.2 default
  - 접근 제어자를 별도로 설정하지 않는다면 변수나 메서드는 접근 제어자가 자동으로 설정되어 동일한 패키지 안에서만 접근이 가능

  ### 1.1.3 protected
  - 동일 패키지의 클래스 또는 해당 클래스를 상속받은 클래스에서만 접근이 가능
  - 다른 패키지이더라도 상속되어있는 클래스의 필드는 접근 가능

  ### 1.1.4 public
  - public이 붙은 변수나 메서드는 어떤 클래스에서도 접근이 가능

  ### 1.1.5 클래스의 접근 제어자
  - public, default 2가지만 사용 가능

  ## 1.2 클래스, 객체, 인스턴스 차이
  ### 1.2.1 클래스
  - 클래스는 객체를 생성하기 위한 '틀' 또는 '설계도'
  - 객체가 가져야 할 속성(변수)과 기능(메서드)을 정의
  - 예를 들어, 붕어빵 틀 -> 붕어빵 틀인 클래스로 붕어빵을 만들어 실제 나온 붕어빵을 객체 또는 인스턴스라 칭함

  ### 1.2.2 객체
  - 객체는 클래스에서 정의한 속성과 기능을 가진 실체를 의미
  
  ### 1.2.3 인스턴스
  - 특정 클래스로부터 생성된 객체를 의미
  
  ### 1.2.4 객체와 인스턴스의 차이
  - 인스턴스는 주로 객체가 어떤 클래스에 속해 있는지 강조할 때 사용
  - 예를 들어, 팥 붕어빵은 붕어빵 클래스의 인스턴스

  ## 1.3 Overloading vs Overriding
  ### 1.3.1 Overloading
  - 자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있음
  - 메서드의 이름이 같고, 매개변수의 개수나 타입이 달라야 함
  - 리턴 값만 다른 것은 오버로딩을 할 수 없음
  - 접근 제어자도 자유롭게 지정 가능
  - 매개변수의 차이로만 구현 가능
  - 예를 들어, 회원이라는 클래스가 있을 때 아이디, 패스워드, 회원 상태가 필드로 있으면 회원 상태를 포함해서 만들어야할 때가 있을때가 있고 회원 상태를 포함하지 않고 회원을 만들어야할 때가 있을 것임

  ### 1.3.2 Overriding
  - 부모 클래스로부터 상속받은 메서드를 자식 클래스에서 재정의하는 것
  - 메서드의 이름, 매개변수, 리턴 값이 모두 동일해야 함 -> 접근 제어자는 변경 가능
  - `@Override` 어노테이션을 붙여 오버라이딩 검증
  - 예를 들어, 사람이라는 인터페이스를 만들고 걷기 메서드를 정의 했을 때 구현한 창현이라는 클래스에서는 걷기를 오버라이딩해서 사용

  ## 1.4 Primitive type vs Reference type
  ### 1.4.1 Primitive Type(원시 타입)
  - int, long, double, float, boolean, byte, short, char 총 8가지의 기본 자료형이며 stack에 저장

  ### 1.4.2 Reference Type(참조 타입)
  - 원시 타입을 제외한 나머지 타입(문자열, 배열, 클래스 등)
  - 참조형은 데이터에 접근하기 위한 참조(쭈소)를 저장하는 데이터 타입
  
  기본형 변수는 직접 사용할 수 있는 값이 들어있지만, 참조형 변수에는 위치(참조 값)가 들어가 있어서 참조형 변수를 통해서 뭔가 하려면 결국 참조값을 통해 해당 위치로 이동해야 함

  ### 1.4.3 Call by Reference vs Call by Value
  ### 1.4.3.1 Call by Value
  - 함수의 매개변수에서 값을 복사하는 것
  - 예를 들어, sum이라는 메서드에 매개변수로 int a, int b가 들어있을 때 호출시 입력하는 두 값은 원시자료형으로 값을 복사해서 전달하게 됨.

  ### 1.4.3.2 Call by Reference 
  - 함수의 매개변수에서 주소 값을 참조하는 것
  - 예를 들어, sum이라는 메서드에 매개변수로 int[] 배열이 들어있을 때 호출시 입력하는 배열은 참조 타입으로 배열의 값을 넘기는 것이 아닌 주소 값을 복사하여 전달함.

사실 Call by Reference는 직접 적인 메모리 참조를 이야기하는 것으로 자바에서는 직접적으로 메모리 접근이 불가능하기 때문에 Call by Reference 보다는 Call by Address라는 표현이 더 알맞음. 그리고 int[]라는 배열 참조형 변수도 사실 참조하는 주소 자체가 값이고 해당 값을 복사하는 것이기 때문에 Call by Value라고 봐도 무방

  ### 1.4.4 Wrapper Class
  - 기본 자료타입을 객체로 다루기 위해 사용하는 클래스를 래퍼 클래스라고 부름
  - 기본 자료형을 래퍼 클래스로 변환하는 작업을 박싱, 반대의 상황을 언박싱이라고 부르며 JDK 1.5부터는 자동으로 처리 함
    - 오토 박싱/언박싱은 성능에 영향을 미치므로 필요한 상황이 아니면 지양
  - Collecion과 같은 데이터 구조에서 기본 타입이 아닌 참조형 타입만 사용 가능하기 때문에 사용
  - Wrapper 클래스는 불변 객체이기 때문에 새로운 값이 할당되는 경우 새롭게 클래스가 만들어짐

  ## 1.5 interface vs abstract class
  ### 1.5.1 abstract class
  - 메서드가 없거나, 추상 메서드를 가지고 있는 것이 추상 클래스
    - 추상 메서드: 메소드 안이 아직 구현되어 있지 않은 abstract로 정의된 메서드를 의미
    - 클래스안의 메서드가 단 한개라도 추상 메서드가 있다면 그 클래스 앞에는 반드시 abstract 클래스명으로 표기되어야 함
    - 추상 클래스안에 있는 추상 메서드들은 반드시 하위 클래스에서 모두 구현해야함

  ### 1.5.2 interface
  - 안이 비어있는 메서드들의 형태들만 써놓은 것이며 구현한 하위 클래스에서 해당 메서드들의 내용을 구현해서 사용해야 함
  - 다중 상속(구현)이 가능


  구현의 의미에서는 "인터페이스", 확장의 의미에서는 "추상클래스"
  예를 들어, 블랙잭 게임에서 딜러와 게이머가 필요한데 딜러와 게이머는 공통적으로 카드를 뽑거나 카드의 점수를 계산하거나 등 공통적인 기능을 수행. 하지만 딜러와 게이머는 각각 공통적인 기능 외에도 각 역할마다 다른 추가적인 기능과 상태가 필요할 것이고 이렇게 공통적인 기능을 모아놓고 확장할 때는 추상클래스를 사용.
  
  이와 별개로 설계를 할 때, 블랙잭 게임에 대한 로그를 저장할 때 처음에 파일로 저장하라는 요구사항이었는데 나중에 DB로 저장하라고 변경될 것 같을 때, 같은 요구사항이지만 다른 조건으로 "구현"해야할 때 이때 인터페이스를 사용

  하위 구현체들이 공통된 필드나 메서드를 많이 공유할 때

  ## 1.6 Checked Exception vs UnChecked Exception

  ### 1.6.1 Checked Exception
  - RuntimeException을 상속하지 않는 클래스
  - 컴파일 시점에 컴파일러에서 확인되는 예외
  - 반드시 에러 처리를 해야하는 특징을 가지고 있음
  - 예외 발생시 롤백하지 않음
    - Checked Exception은 복구가 가능하다는 메커니즘을 가지고 있기 때문에 복구하지 않음.
    - 복구가 가능하니 롤백은 진행하지 않음 -> try/catch를 명시해서 처리해야하기 때문에
    - 하지만 대부분의 예외는 복구가 불가능하므로 예외를 RuntimeException으로 던져 처리
  - IOException(입/출력), SQLException(데이터베이스 엑세스, 쿼리 오류), ClassNotFound(동적 클래스 로드 오류), InterruptedException(스레드 중단 및 동기화와 관련된 오류)

  ### 1.6.2 Unchecked Exception
  - RuntimeException을 상속하는 클래스
  - 런타임 단계에서 확인 가능
  - 에러 처리를 강제하지 않음
  - NullPointer, ArrayIndexOutOfBounds 등


  예외 복구 전략이 명확하고 복구가 가능하면 CheckedException을 Try-catch로 잡아서 처리, 그렇지 않으면 Unchecked Exception 사용
  
  ### 1.6.3 예외 처리 방식
  - 예외 처리 회피
  - 예외 복구 방식
  - 예외 전환 방식

  ## 1.7 Reflection & Dynamic Proxy
  ### 1.7.1 Reflection
  - JVM은 클래스 정보(바이트 코드)를 클래스 로더를 통해 읽어와서 해당 정보를 JVM 메모리에 저장
  - 저장된 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법
  - 바인딩이란 프로그램에 사용된 구성 요소의 실제 값 또는 프로퍼티를 결정짓는 행위
    - 프로그램에서 사용되는 변수나 메서드 등 모든 것들이 결정되도록 연결해주는 것을 의미

  #### 정적 바인딩
  - 오버로딩: 컴파일 과정에서 어떤 메서드를 호출할지 결정하기 때문에 어떤 메서드를 사용할지 구분 할 수 있음

  #### 동적 바인딩
  - 오버라이딩: 상속을 이용한 부모-자식 관계일 경우 부모에서 정의한 메서드를 자식에서 Overriding 했을 때, 해당 메서드를 이용할 경우 Runtime에 어떤 메서드를 호출할지 정해짐
  - 실행 시간에 Binding 되다보니 정적 바인딩 보다는 성능상 오버헤드가 있지만 상속과 다형성 등 다양한 기능을 사용할 수 있는 장점이 있음

  #### 언제 사용할까?
  - 동적으로 Class를 사용해야할 경우
    - 코드 작성 시점에서는 어떠한 Class를 사용해야할지 모르지만 Runtime에 Class를 가져와서 실행해야하는 경우
      - Spring Annotation(DI)
  - 테스트 코드 작성
    - private 변수를 변경하거나 private method를 테스트할 경우
  - Jackson, GSON등의 Json 직렬화 라이브러리
    - 객체 필드의 변수명/어노테이션명을 Json key와 mapping
  
  팩토리 메서드를 통해 이름에 따라서 새로운 객체를 생성하는 방식이 if/else로 이루어져있을 때, 클래스 이름을 넘겨 동적으로 바인딩하여 클래스를 생성할 수 있음.

  ### 1.7.2 Dynamic Proxy
  - 동적으로 프록시 인스턴스를 만들어 등록하는 방법
  - Proxy Pattern
    - 기존 대상 원본 객체를 수정 없이 추가 동작 기능들을 가미하고 싶을 때 사용하는 패턴
    - 기존 프록시 패턴은 대상 원본 클래스 수 만큼 일일히 프록시 클래스를 하나하나 다 만들어야했음
    - 예를 들어 로깅을 한다했을 때, A class와 B class에 둘 다 적용하려면 A와 B의 프록시 객체를 만들어 별도로 적용해야했음
  - InvocationHandler를 구현하여 invoke 메서드를 오버라이딩하고 mtehod.invoke를 통해 기존 클래스 메서드 실행
  - 동적 프록시는 타입을 클래스가 아닌 무조건 인터페이스를 파라미터로 넣어야 함
    - 개선한 것이 CGLIB -> 클래스를 대상으로 바이트코드를 조작하여 프록시를 생성할 수 있는 라이브러리 스프링 기본 내장 (스프링 프레임워크에서 빈을 등록할 때 Spring AOP를 이용하여 프록시로 등록되는데 기본적으로 객체가 Interface를 하나라도 구현하고 있으면 Dynamic Proxy, 구현하고 있지 않으면 CGLIB을 이용)

  # 2. 질문
  1. 어떠한 클래스에서 private으로 설정된 필드가 있을 때 이 것을 해당 클래스안에 별도의 이너 클래스를 만들게 되면 해당 이너 클래스에서는 private 필드를 읽을 수 있는지?
  2. 클래스, 객체, 인스턴스에 대해서 설명해주시고 객체와 인스턴스는 어떠한 차이가 있는지 알려주세요.
  3. 오버라이딩과 오버로딩의 차이점을 말씀해주시고 예시를 들어서 설명해주세요.
  4. Call by Reference와 Call by Value는 어떤 것이고 어떤 차이가 있나요?
  5. Wrapper Class인 Integer를 어떠한 메서드의 매개변수로 넣고 해당 메서드안에서 값을 변경시켰을 때 호출한 클래스 내의 Integer 자료형의 값도 변경되는지? 변경되지 않으면 왜 변경되지 않은지?
  6. Checked Exception과 Unchecked Exception이 무엇인지 설명해주세요.
  7. 리플렉션이 무엇인지 설명해주시고, 언제 사용하면 좋을지 간단한 예를 들어서 설명해주세요.
  8. 다이나믹 프록시가 무엇인지 설명해주세요.