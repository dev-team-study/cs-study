# 객체지향, JDK/JRE/JVM

## 객체지향

### 4가지 특징

> 추상화
>
> > 객체의 공통적인 속성과 기능을 추출해 정의하는 것을 말합니다. 
> >
> > 추상화를 구현할 수 있는 방법으로는 abstract class, interface가 있습니다. 
>
> 상속
>
> > 기존에 구현한 클래스를 재활용해 구현할 수 있는 것을 의미한다.
> >
> > 상속을 통해 코드 재사용성을 높일 수 있다.
>
> 다형성
>
> > 어떤 객체의 속성이나 기능이 상황에 따라 여러 형태로 변할 수 있다.
> >
> > 메서드 오버라이딩 / 오버로딩이 있다.
> >
> > 다형성을 통해 개발 유연성, 코드 재사용성을 높일 수 있다.
>
> 캡슐화
>
> > 클래스 내의 연관된 속성이나 함수를 하나의 캡슐로 묶어 외부로부터 클래스로의 접근을 최소화하는것을 말한다. 
> >
> > 캡슐화는 객체간의 결합도를 감소시키고 응집도를 강화하는데 기여한다. 

### 5원칙 (SOLID)

> Single Responsibility Principle (단일 책임 원칙)
>
> > 작성된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는데 집중해야한다. 
> >
> > (어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.)
> >
> > 책임 영역이 확실해지기 때문에 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있다. 
>
> Open Close Principle (개방 폐쇄 원칙)
>
> > 확장에는 열려 있고 변경에는 닫혀 있어야 한다. 
>
> Liskov Substitution Principle (리스코프 치환 법칙)
>
> > 하위 타입은 언제나 상위 타입으로 교체할 수 있어야 한다. 
> >
> > (하위 타입은 상위 타입이 약속한 규약을 지켜야한다.)
>
> Interface Segregation Principle (인터페이스 분리의 원칙)
>
> > 하나의 일반적인 인터페이스 보다는, 여러개의 구체적인 인터페이스가 낫다. 
>
> Dependency Inversion Principle (의존성 역전의 법칙)
>
> > 상위 타입은 하위 타입의 구현에 의존해선 안되며, 하위타입이 상위 타입에 의존해야 한다. 

### 객체지향 vs 절차지향 vs 함수형 프로그래밍

> - 절차지향
>   - 순차적인 처리를 중요시 여기며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법
>   - 장점
>     - 코드의 가독성이 좋다. 
>     - 코드를 단위화할 수 있다.
>     - 컴퓨터의 처리구조와 비슷해 실행 속도가 빠르다.
>   - 단점
>     - 각각의 코드가 순서에 따라 실행되어 변경 및 유지보수가 어렵다.
>     - 변수나 상수 등의 값들을 관리하는 자료형과 해당 자료형을 사용하는 함수가 분리되어 사용된다.
>   - 예시
>     - C언어
> - 객체 지향 
>   - 모든 데이터를 객체로 취급해 객체가 처리 요청을 받았을 때 객체 내부에 있는 기능을 사용해 처리하는 기법
>   - 장점
>     - 코드의 재사용이 가능하다. (유지보수에 좋다.)
>     - 분석과 설계의 전환이 쉽다.
>   - 단점
>     - 처리 속도가 상대적으로 느리다. 
>     - 설계에 많은 시간이 소요된다. 
>   - 예시
>     - Java, Python
> - 함수형 프로그래밍
>   - 순수 함수를 사용해, 상태를 제어하기보단 빠르게 처리하는데 초점을 둔 방법
>   - 실행 순서를 지정할 필요가 없어 비 절차형 언어라고도 불림
>   - 장점
>     - 코드에서 프로그램의 실행에 영향을 미치는 영역과 순수한 영역을 최대한 분리
>     - 코드의 가독성이 높아지고, 유지보수가 좋아진다.
>     - 테스트가 쉬워진다.
>   - 단점
>     - 외부 데이터 혹은 내부 데이터 상태를 조작할 수 없다.
>   - 예시
>     - Haskell, OCamal

## JDK, JRE, JVM

### 컴파일 과정

> 1. 자바(.java) 소스코드를 작성
> 2. 자바 컴파일러가 자바 소스파일을 컴파일함
>    - 아직 컴퓨터가 읽을 수 없는 자바 가상 머신이 이해할 수 있는 코드
> 3. 컴파일된 바이트 코드를 JVM의 클래스 로더에게 전달.
> 4. 클래스 로더는 동적로딩을 통해 필요한 클래스들을 로딩 및 링크해 런타임 데이터 영역 (JVM의 메모리)에 올린다.
>    - 로드 : 클래스 파일을 가져와 JVM의 메모리에 로드함,
>    - 검증 : 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어 있는지 검사함.
>    - 준비 : 클래스가 필요로 하는 메모리를 할당.
>    - 분석 : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
>    - 초기화 : 클래스 변수들을 적절한 값으로 초기화 함. (static field)
> 5. 실행 엔진은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 
>    - 인터프리터 : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행.
>    - JIT Compiler : 바이트 코드 전체를 컴파일해 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅하지 않고 바이너리 코드로 직접 실행하는 방식

### 컴파일 언어 vs 인터프리터 언어

> 컴파일 언어
>
> > 컴파일 : 고급 언어로 작성된 소스 코드를 저급 언어로 번역하는 프로그램
> >
> > 컴파일 언어는 컴파일러를 통해 컴파일 타임에 전체 소스코드를 한번에 기계어로 변환 후 실행파일을 만든다.
> >
> > 컴파일 언어는 컴파일 단계와 실행 단계가 분리되어있으며, 컴파일은 단 한번만 수행한다. 
> >
> > 실행시에는 컴파일 과정을 거치지 않고 실행만 하면 되므로 코드 실행 속도가 빠르다.
> >
> > Java, C, C++ .. 
>
> 인터프리터 언어
>
> > 인터프리터 : 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램
> >
> > 인터프리터 언어는 소스 코드를 한번에 기계어로 변환하는 컴파일러와 달리, 컴파일 하지 않고 소스 코드를 한줄씩 읽어들여 실행한다. 
> >
> > 컴파일 하는 과정이 없어 컴파일 하는 시간이 소요되지 않으나, 인터프리터 언어는 실행파일을 별도로 생성하지 않기 때문에 실행시마다 인터프리터 과정이 반복 수행되어 실행 속도가 느리다는 단점이 존재한다. 
> >
> > Python, JavaScript, Ruby .. 

### JVM 메모리 구조

> JVM Memory 영역은 Method, Heap, Stack, PC Register, Native Method Stack 영역으로 구성되어 있다.
>
> - Method Area
>   - Constant Pool 
>   - field 
>   - method code 등이 저장되는 영역
> - Heap Area
>   - 클래스 인스턴스들이 저장되는 런타임 데이터 영역으로 GC가 관리해준다. 
>   - new 연산으로 생성된 모든 클래스 인스턴스가 저장되는 영역
>   - 멀티 스레드 환경에서 Heap 영역은 모든 스레드가 공유
> - Stack Area
>   - 스레드마다 별도의 스택을 가짐
>   - 메서드 호출 시 스택 프레임이 증가하며 반환 시 프레임이 자동 소멸된다.
>   - 지역변수, 피연산자, 스택 프레임 데이터 등 세가지 요소로 구성된다. 
> - PC Register
>   - 일반 CPU처럼 PC Register를 가지며 같은 역할을 수행
>   - 스레드 마다 별도 문맥을 가질 수 있도록 개별 PC Register를 가진다.
> - Native Method Stack
>   - C, C++과 같은 Native 언어로 개발된 메서드를 지원하기 위한 스택
>   - 스레드마다 별도로 제공됨

### Garbage Collector 동작과정

> - Minor GC 
>   - Young Generation 영역에서 발생되는 GC 
>   - 처음 생성된 객체 Eden 영역에 위치
>     - Eden 영역이 다 차게 되었을 때 Minor GC 실행 
>       - Reachable 객체 탐색후 살아남은 객체는 1개의 Survivor 영역으로 이동 
>       - Unreachable 객체의 메모리를 해제 
>       - 살아남은 객체들은 age 1 증가
> - Major GC 
>   - Old Generation 영역에서 발생되는 GC 
>     - Old Generation 영역의 공간이 부족하게 되면 Major GC 발생 
>     - ㅡ

### Java8의 큰 특징 + Java11과의 차이점

> Java8
>
> - lambda
>   - 함수를 하나의 표현식으로 나타낸 것
> - Optional 
>   - null이 될 수 있는 객체를 담는 클래스
> - Method Reference 
>   - 람다의 축약 표현
> - stream
>   - Stream의 데이터 흐름으로 람다를 사용할 수 있도록 제공
> - 인터페이스 default, static method
>   - default, static 지시어로 생성된 메서드는 구현부를 가질 수 있다.
> - LocalDateTime 제공
>
> Java 11의 차이점
>
> - String 클래스 메서드 추가
>   - isBlank(), lines(), strip() ... 
> - File 클래스 메서드 추가
> - 람다에서 로컬 변수 var 사용



# 질문

1. 객체지향의 4가지 특징에 대해서 간략하게 설명해주세요. 
2. 자바의 컴파일 동작 과정에 대해서 설명해주세요.
3. 컴파일 언어와 인터프리터 언어는 어떠한 차이점을 지니고 있나요?
4. JVM의 메모리 구조에 대해 간략히 설명해주세요
5. GC의 동작 과정에 대해서 설명해주세요. 

