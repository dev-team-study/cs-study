# static
- 컴파일 타임에 메모리 할당을 단 한번 한다.
- 모든 인스턴스에 공통으로 사용하는 내용에 static을 붙여 사용한다.
인스턴스간 같은 값을 유지하기 위해서 static을 사용한다.
- 클래스가 메모리에 올라가면 static 멤버변수를 사용할 수 있다.
- static메서드는 인스턴스 변수를 사용할 수 없다.
- main메서드가 static인 이유 : 프로그램 실행 순간에 메모리에 할당되어야 한다. gc의 정리되상이 되어서는 안된다.

# final
- 클래스의 final : 상속을 허용하지 않음
- 변수의 final : 변경 불가능한 상수, 재하라당이 불가능하다.(컴파일 에러 발생)
- 메서드 내부 변수 final : 선언시 초기화, 사용 전 초기화
- 객체의 멤버 변수 final : 선언시 초기화, 생성자를 이용해 초기화, 초기화 block을 이욯애 초기화 변수에 값을 할당하기 전 별도의 로직이 실행되어야 하는 등의 상황에서 사용
- static 변수 : 선언시 초기화, static 초기화 block을 이용해 초기화
- overriding을 금지한다. (상속 불가능 특성)
- 인터페이스는 추상 메서드와 정적 상수만 가질 수 있어 static, final을 붙이지 않아도 된다.
- finally : try/catch 블록이 종료될때 실행될 코드 블록을 정의하기 위해서 사용
- finalize : gc가 더이상 참조하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.

### effectively final
변수에 final키워드를 붙이지 않아도 해당 값이 변경될 가능성이 어벗으면 final키워드가 붙였다고 여기는 것

익명 클래스나람다 표현식에서 외부 지역변수를 참조할 때, 외부 지역 변수는 반드시 final 키워드가 붙거나 effectively final이어야 한다.

동시성 문제, 멀티스레드에서는 지역 변수를 사용하는 스레드와 람다식을 사용하는 스레드가 다를 수 있다.
지역변수는 클래스 변수나 인스턴스 변수와는 달리, 각 스레드의 스택프레임에 생성된다.<br>
그래서 다른 스레드를 사용하는 람다식에서는 해당 지경변수의 최신값을 동기화할 수 없어 final키워드를 사용할 수 잇게 하였다.

### final이 완벽한 불변을 보장하지는 않는다.
- 변수의 재할당을 막지만, 참조하고 있는 객체 내부의 상태가 변함을 보장하진 않는다.
- ex : arrayList에 add하면 add를 할 수 있다.
### 불변성을 보장받는 방법
- 객체의 경우 생성자를 통해 값을 주입받는다.
- 컬렉션의 경우 unmodifiable collection을 활용한다.
(이마저도 첫 선언이 일반 collection이라면 불변성을 보장할 수 없어 직접 복사해서 사용하는 것이 가장 안전)

# generic
클래스나 메소드를 일반화된 타입 매개변수를 이용해 선언하는 기법

### static은 객체가 생성되기전에 이미 메모리에 올라가는데 제네릭으로 사용하면 타입을 어디서 얻어오는가?
제네릭 메소드의 제네릭 타입은 지역변수처럼 사용되어, static메소드가 메모리에 올라가더라도 타입이 지정되지 않고 메소드의 틀만 지정된다.
메소드 호출 시 타입을 지정하면 된다.

### 와일드카드

< ? extends T> : T와 T의 자손 타입만 가능<br>
< ? super T > :  T와 T의 부모(조상) 타입만 가능<br>
< ? >	 :  모든 타입 가능 <? extends Object>랑 같은 의미

extends T : 상한 경계, 뒤에 오는 타입이 최상위 타입으로 한계가 정해짐<br>
< T extends Fruit > : Fruit, Apple 타입만 올 수 있음<br>
< T extends Beef > : Beef 타입만 올 수 있음<br>
< T extends Food > : Food, Fruit, Apple, Meat, Beef 타입이 올 수 있음<br>

만일 여러 개의 타입을 동시에 상속한 경우로 제한하고 싶다면 & 기호를 사용할 수 있음
super T : 하한 경계, 뒤에 오는 타입이 최하위 타입으로 한계가 정해짐<br>
< ? super Fruit > : Fruit, Food 타입만 올 수 있음<br>
< ? super Beef > : Beef, Meat, Food 타입만 올 수 있음<br>
< ? super Food > : Food 타입만 올 수 있음<br>

### 사용 이유
제네릭 파라미터의 타입보다 제네릭 파라미터를 사용하는 방법이 더 중요할 때 사용한다.

### < T extends [타입] >와 < ? extends [타입] >의 차이
유형 경계를 지정하는 것은 같으나,
경계가 지정되고 T는 특정 타입으로 지정이 되지만, ?는 타입이 지정되지 않는다.

### 장점 
- 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.
- 클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다, 관리가 편하다.
- 비슷한 기능을 지원하는 경우, 코드 재사용성이 높아진다.

# stream, lambda
## stream
병렬 처리 방식으로 데이터를 쉽게 필터링, 변환, 집계할 수 있다. 개발자가 쉽게 읽을 수 있으며, 복잡한 작업을 쉽게 수행할 수 있다.

### 장점
- 함수형 프로그래밍
- 지연평가 (필요한 경우에만 요소를 평가해 메모리 사용량을 줄이고 성능을 향상시킬 수 있음)
- 병렬 처리
- 중간 및 종료 조건의 두가지 우형을 처리한다.

### 특징
- 원본 테이터를 변경하지 않는다. 원본 데이터를 조회해 별도 요소로 stream을 생성한다.
- 일회용으로 재사용이 불가능하다.
- 내부에서 반복적으로 작업을 처리한다.(for와 while문의 역할을 대신할 수 있음)
- filter, map 등 지연연산으로 성능 최적화 가능
- 메서드를 통해 손쉬운 병렬 처리가 가능하다.

### stream의 foreach
Stream은 컬렉션 등의 요소를 하나씩 참조해 함수형 인터페이스(람다식)를 통해 반복적인 작업의 처리를 가능하게 해준다.

- stream 자체를 강제적으로 종료할 수 없다. 로직의 수행을 막을 수는 없지만, 모두 순회하며 로직의 수행으르 막아야 하는지 판단한다.
(최종 연산으로만 사용하는 경우 문제)
- for-each 내부에 로직이 하나 더 추가되면 동시성 보장이 어렵고 가독성이 떨어진다.
- 향상된 for문으로 해결하는 것이 더 좋아보임
- Collection의 foreach는 따로 객체를 생성하지 않고 forEach메서드를 호출한다.stream은 생성 비용이 있음
- parallelStream 메서드로 stream객체를 생성하면 여러 스레드에서 스트림을 실행해 실행순서가 매번 달라지고 예측 불가능하다.
- collection의 foreach는 수정을 감지하면 허가되지 않은 변경이 동시에 이루어짐을 감지해 exception을 날림
- stream은 무조건 리스트를 끝까지 돌고 npe를 던짐

## lambda
함수를 하나의 식으료 표현한 것. 불필요한 코드를 줄이고, 가독성을 높인다.(익명 함수)
타입 f = (매개변수) -> 구현부

### 특징
- 람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
- 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.
- 함수형 인터페이스는 추상메소드가 하나이기 때문에 따로 명시하지 않아도 그 내용을 알 수 있음

### 장점
- 식에 개발자의 의도가 명확히 드러나 가독성이 높아진다.
- 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.
- 병렬프로그래밍이 용이하다.

### 단점
- 람다를 사용하면서 만든 익명함수는 재사용이 불가능하다.
- 디버깅이 어렵다.
- 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있다.
- 재귀로 만들경우 부적합하다.

# hashcode & equals

## equals
동일성 비교. 객체의 주소값으로 비교를 한다. 
- 내용을 overriding해서 비교할 수도 있다. (String, Date,File,Wrapper)클래스들은 주소값이 아닌 내용을 비교한다.
- StringBuffer는 오버라이딩 되어있지 않음
- ==으로 비교가 되는 이유 : stack영역에 변수가 저장되고 해당 변수에 저장된 상수는 runtineConstantPool에 저장되어 있다.
스택의 변수 선언부는 constantpool의 주소값을 가지고 있고, 다른 변수도 같은 상수를 저장하고 있으면, constant pool의 주소값을 가지고 있어 주소값 비교가 가능하다.

### 언제 저장하는가?
- 논리적 동치성 비교가 필요한 경우
- 값 클래스 처럼 값을 표현하는 클래스의 비교(값이 같은지를 알고싶기 때문)
- enum과 같은 클래스들은 equals를 재정의하지 않아도 되는 경우임 인스턴스가 2개 이상 만들어지지 않음

### 메서드 규약
- 반사성 x.equals(x) 는 true
- 대칭성 x.equals(y) 가 true면 y.equals(x) 도 true다
- 추이성 x.equals(y) true고 y.equals(z)도 true면 xz도 같을것이다.
- 일관성 x.equals(y) 를 반복해도 항상 t/f중 하나로만 반환
- x.equals(null) 은 false

### 양질의 equals
- ==를 사용해 자기 자신의 참조인지 확인
- instanceof로 타입 확인
- 올바른 타입으로 형변환

## hashCode
- 찾고자 하는 값을 입력하면, 그 값이 저장된 위치를 알려준다.
- 해시코드가 같은 객체가 2개 이상 존재할 수 있다. 하지만 그 경우 값도 같아야한다.(64bit jvm에서 중복 가능)
- String 클래스는 내용이 같으면 동일한 해시코드를 반환하도록 오버라이딩 되어있다.
- Object 클래스는 heap에 저장된 객체의 메모리 주소값으로 해시코드를 만들어, 객체에 대해서는 항상 다른 해시코드 값을 반환한다.
  (해시코드는 같지만, 서로 다른 객체임을 알 수 있게 해줌)

### 해시 충돌
- hashTable은 key,value 형태로 데이터를 저장한다. 이때 해시 함수를 이용해 key값을 기준으로 고유한 식별값인 해시값을 만든다.
  이 해시값은 버킷에 저장된다.
- hashTable의 크기는 한정적이어서 다른 객체이더라도 같은 해시값을 가질 수 있다. 이때 해시 충돌이 일어난다.
- 이때 해당 버킷에 linkedList 형태로 객체를 추가한다.

put 하는 경우라면 
- 같은 해시값 버킷에 다른 객체가 있다면, equals메서드가 사용된다. 
값이 같은 객체라면, 기존 객체를 덮어쓰고(equals true), 없다면, entry를 linkedList에 추가한다.(equals false)

get 하는 경우라면
- 값이 같은 객체가 있다면 그 객체를 reeturn
- 값이 같은 객체가 없다면 null을 return한다.

### equals와 hashcode를 재정의해야 하는 이유
- 동일한 객체는 동일한 메모리 주소를 가지고, 동일한 해시코드를 가져야한다.
- hashCode만 재정의 하지 않으면, 같은 값은 객체여도 서로 다른 해시값을 가져 객체가 저장된 버킷을 찾을 수 없다.
- 특히 hashMap의 key값으로 해당 객체를 사용할 경우 문제가 발생한다.
- equals가 두 객체를 다르다고 판단하더라도 두 객체의 hashCode값은 같을 수 있다.(해시 충돌)
- equals를 재정의하지 않으면, hashCode로 객체가 저장된 버킷을 찾을 수 있지만, 그 객체가 자신과 같은 객체인지 비교할 수 없다.