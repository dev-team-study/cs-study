# 1. Servlet
   ## 1.1 개념
   - 동적 웹페이지를 만들 때 사용되는 자바 기반의 웹 애플리케이션 프로그래밍 기술
   - 웹을 만들 때 다양한 요청과 응답이 있고 이 요청과 응답에는 규칙이 존재
     - 이러한 요청과 응답을 일일히 처리하지 않고 서블릿을 통해 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 됨
   - Servlet 이전에는 CGI(Common Gateway Interface)라는 프로그램이 있었음
     - CGI는 웹서버와 사용자 요청을 받아서 처리하는 외부 프로그램을 연결해주는 인터페이스를 의미
     - CGI는 요청마다 새로운 프로세스를 생성해야해서 비효율적

   ## 1.2 tomcat
   - 서블릿 컨테이너를 포함하고 있는 대표적인 오픈소스 웹 서버이면서 동적인 컨텐츠도 처리 가능하기 때문에 웹 애플리케이션이라고도 함
  
   ## 1.2.1 tomcat의 처리 과정
   1. 클라이언트가 톰캣 서버의 80번 포트로 HTTP 요청을 보내면, 해당 포트의 Coyote Connector 를 통해 Catalina Engine 으로 요청
    — 이 때, Connector와 Engine을 연결해주는 컴포넌트가 바로 Service
   2. Catalina Engine은 Connector를 통해 클라이언트의 요청을 받은 후, 요청에 맞는 Host 내 Context, 즉 어플리케이션에 요청을 전달
   3. Context는 `/WEB-INF/web.xml`이라는 web application deployment descriptor file 에 정의된 서블릿 맵핑 정보를 참고하여 요청에 맞는 Servlet을 찾고, 해당 Servlet에게 요청을 전달
   4. Servlet이 반환하는 응답은 `Context` -> `Catalina Engine` -> `Connector` 를 통해 클라이언트에게 전달
    — 즉, 클라이언트의 HTTP request 인입 > Catalina > Context > Servlet > 클라이언트 response 반환 순으로 처리 됨
   

   ## 1.3 filter
   - client로 부터 Server로 요청이 들어오기 전에 서블릿을 거쳐서 필터링 하는 것을 의미
   - 공통적인 기능들을 서블릿이 호출되기 전에 수행되게 하고 싶거나 서블릿이 호출되고 난 뒤에 후처리 하고싶을 때 사용 가능
     -  물론 AOP로도 공통 관심사 처리가 가능하지만 웹과 관련된 공통 관심사(HTTP header, URL 정보 등)을 처리할 때 유용 -> HttpServletRequest를 제공하기 때문
   ### 1.3.1 Filter의 라이프 사이클
   - 생성, 초기화, 필터, 종료 4단계
   - init()을 호출하면 필터 인터페이스를 초기화하여 바로 요청을 처리할 수 있는 상태가 됨
   - service() 메서드 처럼 필터는 doFilter() 메서드를 통해서 요청을 처리
   - destory() 메서드 호출시 필터는 비활성 상태로 변경
   
   ### 1.3.2 FilterChain
   - 필터는 연속적인 작용을 수행
   - 필터 객체가 수행해야할 부분인 doFilter()메서드로 전달되는 것은 FilterChain 객체
   - Filter 여러개가 모여서 하나의 체인을 형성하는 것

   ## 1.4 servlet container
   - 웹 서버와 자바 서블릿 간의 상호작용을 담당하는 서블릿의 런타임 환경
   - 서블릿을 담고 관리해주는 컨테이너
   - 구현되어있는 Servlet 클래스의 규칙에 맞게 서블릿을 관리해주고 클라이언트에서 요청시 컨테이너는 HttpServletRequest와 HttpServletResponse 두 객체를 생성하여 post,get 여부에 따라 동적인 페이지를 생성하여 전달
     - HttpServletRequest
       - http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용하며 헤더, 파라미터, 쿠키, URI 등의 정보를 읽어 들이는 메서드와 Body의 Stream을 읽어 들이는 메서드를 가지고 있음
     - HttpServletResponse
       - 요청을 보낸 클라이언트에게 응답을 보내기 위한 객체로 서블릿에게 전달하고 이 객체를 활용하여 Content-Type, 응답 코드, 응답 메시지 등을 전송
   ## 1.4.1 주요 기능
 ### 1. 생명 주기 관리
 - 서블릿 컨테이너가 가동 되는 순간 서블릿 클래스를 로딩해서 인스턴스화 하고, 초기화 메서드를 호출하고, 요청이 들어오면 적절한 서블릿 메서드를 찾아서 동작

### 2. 통신 지원
- 클라이언트의 Request를 받아주고 Response를 보낼 수 있게 웹 서버와 소켓을 만들어서 통신 함
- 소켓을 만들어 특정 포트를 리스닝하고, 연결 요청이 들어오면 스트림을 생성해서 요청을 받음
  - 이 과정을 통해 비지니스 로직에 더 집중할 수 있음

### 3. 멀티스레딩 관리
- 서블릿 컨테이너는 해당 서블릿의 요청이 들어오면 스레드를 생성해서 작업을 수행
- 동시에 여러 요청이 들어와도 멀티스레딩 환경으로 동시다발적인 작업을 관리 함

## 1.5 동작과정
 1. Servlet Request, Servlet Response 객체를 생성
 2. 설정 파일을 참고하여 매핑할 Servlet을 확인
 3. 서블릿 인스턴스 존재의 유무를 확인하여 없으면 init() 메서드 호출하여 생성
 4. Servlet Container에 스레드를 생성하고 service를 실행
 5. 응답을 처리 후 distory() 메서드를 실행시켜 Servlet Request와 Servlet Response 객체를 소멸시킴


 ## 1.6 서블릿의 생명주기 메서드
 - init()
   - 서블릿이 처음으로 요청 될 때 초기화를 하는 메서드
   - 클래스를 new하는 것 처럼 서블릿 클래스도 초기화를 해야 사용 가능
   - 초기화 된 서블릿은 싱글톤으로 관리되어 다음에 한 번 더 해당 서블릿 클래스를 호출시 기존에 있던 서블릿 클래스를 호출
 - service()
   - 서블릿 컨테이너가 요청을 받고 응답을 내려줄 때 필요한 서블릿의 메서드
   - 실질적으로 클라이언트의 요청을 처리하는 메서드
   - Servlet Interface를 구현한 HttpServlet 클래스의 doGet, doPost 메서드들이 호출
 - destroy()
   - 더 이상 사용되지 않는 서블릿 클래스는 주기적으로 서블릿 컨테이너가 destory()메서드를 호출하여 제거


# 2. Spring 기본
   ## 2.1 Spring vs Spring MVC vs Spring Boot
   ### 2.1.1 Spring
   - Java 기반 애플리케이션 개발을 지원하는 오픈소스 애플리케이션 프레임워크
   
   #### 2.1.1.1 Spring의 특징 
   - 제어 역전(IoC)
     - 객체의 생명 주기 및 의존성 관리를 담당하는 IOC 컨테이너를 제공
     - 객체의 생성과 관계 설정을 스프링에 위임하여 스프링 컨테이너가 객체의 생명 주기를 관리하고 의존성을 주입
   - 의존성 주입(DI)
     - 의존성 주입을 통해 객체 간의 관계를 설정
     - 애플리케이션의 결합도를 낮추고 유연성과 테스트 용이성을 향상시킴
   - AOP(관점 지향 프로그래밍)
     - 애플리케이션의 핵심 비즈니스 로직과 부가적인 기능을 분리하여 모듈화할 수 있음
   - 웹 개발 지원
     - 웹 개발을 위한 다양한 기능과 계층을 제공
 
   #### 2.1.1.2 Spring의 단점
   - 설정의 복잡성
     - 기능을 제공하기 위해 많은 설정과 구성이 필요함
   - 높은 초기 학습 난이도
     - 다른 프레임워크에 비해 학습이 필요한 부분이 많음
   - 의존성 관리 문제
     - XML 파일에 많은 수의 빈을 등록해야 함
     - 코드 가독성을 떨어뜨리고, 의존성 관리가 어려워질 수 있음
   - 별도 WAS 서버 구성의 번거로움
     - 별도의 WAS를 설치하고 설정해야 함
     - 애플리케이션 서비스하기 위해서 별도의 서버에 수동으로 배포해야하는 번거로움이 있음

   ### 2.1.2 Spring MVC
   - 스프링 프레임워크에서 제공하는 모듈 중 하나로, 웹 애플리케이션의 개발을 위한 기본적인 웹 프레임워크
   - 개발자가 애플리케이션의 모든 측변을 세밀하게 제어할 수 있는 유연성을 갖음
     - 보일러 플레이트에 대한 코드 작성을 매번 해야하는 번거로움, 설정의 어려움을 갖고 있음
     - Spring에서 얘기한 단점과 거의 동일함

   ### 2.1.3 Spring Boot
   - 스프링의 문제점을 해결하기 위해 간단한 설정과 구성을 통해 스프링 애플리케이션의 개발을 빠르게 시작할 수 있도록 해주는 프레임워크
  
   #### 2.1.3.1 Spring Boot의 특징
   - 간결한 설정
     - 번거로운 XML 설정이 필요 없으며, 최소한의 설정으로 Spring을 사용할 수 있고 기본적인 설정을 자동으로 처리함
     - 비지니스 로직에 집중 가능
   - 내장 서버
     - 내장된 서버 Tomcat, Jetty 등을 제공하여 별도의 서버 설정 없이 애플리케이션을 실행할 수 있음
     - 배포를 위해 War 파일을 생성해서 Tomcat에 배포할 필요가 없으며, JAR 파일에 모든 의존성 라이브러리가 포함되어있어 외부 서버 없이도 애플리케이션 실행 가능
   - 의존성 관리 간소화
     - 여러 써드파티 라이브러리를 사용할 때 발생하는 라이브러리 버전 충돌로 인한 문제를 해결하기 위해 이미 테스트된 여러 라이브러리들의 묶음 패키지를 제공

   스프링 부트는 스프링의 장점은 그대로 계승하면서, 기본의 문제가 되는 부분을 보완하여 생산성, 서비스 운영, 성능 모두 해결할 수 있음

   ### 2.2.1  MVC1 vs MVC2
   #### 2.2.1.1 MVC란
   - 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴
   - 소프트웨어의 비지니스 로직과 화면을 구분하는데 중점을 두고 있음
     - 이러한 관심사의 분리는 더 나은 업무의 분리와 향상된 관리를 제공
   - 세가지 역할
     - Model: 데이터와 비지니스 로직을 관리
       - 앱이 포햄해야할 데이터가 무엇인지를 정의
     - View: 레이아웃과 화면을 처리
       - 앱의 데이터를 보여주는 방식을 정의
     - Controller: 모델과 뷰로 명령을 전달
       - 앱의 사용자로부터의 입력에 대한 응답으로 모델 및 뷰를 업데이트하는 로직을 포함

   #### 2.2.1.1 MVC1
   ![image](https://i.imgur.com/rzhzcZc.png)
   - View와 Controller를 모두 JSP가 담당하는 형태를 가짐
   - JSP 하나로 유저의 요청을 받고 응답을 처리
   - Model은 JavaBean으로 처리
   - 앱의 크기가 커지면 커질수록 제대로 분리되지 못한 환경 때문에 코드의 복잡성이 증가하고 재사용성이 떨어지며 유지보수에 있어서도 문제가 발생할 가능성이 높음

   #### 2.2.1.2 MVC2
   ![image](https://i.imgur.com/keastvz.png)
   - 요청을 하나의 컨트롤러, Servlet이 먼저 받는형태로 Controller와 View가 분리되어있음
   - M, V, C중 수정해야할 부분이 있다면, 그것만 꺼내서 수정하면 됨
     - 유지보수에 있어서도 큰 이점을 갖음

   ## 2.2 dispatcher servlet
   - Dispatcher Servlet이 포함되면 Spring MVC라고 볼 수 있음
   - HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러라고 정의할 수 있음
   - **예시**
  1. 클라이언트로부터 어떠한 요청이 오면 Tomcat과 같은 서블릿 컨테이너가 요청을 받음
  2. 이 요청은 프론트 컨트롤러인 디스패처 서블릿이 가장 먼저 받음
  3. 디스패처 서블릿은 공통적인 작업을 먼저 처리한 후에 해당 요청을 처리해야하는 컨트롤러를 찾아서 작업을 위임

   ### 2.2.1 동작 과정
   ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbcff5H%2FbtstbdRuSr9%2FpNKnGdMwftSWmiGLHA7yL0%2Fimg.png)

   #### 1. 클라이언트의 요청을 디스패처 서블릿이 받음
   ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoN96r%2Fbtrw7SYEpgr%2FlKLp5nqEZUJR32GoPc9bwk%2Fimg.png)
   - 필터들을 지나 스프링 컨텍스트에서 디스패처 서블릿이 가장 먼저 요청 받음
   - 인터셉터가 컨트롤러로 요청을 위임하지는 않음!

   #### 2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음
   - 요청을 처리할 핸들러(컨트롤러)를 찾고 해당 객체의 메소드를 호출
   - HandlerMapping
     - 가장 먼저 어느 컨트롤러가 요청을 처리할 수 있는지 식별하는 역할
     - Spring에서는 `@Controller`로 작성된 모든 컨트롤러를 찾고 파싱하여 HashMap으로 <요청 정보, 처리할 대상>으로 관리

   #### 3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달
   - HandlerAdapter를 통해 컨트롤러로 요청을 위임
   - 어댑터 패턴을 적용함으로써 컨트롤러의 구현 방식에 상관없이 요청을 위임 가능
   
   #### 4. 핸들러 어댑터가 컨트롤러로 요청을 위임
   - HandlerAdapter 컨트롤러의 요청을 위임한 전/후에 공통적인 전/후처리 과정이 필요
   - `@RequestParam`, `@RequestBody`등을 처리하기 위한 ArgumentResolver들과 응답시에 ResponseEntity의 Body를 Json으로 직렬화하는 등의 처리를 ReturnValueHander 등이 핸들러 어댑터에서 처리 됨
   - ArgumentResolver 등을 통해 파라미터가 준비되면 리플렉션을 이용해 컨트롤러로 요청을 위임

   #### 5. 비지니스 로직을 처리함
   - 컨트롤러는 서비스를 호출하고 작성한 비즈니스 로직들이 실행됨

   
   #### 6. 컨트롤러가 반환 값을 반환
   - 비지니스 로직이 처리된 후에는 컨트롤러가 반환 값을 반환 함
   - 응답 데이터를 사용하는 경우 ResponseEntity를 주로 반환하고, 응답 페이지를 보여주는 경우라면 String으로 View의 이름을 반환

   #### 7. 핸들러 어댑터가 반환 값을 처리함
   - HandlerAdapter는 컨트롤러로부터 받은 응답을 응답처리기인 ReturnValueHandler가 후처리한 후에 디스패처 서블릿으로 돌려줌
   - 컨트롤러가 ResponseEntity를 반환하면 HttpEntityMethodProcessor가 MessageConverter를 사용해 응답 객체를 직렬화하고 응답 상태를 설정. 
   - 만약 컨트롤러가 View 이름을 반환하면 ViewResolver를 통해 View를 반환 함

   #### 8. 서버의 응답을 클라이언트로 반환
   - 디스패처 서블릿을 통해 반환되는 응답은 다시 필터를 거쳐 클라이언트에게 반환 됨
   - 응답이 데이터라면 그대로 반환되지만, 응답이 화면이라면 View의 이름에 맞는 View를 찾아서 반환해주는 ViewResolver가 적절한 화면을 내려줌 

- 정적자원과 동적 자원을 분할 처리하기도 함
  - 디스패처 서블릿에서 요청을 처리할 컨트롤러를 못 찾는 경우 2차로 설정된 정적 자원을 탐색

### 2.2.3 용어
  - HandlerMapping: 요청을 처리할 컨트롤러를 찾기 위한 맵핑
  - HandlerAdapter: 요청을 컨트롤러로 위임하기 위한 어댑터
  - ViewResolver: 뷰를 반환하기 위한 리졸버