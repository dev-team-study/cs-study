# Spring 기본
## IoC & DI
IoC : 제어의 역전. IoC컨테이너가 등장하기 전에는 일반적으로 개발자가 작성하는 코드가 라이브러리를 호출했기 때문에 실행흐름이 개발자가 작성한 코드에서 제어된다고 볼 수 있었습니다. 하지만 IoC컨테이너를 지원하는 프레임워크의 등장 이후로는 프레임워크가 개발자가 작성한 코드를 호출하도록 바뀌었습니다. 이 때문에 프레임워크가 개발자의 코드를 제어하는 방향으로 제어의 방향이 바뀌었다는 의미에서 제어의 역전이라고 표현합니다.

DI : 의존성 주입. 사용하고 싶은 의존성을 직접 만들어서 사용하는 대신에, 미리 만들어둔 객체를 외부로 부터 주입받아서 사용하는 방식입니다. IoC컨테이너의 등장으로 인해 미리 컨테이너에 빈들을 등록해두고 꺼내서 쓰는 것이 가능해졌는데요. 이 덕분에 DI를 더 효율적으로 활용할 수 있게 되었습니다.    

## Bean, Component
@Bean과 @Component 모두 목적이 명확하지 않은 Bean을 생성할 때 사용하는 어노테이션입니다. 하지만 @Bean의 개발자가 컨트롤 할 수 없는 클래스를 빈으로 등록하고 싶을 때 사용하고, @Component의 경우 개발자가 컨트롤할 수 있는 클래스를 등록하고 싶을 때 사용합니다. 좀 더 구체적으로 말씀드리자면 직접 작성한 클래스의 경우 클래스 위에 Component어노테이션을 붙여서 빈으로 등록할 수 있는데요. 라이브러리에서 import해오는 클래스의 경우 해당 라이브러리 소스코드에 직접 Component 어노테이션을 달 수는 없으니까 메서드 안에서 객체를 생성한 뒤에 메서드에 @Bean어노테이션을 붙여서 등록하는 식으로 처리합니다.

## @Component @Service @Controller @Repository
먼저 @Component 의 경우 IoC컨테이너에 객체를 등록시키기 위해 사용되는 가장 기본적인 어노테이션입니다. 이 어노테이션을 붙이면 빈 자동 스캔이나 DI 등의 적용대상이 됩니다.  
다음으로 @Controller나 @Repository 같은 어노테이션의 경우 @Component 어노테이션을 상속받은 어노테이션들 입니다. 따라서 @Component를 붙였을 때 수행되는 기능을 모두 적용받을 수 있습니다. 여기에 더해 Controller의 경우 이 어노테이션이 붙인 클래스에서만 @RequestMapping 어노테이션을 붙일 수 있게하고, @Repository어노테이션의 경우 각 DB접근 플랫폼이 발생시키는 예외를 잡아서 Spring에서 약속된 데이터 접근 계층의 예외로 다시 던져주는 등의 추가작업을 수행합니다.  


## Container
스프링에서 컨테이너는 일반적으로 IoC컨테이너를 의미합니다. IoC 컨테이너는 스프링 어플리케이션이 실행될 때 함께 생성되어서 빈을 등록하고, 의존성을 주입하는 등 스프링에서 빈을 관리하는 역할을 수행합니다.    
IoC 컨테이너를 구현하는 클래스에는 대표적으로 Bean Factory와 Application context 두 가지 클래스가 있습니다.

Application context는 Bean Factory를 상속받은 클래스이기 때문에 기존 기능을 모두 가지면서도 몇 가지 기능이 추가된 클래스입니다. 추가된 기능 중에 대표적인 기능이 바로 @Profile어노테이션인데요. 이 어노테이션은 Application Context와 같은 패키지에 속한 어노테이션으로, 빈을 등록할 때 특정 프로파일에서만 이 빈이 주입되도록 설정해줄 수 있습니다. 예를 들어서 운영환경과 개발환경의 DB가 다르고 빈을 등록해서 이를 설정 한다고 할 때, 실행된 환경에 맞게 빈이 등록되고 주입되도록 설정해줄 수 있습니다.

## Bean Scope
싱글톤 : 
- 어플리케이션에 해당 클래스의 빈이 딱 하나만 생성되어 컨테이너에 등록된다. 이후 주입이 필요한 클래스에 모두 같은 참조를 가진 싱글톤 빈이 주입된다. 싱글톤 특성 상 stateless하게 구성하는게 좋다는 특징을 가지고 있다.
- 싱글톤 빈의 생명주기는 IoC컨테이너의 생명주기와 거의 비슷하다. 컨테이너가 생성될 때 등록되서, 스프링이 종료되면서 컨테이너가 내려갈 때까지 계속 컨테이너에게 관리된다.        
프로토타입 :
- 싱글톤과 달리 프로토타입 빈은 클라이언트들이 빈을 요구할 때마다 컨테이너에서 빈을 생성하고 의존성을 주입해주게 됩니다.  
- 생명주기도 싱글톤 빈과는 조금 다른데 컨테이너에서 의존성 주입을 해주고 난 뒤 부터는 컨테이너가 프로토타입 빈을 관리하지 않기 때문에 각 빈의 생명주기가 제각각이게 됩니다.  

## VO vs DTO vs DAO
DTO : 레이어 간 데이터 전달용
- DTO는 레이어 간 데이터를 전달하기 위해 자주 사용됩니다. 특히 Controller와 Service 계층 간 데이터를 전달할 때 많이 사용되는데요. getter, setter외에 비즈니스 로직을 가지지 않고 오롯이 데이터 전달만을 위해서 사용되는 것이 특징입니다.  

VO : 값 표현
- VO는 값을 표현하기 위해 사용되는 불변 객체입니다. 객체의 참조 값이 달라도, 객체가 가지고 있는 상태가 서로 같으면 같은 객체로 취급한다는 특징이 있습니다. DTO객체와의 차이점은 DTO객체는 setter를 두느냐, 두지 않느냐에 따라서 불변객체로 만들지를 선택할 수 있는 반면에, VO객체는 무조건 불변객체로 만들어야하고, 비즈니스 로직 또한 포함될 수 있다는 점이 있습니다.  

# Spring 심화
## AOP
### 개념
- Aspect Oriented Programming의 약자로, '관점 지향 프로그래밍'을 의미한다.
- AOP는 핵심적인 비즈니스 로직으로부터 '횡단 관심사'를 분리하는 것에 목적을 둔다. 즉, 부가기능을 따로 관리하는 것을 의미한다.
### 장점
- 장점 1: 전체 코드 기반에 흩어져 있는 관심 사항이 하나의 장소로 응집한다.
- 장점 2: 비즈니스 클래스에 주요 비즈니스 로직에 대한 코드만 포함하고 있기 때문에 코드가 깔끔해진다.
- 즉, 객체지향적으로 코드를 짤 수 있게 도우며 유지보수가 용이해진다.
### AOP 용어
Target : 부가기능을 적용할 대상(객체 ex. XXService)
Advice : '부가기능', 기능 + 어느 시점에 주입해 줄 것인지의 정보도 붙어있다.
Join Point : 어드바이스가 적용될 수 있는 위치(스프링 AOP에서는 메서드 실행 단계를 의미)
Point cut : 어드바이스를 적용할 조인 포인트를 선별하는 작업(스프링 AOP에서는 메서드가 Pointcut의 대상)
Advisor: 어드바이스와 포인트컷을 하나씩 가지고 있는 오브젝트(결과적으로 어떤 기능을, 어느 시점에, 어디에 주입해줄 것인지가 모두 기술되어있음)
Weaving : 조인 포인트에 어드바이스를 적용하는 방법.(스프링 AOP에서는 Runtime Weaving이라는 것을 사용해서 런타임 중에 Advice를 적용해준다) 

### 스프링 AOP의 빈 등록 과정
- 어플리케이션이 실행되면서 IoC컨테이너에 빈이 등록될 때 AOP가 적용됩니다. 컨테이너가 빈 객체를 생성한 뒤에 최종적으로 컨테이너에 등록하기 전 '빈 후처리기'라는 것을 통해서 이 빈 객체에 적용해야할 AOP가 있는지 조사합니다. 좀 더 구체적으로는 포인트컷 정보를 가지고 있는 어드바이저 리스트를 모두 순회해서 현재 등록 중인 빈에 적용해야할 AOP가 있는지 찾게 되는데요. 이를 찾았으면 프록시 객체를 생성해서 빈 객체에 부가기능을 추가해줍니다. 그 뒤에 프록시 객체를 빈으로 등록하면 빈의 메서드가 호출될 때 마다 부가기능까지 함께 수행됩니다.      

## 동적 프록시
- 프록시 패턴은 로깅, 접근 제어, 트랜젝션 등 대상 객체에 대한 수정 없이 추가 동작을 가미하고 싶을 때 사용하는 코드 패턴이다. 이 패턴을 적용하면 개방 패쇄 원칙(OCP)의 효과를 얻을 수 있어 코드 수정없이 유연하게 확장이 가능하여 유지보수 측면에서 좋은 효과를 얻을 수 있다는 장점이 있다.  
- 하지만 프록시 패턴은 프록시를 적용하고 싶은 원본 클래스 수만큼 일일히 프록시 클래스를 하나하나 만들어줘야한다는 단점이 존재한다. 이를 해결하기 위해 프록시 객체를 컴파일 시점이 아닌 런타임 시점에 동적으로 만들어주는 기술이 바로 동적 프록시 기술이다.   
## JDK Dynamic Proxy && CGLIB
- JDK Dynamic Proxy: 인터페이스 기반으로 바이트 코드를 조작
- CGLIB: 클래스 기반으로 바이트 코드를 조작

빈이 등록될 때 AOP적용 대상이 되는 빈들에 대한 동적 프록시 객체가 만들어지는데 이 떄, 해당 객체가 Interface를 하나라도 구현하고 있으면 JDK Bynamic Proxy를, Interface를 구현하고 있지 않으면 CGLIB을 이용한다.