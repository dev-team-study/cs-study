# 1. JPA
   ## 1.1 고아객체
   - 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제는 기능
   - 예를 들어, 부모라는 객체에서 여러명의 자식 객체를 `@OneToMany`로 가지고 있을 때, 또 반대로 자식 객체에서는 `@ManyToOne`을 맺고 있다고 가정하고 부모 객체에서 자식 리스트를 불러와 리스트에서 삭제했을 때, 하나의 자식 객체는 해당 리스트에서 삭제되며 연관관계가 끊어짐 -> 이때 끊어진 자식 엔티티를 자동으로 삭제 함
     - 부모를 제거해도 자식 모두 삭제 됨
   - 영속성 컨텍스트가 플러시될 때 Delete문이 나감
   - 혹시나 참조하는 곳이 여러개인 엔티티의 경우 원하던 엔티티에 의해 삭제되지 않을 수 있으므로 꼭 참조하는 엔티티는 하나여야 함 
   - orphanRemoval = true로 설정하며 `@OneToMany`에서 설정 함

   ## 1.2 단뱡향/양방향 매핑
   - 테이블 관점
     - 게시글이 있고, 댓글이 있을 때 1개의 게시글에는 여러 개의 댓글이 달릴 수 있는 1:N의 관계로 볼 수 있고 댓글의 입장에서는 하나의 댓글은 하나의 게시글에 속할 수 있음
     - 테이블은 사실 외래 키 하나로 양 쪽 테이블 조인이 가능하여 두 개의 데이터를 조회할 수 있으므로 단방향, 양방향 관계라는 것은 없음
   - 객체 관점
     - 참조용 필드가 있는 객체만 다른 객체를 참조하는 것이 가능하여 단방향 또는 양방향(단방향이 서로 마주보고 있는) 관계를 맺을 수 있음
     - 단방향
       - 두 객체 사이에 하나의 객체만 참조용 필드를 가지고 있는 경우 단방향 관계
       - `@ManyToOne`: 게시글이 있고 댓글이 있을 때 1:N 관계이므로 N인 댓글이 ManyToOne이 됨
       - `@OneToMany`: 게시글이 있고 댓글이 있을 때 1:N 관계이므로 1인 게시글이 OneToMany가 됨
     - 양방향
       - 두 객체 모두가 참조용 필드를 갖고 이는 경우 양방향 관계라고 부름
         - 사실 양방향 관계는 없고 단방향으로 이루어진 두 개의 단방향이 모여 편하게 양방향이라고 부름
       - 양방향으로 설정할 경우 외래키가 있는 곳에 즉, N쪽에 연관 관계의 주인을 표시해줘야 함
         - 게시글과 댓글이 있을 때 댓글을 변경한다고 하면 게시글을 통해 댓글을 변경할지, 댓글로 직접 변경할지 헷갈릴 수 있어서 이것을 설정하여 특정 한 곳에서만 동작시키도록 해야 함
       - 양방향 관계를 맺을 경우 코드의 복잡성 증가, 유지보수의 어려움 등 다양한 문제가 있기 때문에 사용하지 않는 것이 좋음
         - 예를 들어, 회원 테이블이 있는데 회원 특성상 여러 개의 필드와 연관 관계가 있게 됨. 이때 이 모든 필드를 양방향으로 설정하는 경우 엔티티가 비대해지고 코드를 유지보수하기 어려워짐


   ## 1.3 N + 1 문제
   - 1번 조회해야할 것을 N개 종류의 데이터 각각을 추가로 조회하게 돼서 총 N+1번 DB조회를 하게 되는 문제
   - JPA Entity 조회시 Query 한 번에 조회되는 것이 아닌 연관관계에 포함 된 다른 필드의 값을 불러오며 발생하는 현상
   - 예를 들어, 회원과 경기가 있을 때 회원에서 경기를 여러 개 만들 수 있어 `@OneToMany`로 설정했다고 가정
     - 회원이 5명인데 모든 회원을 조회할 경우 회원을 조회하고, 회원에서 가지고 있는 경기 필드를 조회할 때 한 명의 회원에 대한 경기 리스트를 불러와야하는데 회원이 5명이니 +5번의 쿼리를 더 날리는 것이죠
   - 해결 방법
     - Fetch Join
       - 연관된 엔티티나 컬렉션을 SQL을 날릴 때 한 번에 함께 조회할 수 있게 함
     - Batch Size
       - 엔티티를 조회할 때 지정된 Size만큼 SQL의 In절을 사용해서 조회할수 있게 함
# 2. 테스트 
   ## 2.1 DDD, TDD
   ### 2.1.1 DDD (Domain Driven Design)
   - 도메인 주도 개발
   - 데이터 중심의 접근법을 탈피하여 순수한 도메인의 모델과 로직에 집중
   - 기술보다 도메인이 더 높은 우선순위를 가져야 함
   - 모듈 간의 의존성은 최소화시키고, 응집성은 최대화 하는 것

   ### 2.1.2 TDD (Test Driven Development)
   - 테스트 주도 개발
   - 매우 짧은 개발 서클의 반복을 갖는 소프트웨어 개발 프로세스
   - 테스트 코드를 먼저 작성하고, 기능을 구현하고 리팩토링의 반복
    - 요구사항 이해도 향상, 안정성 증가, 코드 유지보수 쉬움
    - 코드량 증가, 생산성이 떨어짐, 진입장벽의 어려움

   ### 2.1.3 BDD (Behavior Driven Development)
   - 행동 주도 개발
   - TDD에 DDD의 스타일을 적용하여 탄생
   - 테스트 케이스 자체가 요구사항이 되도록 개발하는 방식
   - TDD에서는 단위 테스트로 작성된 테스트 코드의 가독성을 높이고 테스트 케이스에 대한 문서를 작성했으나, BDD는 이것을 통합테스트와 시나리오 테스트까지 확장하여 각각에 해당하는 문서를 대체

   ## 2.2 Junit4 vs Junit5
   ### 2.2.1 Junit이란
   - 자바 프로그래밍 언어용 유닛 테스트 프레임워크
     - 유닛 테스트: 프로그래밍에서 모든 함수와 메서드에 대한 테스트 케이스를 작성하여 의도된 대로 잘 동작하는지 검증하는 절차
       - 프로그램을 작은 단위로 쪼개어 각 단위가 정확하게 동작하는지 검사함으로써 프로그램의 안정성을 높임
   - 단정 메서드로 테스트 케이스의 수행 결과를 판별(Assert)

   ### 2.2.2 Junit4와 Junit5의 차이점
   #### Junit4
   - Vintage-engine
   - 확장성이 떨어지고 테스트 코드의 구성이 어려울 수 있음

   #### Junit5
   - Jupiter-engine
   - Junit4의 단점을 보완하여 새로운 기능들을 추가
     - 테스트 인스턴스 라이프사이클을 지원하고, 동적 테스트를 지원하며, 테스트 파라미터화 기능도 추가

   <hr>

   - 어노테이션의 차이
   - Junit4는 리플렉션에 의존했으나 의존하지 않아도 됨 -> Junit5의 Junit Platform이라는 통합 플랫폼이 제공되기 때문

   ## 2.3 단위, 통합, 인수 테스트
   ### 2.3.1 단위 테스트
   - 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트
   - 테스트 대상 단위의 크기는 엄격하게 정해져있지는 않지만 보통 클래스에서 메서드 수준으로 정해짐
   - 테스트 대상을 가장 작게해서 테스트를 간단하고 쉽게 만들어야 함

   ### 2.3.2 통합 테스트
   - 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트
   - 개발자가 변경할 수 없는 부분(외부 라이브러리)까지 묶어 검증할 때 사용
     - DB에 접근해서 수행하거나, 전체 코드의 다양한 환경이 제대로 동작하는지 확인하는데 모든 작업을 수행
   - 장점
     - 단위 테스트에서 발견하기 어려운 버그를 찾을 수 있다는 점
   - 단점
     - 단위 테스트보다 더 많은 코드를 테스트하기 때문에 신뢰성이 떨어질 수 있음
     - 어디서 에러가 발생했는지 확인하기 어려운 점

   ### 2.3.3 인수 테스트
   - 사용자의 스토리(시나리오)에 맞춰 수행하는 테스트
   - 두 테스트와는 달리 비즈니스 쪽에 초점을 둠
   - 소프트웨어 내부 코드에 관심을 갖지않고 비즈니스쪽에 관심을 두는 형태의 테스트

   ## 2.4 stub, mock
   ### 2.4.1 테스트 대역 (Test Double)
   - 테스트하려는 객체가 다른 객체들이 여러 관계가 엮여있어 사용하기 힘들 때, 대체할 수 있는 객체를 의미

   ### 2.4.2 stub(상태 검증)
   - 인스턴스화하여 구현한 가짜 객체를 이용해 실제로 동작하는 것 처럼 보이게 만드는 객체
   - 테스트 중에 만들어진 호출에 미리 준비된 답변을 제공하며 일반적으로 테스트 위해 프로그래밍된 것 외에는 응답하지 않음
   ### 2.4.3 mock(행위 검증)
   - 호출에 대한 기대를 명세하고, 내용에 따라 동작하도록 프로그래밍 된 객체
   - 예상되는 기대값으로 미리 프로그래밍 된 객체

   #### 상태 검증
   - 메서드가 수행된 후, 객체의 상태를 확인하여 올바르게 동작했는지를 확인
   - assertThat
   #### 행위 검증
   - 메서드의 리턴 값으로 판단할 수 없는 경우, 특정 동작을 수행하는지 확인하는 검증 법
   - verify

   ## 2.5 SpringBoot 계층별 테스트 방법
   - Domain
     - 순수 도메인 클래스의 경우 의존성이 없으므로 순수 단위 테스트를 진행하면 됨
   - Repository
     - 관련된 데이터베이스 프레임워크를 이용하게되는데 보통 JPA를 사용하게되면 `@DataJpaTest` 테스트를 이용
     - 저장을 위한 JPA 연관 관계와, 메서드가 제대로 구현되었는지 테스트를 확인하는 것이 목적
     - `@SpringBootTest`와 `@DataJpaTest`의 차이점은?
       - SpringBootTest는 실제 DB Insert쿼리가 나가고 DataJpaTest는 쿼리가 나가지 않음
         - `@DataJpaTest`의 어노테이션을 보면 해당 어노테이션에 `@Transactional`이 붙어있음
         - `@Transactional`이 붙어있으면 테스트에서는 SELECT를 제외한 나머지 코드는 Rollback의 대상으로 취급
   - Service
     - 데이터의 CRUD를 Repository에 위임하고 트랜잭션을 관리하고, 비즈니스 로직을 수행하는 것이 주요 책임
     - Repository의 확인은 Repository에서 확인했으므로 메서드가 호출되는지 정도만 파악하면 되며 Mock 객체를 given으로 주어 정상적인 테스트가 가능하도록 설정 함
   - Controller 
     - 사용자의 요청 데이터를 서비스에 전달해주고, 서비스가 반환하는 결과를 클라이언트에게 반환 하는 부분
     - 컨트롤러는 보통 로직이 많지 않아 Mock 테스틑 하기보다는 실제 서비스 및 도메인 계층을 대상으로 통합 테스트를 작성하여 전체적인 데이터가 잘 나오는지 확인 함

   ## 2.6 테스트 커버리지 (JACOCO)
   - 시스템 및 소프트웨어에 대해 충분히 테스트가 되었는지를 나타내는 정도
   ### 2.6.1 코드 커버리지
   - 테스트에 의해 실행된 소스 코드의 양을 나타낸 것
   - 즉, 테스트로 코드가 얼마나 커버되었는지 나타내는 것

   ### 필요성
   - 테스트 코드는 발생할 수 있는 모든 시나리오에 대해 작성되어야 하는데, 이때 코드 커버리지는 테스트를 수치화하여 미쳐 놓친 코드의 구멍을 보완할 수 있게 해줌

   ### 코드 커버리지 기준
   #### 구문 커버리지
   - 라인 커버리지라고도 하며 코드 한 줄이 한 번 이상 실행된다면 충족
   - 조건에 따른 모든 로직을 확인하기보다 모든 코드가 실행되었는지 확인
   #### 결정 커버리지
   - 브랜치 커버리지
   - 조건식이 True/False를 가지는 경우 충족
   - IF문에 대한 테스트 코드가 동작하는 경우
   #### 조건 커버리지
   - 모든 내부 조건에 대해 True/False를 가지게 되면 충족
   - IF문에 조건이 여러 개가 있을 때 해당 모든 조건에 대해 검사하는 것

   ### 2.6.2 JACOCO
   - 코드 커버리지 측정을 하는 툴
   - build.gradle에 별도의 설정을 한 후
   - 빌드된 이후에 build 파일안에 JacocoReport가 생김
   - 해당 Index 페이지를 열어보면 측정된 커버리지가 나옴