## Spring 심화

> ### interceptor 
>
> Spring이 제공하는 기술로써, Dispatcher Servlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다. 
>
> 디스패처 서블릿은 핸들러 매핑을 통해 적절한 컨트롤러를 찾도록 요청하는데, 그 결과로 실행 체인(Handler Execution Chain)을 반환한다. 이 실행 체인의 경우 1개 이상의 인터셉터가 등록되어 있다면 순차적으로 인터셉터들을 거쳐 컨트롤러가 실행되도록 하고, 인터셉터가 없다면 바로 컨트롤러를 실행한다. 
>
> [메소드]
>
> - preHandle
>   - 컨트롤러가 호출 되기 전에 실행된다. 
>   - 컨트롤러 이전에 처리해야하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용
>   - return 값이 false일 경우 작업을 중단해 이후의 작업이 진행되지 않는다.
> - postHandle
>   - 컨트롤러가 호출된 후에 실행된다.
>   - 컨트롤러 이후에 처리해야하는 후처리 작업이 있을 때 사용
>   - 컨트롤러 하위 계층에서 작업을 진행하다가 중간에 예외가 발생하면 postHandle은 호출되지 않는다.
> - afterCompletion
>   - 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행된다. 
>   - 요청 처리 중에 사용한 리소스를 반환할 때 사용하기에 적합
>   - postHandle과 달리 중간에 예외가 발생하더라도 무조건 실행된다. 
>
> #### 	filter와 차이점
>
> |                     대상                     |                            Filter                            |                         Interceptor                          |
> | :------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> |              관리되는 컨테이너               |                      Servlet Container                       |                       Spring Container                       |
> |            스프링의 예외처리 여부            |                              X                               |                              O                               |
> | Request / Response <br />객체 조작 가능 여부 |                              O                               |                              X                               |
> |                     용도                     | - 공통 보안 및 인증/인가 관련 작업<br />-모든요청에 대한 로깅 또는 감사<br />-이미지/데이터 압축 및 문자열 인코딩<br />-Spring과 분리되어야 하는 기능 | - 세부적인보안 및 인증/인가 공통 작업<br />-API 호출에 대한 로깅 또는 감사<br />-Controller로 넘겨주는 정보의 가공 |
>
> ### Spring 전체 동작과정
>
> 1. 클라이언트의 요청을 디스패처 서블릿이 받는다.
> 2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾는다.
> 3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달한다.
> 4. 핸들러 어댑터가 컨트롤러로 요청을 위임
> 5. 비즈니스 로직을 처리
> 6. 컨트롤러가 반환값을 반환
> 7. 핸들러 어댑터가 반환값을 처리
> 8. 서버의 응답을 클라이언트로 반환

## JPA

> ### JDBC, Spring JDBC
>
> JDBC, Spring JDBC 모두 Java에서 데이터베이스 작업을 수행하기 위한 접근 방식이다. 
>
> 하지만 일부 차이점이 존재한다. 
>
> - 추상화의 정도
>   - JDBC 
>     - Java의 표준 SQL 인터페이스로, 직접적인 데이터베이스 연결 및 SQL 쿼리 실행을 위한 낮은 수준의 API 제공
>     - 개발자는 연결 관리, SQL 쿼리 작성, 결과셋 처리, 예외처리등을 직접 해야 함
>   - Spring JDBC
>     - Spring 프레임워크의 일부로, JDBC 위에 구축된 높은 수준의 추상화를 제공 
>     - 반복되는 코드 작성 부담을 줄여주고, 예외처리, 리소스 관리, 템플릿 기반의 접근 방식을 통한 간결한 코드 작성이 가능 
> - 코드의 간결 성 및 유지 관리 
>   - JDBC 
>     - 연결 관리, SQL 쿼리 작성, 결과 처리 등을 직접 관리해야 하므로 코드가 길고 복잡해 질 수 있다. 
>   - Spring JDBC
>     - JdbcTemplate과 같은 템플릿 클래스를 제공해 공통 작업을 간소화 한다.
> - 예외 처리 
>   - JDBC 
>     - SQL 예외를 직접 처리해야 한다. 
>   - Spring JDBC 
>     - 일관된 런타임 예외 계층을 제공해 개발자가 데이터베이스 예외를 더욱 쉽게 처리 할 수 있게 한다. 
> - 템플릿 디자인 패턴 
>   - JDBC 
>     - 개발자가 직접 반복되는 패턴을 관리해야 한다. 
>   - Spring JDBC
>     - JdbcTemplate과 같은 템플릿 클래스를 사용해 반복되는 작업을 간소화 할 수 있고, 일반적인 패턴을 재사용 할 수 있다. 
> - 리소스 관리 
>   - JDBC 
>     - connection, Statement, ResultSet 등의 리소스를 직접 열고 닫아야 한다. 
>     - 자칫하면 리소스 누수를 초래할 수 있는 복잡한 과정
>   - SpringJDBC
>     - 자동 리소스 관리를 제공해, 개발자가 리소스를 수동으로 닫는 것에 대한 걱정을 덜어준다. 
> - 통합 및 확장성 
>   - JDBC 
>     - 다른 프레임워크나 라이브러리와의 통합은 개발자의 책임
>   - Spring JDBC
>     - Spring 프레임워크와 자연스럽게 통합되어 있으며, Spring의 다른 기능과 쉽게 결합 할 수 있다.
>
> ### Sql Mapper(MyBatis), ORM
>
> 데이터베이스와의 상호작용을 단순화하는 두가지의 다른 기술이다. 
>
> 각각 데이터베이스와 애플리케이션 코드 간의 매핑을 다루는 방식에 있어 차이가 존재한다. 
>
> SQL Mapper 
>
> - 정의 
>   - SQL Mapper는 데이터베이스 쿼리를 직접 작성하고 실행할 수 있게 해주는 도구. 
> - 접근 방식 
>   - 개발자는 SQL 쿼리를 직접 작성하고, 이 쿼리를 애플리케이션의 데이터 객체에 매핑한다.
>   -  SQL 매퍼는 이러한 쿼리와 매핑 정보를 관리한다.
> - 제어 
>   - 개발자는 쿼리 최적화 및 성능 조정에 대한 더 많은 제어권을 가진다.
>   - 복잡하고 세밀한 쿼리를 작성할 수 있다.
> - 사용 사례
>   - 성능이 중요하거나, 데이터베이스 구조가 복잡하고 맞춤화된 쿼리가 필요한 상황에 적합
>
> ORM
>
> - 정의 
>   - ORM은 데이터베이스 테이블을 객체로 매핑해, 개발자가 SQL을 직접 작성하지 않고도 데이터베이스를 조작할 수 있게 해주는 기술.
> - 접근 방식
>   - 객체 지향 프로그래밍 패러다임을 따르며, 데이터베이스 테이블을 클래스로, 레코드를 객체로 표현한다.
>   - ORM 프레임워크가 대부분의 SQL 쿼리를 자동으로 생성한다.
> - 제어
>   - SQL 쿼리의 자동화로 인해 세밀한 쿼리 최적화에 대한 제어가 줄어든다.
>   - 데이터베이스와의 상호작용을 객체 지향적으로 처리할 수 있어 개발의 간결겅과 유지 관리성이 향상된다.
> - 사용 사례
>   - 객체 지향 프로그래밍과 데이터베이스 간의 불일치를 해소하려는 상황 혹은 빠른 개발 속도와 유지 관리의 용이성이 중요한 프로젝트에 적합
>
> ### JPA, Hibernate
>
> JPA와 Hibernate는 Java 기반의 데이터 지속성을 관리하는데 사용되는 기술이다. 
>
> JPA (Java Persistence API)
>
> - 정의 
>   - JPA는 Java EE 플랫폼의 일부로, 객체-관계 매핑을 위한 표준 API를 제공한다. 
>   - JPA는 ORM을 구현하기 위한 명세이며, 실제 구현은 JPA Provider에 의해 이루어진다.
> - 목적 
>   - JPA는 데이터베이스 테이블과, Java 객체 간의 매핑을 정의하고, 데이터베이스 작업을 위한 표준 API를 제공한다.
> - 구현체
>   - JPA는 명세이기 때문에, Hibernate, EclipseLink, OpenJPA 등과 같은 여러 구현체가 존재한다.
>
> Hibernate
>
> - 정의 
>   - Hiberantesms JPA의 가장 유명한 구현체 중 하나로, 객체-데이터베이스 관계 매핑을 위한 프레임워크이다.
> - 기능
>   - Hibernate는 데이터베이스와 객체 지향 프로그래밍 사이의 불일치 문제를 해결하기 위해 설계되었다.
> - 확장성
>   - Hibernatesms JPA명세를 넘어서는 다양한 추가 기능과 성능 최적화 옵션을 제공한다. 
>
> ### 영속성 컨텍스트
>
> 영속성 컨텍스트는 일종의 버퍼 역할을 하며, 애플리케이션과 데이터베이스 사이에서 엔티티의 생명 주기를 관리한다.
>
> - 엔티티 생명주기 관리
>   - 영속성 컨텍스트는 엔티티 객체의 생명주기를 관리한다. 
>   - 상태는 new, managed, detached, removed 
> - 1차 캐시
>   - 엔티티 매니저를 통해 조회 또는 변경된 엔티티는 먼저 영속성 컨텍스트에 저장된다. 
>   - 이후 같은 엔티티에 대한 조회 요청이 있을 때에는 데이터베이스에 접근하지 않고 1차 캐시에서 엔티티를 반환한다.
> - 변경 감지 
>   - 영속성 컨텍스트는 엔티티의 변경을 추적한다.
>   - 트랜잭션을 커밋할 때, 영속성 컨텍스트는 1차 캐시에 있는 엔티티와 데이터베이스의 상태를 비교해 변경된 사항이 있는 지확인한다.
>   - 변경이 감지되면, 이를 데이터베이스에 자동으로 반영한다.
> - 지연 로딩
>   - 영속성 컨텍스트는 필요할 때 까지 엔티티의 로딩을 지연시킬 수 있다. 
>   - ex) 연관된 엔티티를 즉시 로드하지 않고, 실제로 사용 될 때 로드하는 방식.
> - 트랜잭션 범위 내에서의 일관성
>   - 영속성 컨텍스트는 하나의 트랜잭션 범위 안에서 엔티티에 대한 일관성을 보장한다.
>   - 같은 트랜잭션 내에서는 같은 엔티티 인스턴스에 대해 동일한 데이터 뷰를 유지한다. 
>
> ### 즉시/지연 로딩
>
> JPA에서 관계를 가진 엔티티를 로드하는 두가지 전략이다.
>
> 즉시 로딩 
>
> - 정의 
>   - 엔티티를 로드할 때, 관련된 모든 연관 엔티티나 컬렉션도 함께 즉시 로드하는 전략.
> - 동작
>   - User 엔티티에 Order 엔티티가 연관되어 있다면, User 엔티티 로드시 연관된 Order 엔티티도 동시에 로드 된다.
> - 장점
>   - 연관된 데이터가 필요한 경우, 추가적인 쿼리 없이 바로 사용할 수 있다.
> - 단점
>   - 필요하지 않은 데이터까지 로드 할 수 있어 성능에 부정적인 영향을 미칠 수 있다.
>   - 특히 연관된 데이터가 많거나, 복잡한 경우, 성능 저하의 원인이 될 수 있다.
>
> 지연로딩
>
> - 정의 
>   - 엔티티를 로드할 때, 연관된 에티티나 컬렉션을 실제로 사용할 때 까지 로드하지 않는 전략
> - 동작
>   - 위 예시에서 User 엔티티 조회시 Order 엔티티는 로드하지 않는다.
>   - Order 데이터에 접근하는 시점에 해당 데이터를 로드하는 쿼리가 실행된다.
> - 장점
>   - 필요한 시점에만 데이터를 로드하므로 초기 로드 시간을 줄이고, 자원을 효율적으로 사용할 수 있다.
> - 단점
>   - 실제 데이터에 접근 할 때 마다 추가적인 쿼리가 발생할 수 있으므로, 네트워크 지연이나 쿼리 오버헤드가 발생할 수 있다.
>
> ### 프록시
>
> JPA에서 프록시는 실제 엔티티 객체를 상속받아 생성된 객체로, 실제 엔티티의 참조를 지연 로딩 방식으로 관리하기 위해 사용된다. 프록시는 데이터베이스의 실제 데이터를 담고 있는 것 처럼 동작하지만, 실제로는 필요한 시점까지 데이터를 로드하지 않는다.
>
> - 지연 로딩
>   - 프록시는 주로 지연 로딩 설정이 있는 관계에서 사용된다.
>   - JPA는 엔티티의 연관된 객체를 즉시 로드하지 않고, 프록시 객체를 반환해 해당 객체가 실제로 사용될 때 까지 로드를 지연시킨다.
> - 프록시 객체의 초기화
>   - 프록시 객체에 처음 접근할 때, JPA는 데이터베이스에서 실제 엔티티 데이터를 로드하고 프록시 객체를 초기화 한다.
>   - 이후 프록시 객체는 실제 엔티티처럼 동작하며, 실제 엔티티 데이터에 접근할 수 있다.
> - 투명성
>   - 프록시 객체는 실제 엔티티를 상속받기 때문에, 프록시 객체를 실제 엔티티와 동일하게 사용할 수 있다.
> - 프록시의 특징
>   - 프록시 객체는 처음 사용될 때 한번 초기화 된다. 
>   - 초기화 이후에는 해당 프록시 인스턴스를 통해 여러번 데이터에 접근할 수 있다.
>   - 프록시 객체는 엔티티와 동일한 식별자를 가진다.
> - 주의사항
>   - 프록시 객체는 영속성 컨텍스트가 활성화된 상태에서만 올바르게 초기화 된다.
>   - 영속성 컨텍스트가 종료되거나 분리된 상태에서 프록시를 초기화 하고자 한다면 예외가 발생할 수 있다. 

